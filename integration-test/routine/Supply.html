<!doctype html>
<html lang="en">
<head>
    <title>method Supply</title>
    <meta charset="UTF-8"/>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <link rel="icon" href="/Documentable/integration-test/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" type="text/css" href="/Documentable/integration-test/css/app.css" media="screen" title="default" />
    <noscript> <style> #search { visibility: hidden; } </style> </noscript>
</head>

<body class="pod">

    <div id="___top"></div>

    <div id="header" class="pretty-box green">

        <a href="/Documentable/integration-test/">
            <img src="/Documentable/integration-test/images/Camelia.svg"alt="»ö«"id="logo"width="62"height="48"/> &nbsp;Raku Documentation
        </a>

        <div id="search" class="ui-widget">
            <div class="green">
                <input placeholder="Loading..." id="query" accesskey="f" title="Enter term to search for (hit Esc to focus)"/>
            </div>
            <p id="not-found-message">
                Not in Index (<a href="" id="try-web-search">try site search</a>)
            </p>
        </div>
        
        <div class="menu">
            
            <div class="menu-items dark-green">
                <a class='menu-item darker-green' href='https://raku.org'><strong>Raku homepage</strong></a>
                    <a class="menu-item " href="/Documentable/integration-test/language.html"> Language </a>
                    <a class="menu-item " href="/Documentable/integration-test/type.html"> Types </a>
                    <a class="menu-item selected darker-green" href="/Documentable/integration-test/routine.html"> Routines </a>
                    <a class="menu-item " href="https://webchat.freenode.net/?channels=#raku"> Chat with us </a>
            </div>
            
            <div class="menu-items darker-green"><div class="menu-items darker-green"><div class="menu-items darker-green"><div class="menu-items darker-green">
                    <a class="menu-item" href="/Documentable/integration-test/routine.html"> All </a>
                    <a class="menu-item" href="/Documentable/integration-test/routine-sub.html"> Sub </a>
                    <a class="menu-item" href="/Documentable/integration-test/routine-method.html"> Method </a>
                    <a class="menu-item" href="/Documentable/integration-test/routine-submethod.html"> Submethod </a>
            </div></div></div></div>
        
        </div>
    </div>

    <div id="content" class="pretty-box yellow content_fragment">

        <div align="right" style="display:none;">
            <button title="Edit this page"  class="pencil" onclick="location=''">
                <svg width="14px" height="16px" viewBox="0 0 14 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                    <defs></defs>
                    <g id="Octicons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g id="pencil" fill="#000000">
                            <path d="M0,12 L0,15 L3,15 L11,7 L8,4 L0,12 L0,12 Z M3,14 L1,14 L1,12 L2,12 L2,13 L3,13 L3,14 L3,14 Z M13.3,4.7 L12,6 L9,3 L10.3,1.7 C10.69,1.31 11.32,1.31 11.71,1.7 L13.3,3.29 C13.69,3.68 13.69,4.31 13.3,4.7 L13.3,4.7 Z" id="Shape"></path>
                        </g>
                    </g>
                </svg>
            </button>
        </div>

        <h1 class="title">method Supply</h1>
        <p class="subtitle"></p>

        <nav class="indexgroup">
<table id="TOC">
<caption><h2 id="TOC_Title">Table of Contents</h2></caption>
    <tr class="toc-level-1"><td class="toc-number">1</td><td class="toc-text"><a href="#class_Supplier">class Supplier</a></td></tr>
   <tr class="toc-level-2"><td class="toc-number">1.1</td><td class="toc-text"><a href="#(Supplier)_method_Supply">(Supplier) method Supply</a></td></tr>
       <tr class="toc-level-1"><td class="toc-number">2</td><td class="toc-text"><a href="#class_Channel">class Channel</a></td></tr>
   <tr class="toc-level-2"><td class="toc-number">2.1</td><td class="toc-text"><a href="#(Channel)_method_Supply">(Channel) method Supply</a></td></tr>
                <tr class="toc-level-1"><td class="toc-number">3</td><td class="toc-text"><a href="#class_Promise">class Promise</a></td></tr>
   <tr class="toc-level-2"><td class="toc-number">3.1</td><td class="toc-text"><a href="#(Promise)_method_Supply">(Promise) method Supply</a></td></tr>
               <tr class="toc-level-1"><td class="toc-number">4</td><td class="toc-text"><a href="#class_Proc::Async">class Proc::Async</a></td></tr>
   <tr class="toc-level-2"><td class="toc-number">4.1</td><td class="toc-text"><a href="#(Proc::Async)_method_Supply">(Proc::Async) method Supply</a></td></tr>
                                              <tr class="toc-level-1"><td class="toc-number">5</td><td class="toc-text"><a href="#class_Any">class Any</a></td></tr>
   <tr class="toc-level-2"><td class="toc-number">5.1</td><td class="toc-text"><a href="#(Any)_method_Supply">(Any) method Supply</a></td></tr>
          <tr class="toc-level-1"><td class="toc-number">6</td><td class="toc-text"><a href="#class_IO::CatHandle">class IO::CatHandle</a></td></tr>
   <tr class="toc-level-2"><td class="toc-number">6.1</td><td class="toc-text"><a href="#(IO::CatHandle)_method_Supply">(IO::CatHandle) method Supply</a></td></tr>
                                 <tr class="toc-level-1"><td class="toc-number">7</td><td class="toc-text"><a href="#class_IO::Handle">class IO::Handle</a></td></tr>
   <tr class="toc-level-2"><td class="toc-number">7.1</td><td class="toc-text"><a href="#(IO::Handle)_method_Supply">(IO::Handle) method Supply</a></td></tr>
                                    <tr class="toc-level-1"><td class="toc-number">8</td><td class="toc-text"><a href="#class_IO::Socket::Async">class IO::Socket::Async</a></td></tr>
   <tr class="toc-level-2"><td class="toc-number">8.1</td><td class="toc-text"><a href="#(IO::Socket::Async)_method_Supply">(IO::Socket::Async) method Supply</a></td></tr>
                            
</table>
</nav>

        <div class="pod-body ">
            <p>Documentation for method <code>Supply</code> assembled from the following types:</p>
<h1 id="class_Supplier"><a class="u" href="#___top" title="go to top of document">class Supplier</a></h1>
<p>From <a href="/Documentable/integration-test/type/Supplier#method_Supply">Supplier</a></p>
<h2 id="(Supplier)_method_Supply"><a href="/Documentable/integration-test/type/Supplier#method_Supply">(Supplier) method Supply</a></h2>
<pre class="pod-block-code">method Supply(Supplier:D: --&gt; Supply)</pre>
<p>This creates a new <code>Supply</code> object to which any values which are emitted on this supplier are passed. This is the factory for all <code>live</code> supplies.</p>
<h1 id="class_Channel"><a class="u" href="#___top" title="go to top of document">class Channel</a></h1>
<p>From <a href="/Documentable/integration-test/type/Channel#method_Supply">Channel</a></p>
<h2 id="(Channel)_method_Supply"><a href="/Documentable/integration-test/type/Channel#method_Supply">(Channel) method Supply</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Supply(Channel:D:)</pre>
<p>This returns an <code>on-demand</code> <a href="/Documentable/integration-test/type/Supply">Supply</a> that emits a value for every value received on the Channel. <code>done</code> will be called on the <code>Supply</code> when the <a href="/Documentable/integration-test/type/Channel">Channel</a> is closed.</p>
<pre class="pod-block-code">my $c = Channel.new;
my Supply $s1 = $c.Supply;
my Supply $s2 = $c.Supply;
$s1.tap(-&gt; $v { say &quot;First $v&quot; });
$s2.tap(-&gt; $v { say &quot;Second $v&quot; });
^10 .map({ $c.send($_) });
sleep 1;</pre>
<p>Multiple calls to this method produce multiple instances of Supply, which compete over the values from the Channel.</p>
<h1 id="class_Promise"><a class="u" href="#___top" title="go to top of document">class Promise</a></h1>
<p>From <a href="/Documentable/integration-test/type/Promise#method_Supply">Promise</a></p>
<h2 id="(Promise)_method_Supply"><a href="/Documentable/integration-test/type/Promise#method_Supply">(Promise) method Supply</a></h2>
<pre class="pod-block-code">method Supply(Promise:D:)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Supply">Supply</a> that will emit the <code>result</code> of the <a href="/Documentable/integration-test/type/Promise">Promise</a> being Kept or <code>quit</code> with the <code>cause</code> if the <a href="/Documentable/integration-test/type/Promise">Promise</a> is Broken.</p>
<h1 id="class_Proc::Async"><a class="u" href="#___top" title="go to top of document">class Proc::Async</a></h1>
<p>From <a href="/Documentable/integration-test/type/Proc::Async#method_Supply">Proc::Async</a></p>
<h2 id="(Proc::Async)_method_Supply"><a href="/Documentable/integration-test/type/Proc::Async#method_Supply">(Proc::Async) method Supply</a></h2>
<pre class="pod-block-code">multi method Supply(Proc::Async:D: :$bin!)
multi method Supply(Proc::Async:D: :$enc, :$translate-nl)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Supply">Supply</a> of merged <a href="/Documentable/integration-test/routine/stdout">stdout</a> and <a href="/Documentable/integration-test/routine/stderr">stderr</a> streams. If <code>:$bin</code> named argument is provided, the <code>Supply</code> will be binary, producing <a href="/Documentable/integration-test/type/Buf">Buf</a> objects, otherwise, it will be in character mode, producing <a href="/Documentable/integration-test/type/Str">Str</a> objects and <code>:$enc</code> named argument can specify <a href="/Documentable/integration-test/routine/encoding">encoding</a> to use. The <code>:$translate-nl</code> option specifies whether new line endings should be translated for to match those used by the current operating system (e.g. <code>\r\n</code> on Windows).</p>
<pre class="pod-block-code">react {
    with Proc::Async.new: «&quot;$*EXECUTABLE&quot; -e &#39;say 42; note 100&#39;» {
        whenever .Supply { .print }  # OUTPUT: «42␤100␤»
        whenever .start {}
    }
}
</pre>
<p>It is an error to create both binary and non-binary <a href="/Documentable/integration-test/type/Proc::Async#method_Supply"><code>.Supply</code></a>. It is also an error to use both <a href="/Documentable/integration-test/type/Proc::Async#method_Supply"><code>.Supply</code></a> and either <a href="/Documentable/integration-test/routine/stderr">stderr</a> or <a href="/Documentable/integration-test/routine/stdout">stdout</a> supplies.</p>
<h1 id="class_Any"><a class="u" href="#___top" title="go to top of document">class Any</a></h1>
<p>From <a href="/Documentable/integration-test/type/Any#method_Supply">Any</a></p>
<h2 id="(Any)_method_Supply"><a href="/Documentable/integration-test/type/Any#method_Supply">(Any) method Supply</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Supply(--&gt; Supply:D) is nodal</pre>
<p>First, it coerces the invocant to a <code>list</code> by applying its <a href="/Documentable/integration-test/routine/list"><code>.list</code></a> method, and then to a <a href="/Documentable/integration-test/type/Supply">Supply</a>.</p>
<h1 id="class_IO::CatHandle"><a class="u" href="#___top" title="go to top of document">class IO::CatHandle</a></h1>
<p>From <a href="/Documentable/integration-test/type/IO::CatHandle#method_Supply">IO::CatHandle</a></p>
<h2 id="(IO::CatHandle)_method_Supply"><a href="/Documentable/integration-test/type/IO::CatHandle#method_Supply">(IO::CatHandle) method Supply</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Supply(IO::CatHandle:D: :$size = 65536 --&gt; Supply:D)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Supply">Supply</a> fed with either <a href="/Documentable/integration-test/type/IO::CatHandle#method_read"><code>.read</code></a>, if the handle is in <a href="/Documentable/integration-test/type/IO::CatHandle#method_encoding">binary mode</a>, or with <a href="/Documentable/integration-test/type/IO::CatHandle#method_readchars"><code>.readchars</code></a>, if it isn&#39;t, with reads of <code>:$size</code> bytes or characters. <code>:$size</code> defaults to an implementation-specific value (in Rakudo, the value of <code>$*DEFAULT-READ-ELEMS</code>, which by default is set to <code>65536</code>).</p>
<pre class="pod-block-code">(my $f1 = &#39;foo&#39;.IO).spurt: &#39;foo&#39;;
(my $f2 = &#39;bar&#39;.IO).spurt: &#39;bar&#39;;
react whenever IO::CatHandle.new($f1, $f2).Supply: :2size {.say}
# OUTPUT: «fo␤ob␤ar␤»

react whenever IO::CatHandle.new(:bin, $f1, $f2).Supply: :2size {.say}
# OUTPUT: «Buf[uint8]:0x&lt;66 6f&gt;␤Buf[uint8]:0x&lt;6f 62&gt;␤Buf[uint8]:0x&lt;61 72&gt;␤»
</pre>
<h1 id="class_IO::Handle"><a class="u" href="#___top" title="go to top of document">class IO::Handle</a></h1>
<p>From <a href="/Documentable/integration-test/type/IO::Handle#method_Supply">IO::Handle</a></p>
<h2 id="(IO::Handle)_method_Supply"><a href="/Documentable/integration-test/type/IO::Handle#method_Supply">(IO::Handle) method Supply</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method Supply(IO::Handle:D: :$size = 65536)</pre>
<p>Returns a <code>Supply</code> that will emit the contents of the handle in chunks. The chunks will be <a href="/Documentable/integration-test/type/Buf"><code>Buf</code></a> if the handle is in binary mode or, if it isn&#39;t, <a href="/Documentable/integration-test/type/Str"><code>Str</code></a> decoded using same encoding as <a href="/Documentable/integration-test/routine/encoding"><code>IO::Handle.encoding</code></a>.</p>
<p>The size of the chunks is determined by the optional <code>:size</code> named parameter and <code>65536</code> bytes in binary mode or <code>65536</code> characters in non-binary mode.</p>
<pre class="pod-block-code">&quot;foo&quot;.IO.open(:bin).Supply(:size&lt;10&gt;).tap: *.raku.say;
# OUTPUT:
# Buf[uint8].new(73,32,226,153,165,32,80,101,114,108)
# Buf[uint8].new(32,54,33,10)

&quot;foo&quot;.IO.open.Supply(:size&lt;10&gt;).tap: *.raku.say;
# OUTPUT:
# &quot;I ♥ Perl&quot;
# &quot; 6!\n&quot;
</pre>
<h1 id="class_IO::Socket::Async"><a class="u" href="#___top" title="go to top of document">class IO::Socket::Async</a></h1>
<p>From <a href="/Documentable/integration-test/type/IO::Socket::Async#method_Supply">IO::Socket::Async</a></p>
<h2 id="(IO::Socket::Async)_method_Supply"><a href="/Documentable/integration-test/type/IO::Socket::Async#method_Supply">(IO::Socket::Async) method Supply</a></h2>
<pre class="pod-block-code">method Supply(:$bin, :$buf = buf8.new --&gt; Supply)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Supply">Supply</a> which can be tapped to obtain the data read from the connected <a href="/Documentable/integration-test/type/IO::Socket::Async">IO::Socket::Async</a> as it arrives. By default the data will be emitted as characters, but if the <code>:bin</code> adverb is provided a <a href="/Documentable/integration-test/type/Buf">Buf</a> of bytes will be emitted instead, optionally in this case you can provide your own <code>Buf</code> with the <code>:buf</code> named parameter.</p>
<p>A UDP socket in character mode will treat each packet as a complete message and decode it. In the event of a decoding error, the <code>Supply</code> will <code>quit</code>.</p>
<p>On the other hand, a TCP socket treats the incoming packets as part of a stream, and feeds the incoming bytes into a streaming decoder. It then emits whatever characters the decoder considers ready. Since strings work at grapheme level in Raku, this means that only known complete graphemes will be emitted. For example, if the UTF-8 encoding were being used and the last byte in the packet decoded to <code>a</code>, this would not be emitted since the next packet may include a combining character that should form a single grapheme together with the <code>a</code>. Control characters (such as <code>\n</code>) always serve as grapheme boundaries, so any text-based protocols that use newlines or null bytes as terminators will not need special consideration. A TCP socket will also <code>quit</code> upon a decoding error.</p>

        </div>
    </div>

    

    <footer class="pretty-box yellow">
        <p>
            Generated from <a href="https://github.com/Raku/doc/tree/master/docs/">https://github.com/Raku/doc/tree/master/docs/</a>.
        </p>
        <p>
            This is a work in progress to document Raku (formerly known as Perl 6), and
            known to be incomplete.
        </p>
        <p>
            <a href="https://github.com/raku/doc/blob/master/CONTRIBUTING.md#reporting-bugs">
                Please report any issues
            </a>
            Your contribution is appreciated.
        </p>
        <p>
            This documentation is provided under the terms of the
            <a href="https://raw.githubusercontent.com/raku/doc/master/LICENSE">
                Artistic License 2.0
            </a>. The Camelia image is
            <a href="https://raw.githubusercontent.com/raku/mu/master/misc/camelia.txt">
                copyright © 2009 by Larry Wall.
            </a>
            <!-- CREDITS -->
            <!--External Link Image by Zapyon, CCA-SA 4.0. Derived from Wikimedia Foundation https://commons.wikimedia.org/wiki/File:External-link-04-bold-12x12.svg -->
        </p>
    </footer>

    <script type="text/javascript" src="/Documentable/integration-test/js/app.js?v=1"></script>
    <script type="text/javascript" src="/Documentable/integration-test/js/search.js?v=3"></script>
</body>
</html>


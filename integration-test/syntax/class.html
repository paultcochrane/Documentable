<!doctype html>
<html lang="en">
<head>
    <title>syntax class</title>
    <meta charset="UTF-8"/>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <link rel="icon" href="/Documentable/integration-test/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" type="text/css" href="/Documentable/integration-test/css/app.css" media="screen" title="default" />
    <noscript> <style> #search { visibility: hidden; } </style> </noscript>
</head>

<body class="pod">

    <div id="___top"></div>

    <div id="header" class="pretty-box green">

        <a href="/Documentable/integration-test/">
            <img src="/Documentable/integration-test/images/Camelia.svg"alt="»ö«"id="logo"width="62"height="48"/> &nbsp;Raku Documentation
        </a>

        <div id="search" class="ui-widget">
            <div class="green">
                <input placeholder="Loading..." id="query" accesskey="f" title="Enter term to search for (hit Esc to focus)"/>
            </div>
            <p id="not-found-message">
                Not in Index (<a href="" id="try-web-search">try site search</a>)
            </p>
        </div>
        
        <div class="menu">
            
            <div class="menu-items dark-green">
                <a class='menu-item darker-green' href='https://raku.org'><strong>Raku homepage</strong></a>
                    <a class="menu-item " href="/Documentable/integration-test/language.html"> Language </a>
                    <a class="menu-item " href="/Documentable/integration-test/type.html"> Types </a>
                    <a class="menu-item " href="/Documentable/integration-test/routine.html"> Routines </a>
                    <a class="menu-item " href="https://webchat.freenode.net/?channels=#raku"> Chat with us </a>
            </div>
            
            
            
        
        </div>
    </div>

    <div id="content" class="pretty-box yellow content_fragment">

        <div align="right" style="display:none;">
            <button title="Edit this page"  class="pencil" onclick="location=''">
                <svg width="14px" height="16px" viewBox="0 0 14 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                    <defs></defs>
                    <g id="Octicons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g id="pencil" fill="#000000">
                            <path d="M0,12 L0,15 L3,15 L11,7 L8,4 L0,12 L0,12 Z M3,14 L1,14 L1,12 L2,12 L2,13 L3,13 L3,14 L3,14 Z M13.3,4.7 L12,6 L9,3 L10.3,1.7 C10.69,1.31 11.32,1.31 11.71,1.7 L13.3,3.29 C13.69,3.68 13.69,4.31 13.3,4.7 L13.3,4.7 Z" id="Shape"></path>
                        </g>
                    </g>
                </svg>
            </button>
        </div>

        <h1 class="title">syntax class</h1>
        <p class="subtitle"></p>

        <nav class="indexgroup">
<table id="TOC">
<caption><h2 id="TOC_Title">Table of Contents</h2></caption>
    <tr class="toc-level-1"><td class="toc-number">1</td><td class="toc-text"><a href="#language_documentation_Object_orientation">language documentation Object orientation</a></td></tr>
   <tr class="toc-level-2"><td class="toc-number">1.1</td><td class="toc-text"><a href="#(Object_orientation)_declarator_class_class">(Object orientation) declarator class class</a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">1.2</td><td class="toc-text"><a href="#Attributes">Attributes       </a></td></tr>
                                                                                                                  <tr class="toc-level-2"><td class="toc-number">1.3</td><td class="toc-text"><a href="#Methods">Methods</a></td></tr>
                                                                                                                                                                                 <tr class="toc-level-2"><td class="toc-number">1.4</td><td class="toc-text"><a href="#Class_and_instance_methods">Class and instance methods</a></td></tr>
                                                                                  <tr class="toc-level-2"><td class="toc-number">1.5</td><td class="toc-text"><a href="#self"><code class="pod-code-inline">self</code></a></td></tr>
                                                                                                             <tr class="toc-level-2"><td class="toc-number">1.6</td><td class="toc-text"><a href="#Private_methods">Private methods</a></td></tr>
                                               <tr class="toc-level-2"><td class="toc-number">1.7</td><td class="toc-text"><a href="#Submethods">Submethods</a></td></tr>
                                                      <tr class="toc-level-2"><td class="toc-number">1.8</td><td class="toc-text"><a href="#Inheritance">Inheritance</a></td></tr>
                                                        <tr class="toc-level-2"><td class="toc-number">1.9</td><td class="toc-text"><a href="#Delegation">Delegation</a></td></tr>
                                                                                                                                                    <tr class="toc-level-2"><td class="toc-number">1.10</td><td class="toc-text"><a href="#Object_construction">Object construction</a></td></tr>
                                                                                                                                                                 <tr class="toc-level-2"><td class="toc-number">1.11</td><td class="toc-text"><a href="#Object_cloning">Object cloning</a></td></tr>
                         
</table>
</nav>

        <div class="pod-body ">
            <p>Documentation for syntax <code>class</code> assembled from the following types:</p>
<h1 id="language_documentation_Object_orientation"><a class="u" href="#___top" title="go to top of document">language documentation Object orientation</a></h1>
<p>From <a href="/Documentable/integration-test/language/objects#Classes">Object orientation</a></p>
<h2 id="(Object_orientation)_declarator_class_class"><a href="/Documentable/integration-test/language/objects#Classes">(Object orientation) declarator class class</a></h2>
<p>Classes are declared using the <code>class</code> keyword, typically followed by a name.</p>
<pre class="pod-block-code">class Journey { }
</pre>
<p>This declaration results in a type object being created and installed in the current package and current lexical scope under the name <code>Journey</code>. You can also declare classes lexically:</p>
<pre class="pod-block-code">my class Journey { }
</pre>
<p>This restricts their visibility to the current lexical scope, which can be useful if the class is an implementation detail nested inside a module or another class.</p>
<h2 id="Attributes"><a class="u" href="#___top" title="go to top of document">Attributes <a name="Documentable/integration-test/index-entry-Attribute"></a> <a name="Documentable/integration-test/index-entry-Property"></a> <a name="Documentable/integration-test/index-entry-Member"></a> <a name="Documentable/integration-test/index-entry-Slot"></a></a></h2>
<p>Attributes are variables that exist per instance of a class; when instantiated to a value, the association between the variable and its value is called a property. They are where the state of an object is stored. In Raku, all attributes are <em>private</em>, which means they can be accessed directly only by the class instance itself. They are typically declared using the <code>has</code> declarator and the <code>!</code> twigil.</p>
<pre class="pod-block-code">class Journey {
    has $!origin;
    has $!destination;
    has @!travelers;
    has $!notes;
}
</pre>
<p>While there is no such thing as a public (or even protected) attribute, there is a way to have accessor methods generated automatically: replace the <code>!</code> twigil with the <code>.</code> twigil (the <code>.</code> should remind you of a method call).</p>
<pre class="pod-block-code">class Journey {
    has $.origin;
    has $.destination;
    has @!travelers;
    has $.notes;
}
</pre>
<p>This defaults to providing a read-only accessor. In order to allow changes to the attribute, add the <a href="/Documentable/integration-test/routine/is%20rw">is rw</a> trait:</p>
<pre class="pod-block-code">class Journey {
    has $.origin;
    has $.destination;
    has @!travelers;
    has $.notes is rw;
}
</pre>
<p>Now, after a <code>Journey</code> object is created, its <code>.origin</code>, <code>.destination</code>, and <code>.notes</code> will all be accessible from outside the class, but only <code>.notes</code> can be modified.</p>
<p>If an object is instantiated without certain attributes, such as origin or destination, we may not get the desired result. To prevent this, provide default values or make sure that an attribute is set on object creation by marking an attribute with an <a href="/Documentable/integration-test/routine/is%20required">is required</a> trait.</p>
<pre class="pod-block-code">class Journey {
    # error if origin is not provided
    has $.origin is required;
    # set the destination to Orlando as default (unless that is the origin!)
    has $.destination = self.origin eq &#39;Orlando&#39; ?? &#39;Kampala&#39; !! &#39;Orlando&#39;;
    has @!travelers;
    has $.notes is rw;
}
</pre>
<p>Since classes inherit a default constructor from <code>Mu</code> and we have requested that some accessor methods are generated for us, our class is already somewhat functional.</p>
<pre class="pod-block-code"># Create a new instance of the class.
my $vacation = Journey.new(
    origin      =&gt; &#39;Sweden&#39;,
    destination =&gt; &#39;Switzerland&#39;,
    notes       =&gt; &#39;Pack hiking gear!&#39;
);

# Use an accessor; this outputs Sweden.
say $vacation.origin;

# Use an rw accessor to change the value.
$vacation.notes = &#39;Pack hiking gear and sunglasses!&#39;;
</pre>
<p>Note that, although the default constructor can initialize read-only attributes, it will only set attributes that have an accessor method. That is, even if you pass <code>travelers =&gt; [&quot;Alex&quot;, &quot;Betty&quot;]</code> to the default constructor, the attribute <code>@!travelers</code> is not initialized.</p>
<h2 id="Methods"><a class="u" href="#___top" title="go to top of document">Methods</a></h2>
<p>Methods are declared with the <code>method</code> keyword inside a class body.</p>
<pre class="pod-block-code">class Journey {
    has $.origin;
    has $.destination;
    has @!travelers;
    has $.notes is rw;

    method add-traveler($name) {
        if $name ne any(@!travelers) {
            push @!travelers, $name;
        }
        else {
            warn &quot;$name is already going on the journey!&quot;;
        }
    }

    method describe() {
        &quot;From $!origin to $!destination&quot;
    }
}
</pre>
<p>A method can have a signature, just like a subroutine. Attributes can be used in methods and can always be used with the <code>!</code> twigil, even if they are declared with the <code>.</code> twigil. This is because the <code>.</code> twigil declares a <code>!</code> twigil and generates an accessor method.</p>
<p>Looking at the code above, there is a subtle but important difference between using <code>$!origin</code> and <code>$.origin</code> in the method <code>describe</code>. <code>$!origin</code> is an inexpensive and obvious lookup of the attribute. <code>$.origin</code> is a method call and thus may be overridden in a subclass. Only use <code>$.origin</code> if you want to allow overriding.</p>
<p>Unlike subroutines, additional named arguments will not produce compile time or runtime errors. That allows chaining of methods via <a href="/Documentable/integration-test/language/functions#Re-dispatching">Re-dispatching</a>.</p>
<p>You may write your own accessors to override any or all of the autogenerated ones.</p>
<pre class="pod-block-code">my $ⲧ = &quot; &quot; xx 4; # A tab-like thing
class Journey {
    has $.origin;
    has $.destination;
    has @.travelers;
    has Str $.notes is rw;

    multi method notes() { &quot;$!notes\n&quot; };
    multi method notes( Str $note ) { $!notes ~= &quot;$note\n$ⲧ&quot; };

    method Str { &quot;⤷ $!origin\n$ⲧ&quot; ~ self.notes() ~ &quot;$!destination ⤶\n&quot; };
}

my $trip = Journey.new( :origin&lt;Here&gt;, :destination&lt;There&gt;,
                        travelers =&gt; &lt;þor Freya&gt; );

$trip.notes(&quot;First steps&quot;);
notes $trip: &quot;Almost there&quot;;
print $trip;

# OUTPUT:
#⤷ Here
#       First steps
#       Almost there
#
#There ⤶
</pre>
<p>The declared multi method <code>notes</code> overrides the auto-generated methods implicit in the declaration of <code>$.notes</code>, using a different signature for reading and writing.</p>
<p>Please note that in <code>notes $trip: &quot;Almost there&quot;</code> we are using <a name="Documentable/integration-test/index-entry-indirect_invocant_syntax"><span class="index-entry">indirect invocant syntax</span></a>, which puts first the method name, then the object, and then, separated by a colon, the arguments: <code>method invocant: arguments</code>. We can use this syntax whenever it feels more natural than the classical period-and-parentheses one. It works exactly in the same way.</p>
<p>Note how the call to the <code>notes</code> method in the <code>Str</code> method is made on <code>self</code>. Writing method calls this way will leave the return value of the method as is with regards to containers. To containerize return values, you can make method calls on a sigil instead of <code>self</code>. This calls various methods on the return value of the method depending on the sigil used to containerize it:</p>
<table class="pod-table">
<thead><tr>
<th>Sigil</th> <th>Method</th>
</tr></thead>
<tbody>
<tr> <td>$</td> <td>item</td> </tr> <tr> <td>@</td> <td>list</td> </tr> <tr> <td>%</td> <td>hash</td> </tr> <tr> <td>&amp;</td> <td>item</td> </tr>
</tbody>
</table><p>For example, the <code>Str</code> method of <code>Journey</code> can be rewritten not to use the <code>~</code> operator by embedding a sigiled method call in the string it returns:</p>
<pre class="pod-block-code">method Str { &quot;⤷ $!origin\n$ⲧ$.notes()$!destination ⤶\n&quot; }
</pre>
<p>Method names can be resolved at runtime with the <code>.&quot;&quot;</code> operator.</p>
<pre class="pod-block-code">class A { has $.b };
my $name = &#39;b&#39;;
A.new.&quot;$name&quot;().say;
# OUTPUT: «(Any)␤»
</pre>
<p>The syntax used to update <code>$.notes</code> changed in this section with respect to the previous <a href="#Attributes">Attributes</a> section. Instead of an assignment:</p>
<pre class="pod-block-code">$vacation.notes = &#39;Pack hiking gear and sunglasses!&#39;;
</pre>
<p>we now do a method call:</p>
<pre class="pod-block-code">$trip.notes(&quot;First steps&quot;);
</pre>
<p>Overriding the default auto-generated accessor means it is no longer available to provide a mutable container on return for an assignment. A method call is the preferred approach to adding computation and logic to the update of an attribute. Many modern languages can update an attribute by overloading assignment with a “setter” method. While Raku can overload the assignment operator for this purpose with a <a href="https://github.com/Raku/roast/blob/master/S12-attributes/mutators.t"><code>Proxy</code></a> object, overloading assignment to set attributes with complex logic is currently discouraged as <a href="https://6guts.wordpress.com/2016/11/25/perl-6-is-biased-towards-mutators-being-really-simple-thats-a-good-thing/">weaker object oriented design</a>.</p>
<h2 id="Class_and_instance_methods"><a class="u" href="#___top" title="go to top of document">Class and instance methods</a></h2>
<p>A method&#39;s signature can have an <em>explicit invocant</em> as its first parameter followed by a colon, which allows for the method to refer to the object it was called on.</p>
<pre class="pod-block-code">class Foo {
    method greet($me: $person) {
        say &quot;Hi, I am $me.^name(), nice to meet you, $person&quot;;
    }
}
Foo.new.greet(&quot;Bob&quot;);    # OUTPUT: «Hi, I am Foo, nice to meet you, Bob␤»
</pre>
<p>Providing an invocant in the method signature also allows for defining the method as either as a class method, or as an object method, through the use of <a href="/Documentable/integration-test/type/Signature#Type_constraints">type constraints</a>. The <code>::?CLASS</code> variable can be used to provide the class name at compile time, combined with either <code>:U</code> (for class methods) or <code>:D</code> (for instance methods).</p>
<pre class="pod-block-code">class Pizza {
    has $!radius = 42;
    has @.ingredients;

    # class method: construct from a list of ingredients
    method from-ingredients(::?CLASS:U $pizza: @ingredients) {
        $pizza.new( ingredients =&gt; @ingredients );
    }

    # instance method
    method get-radius(::?CLASS:D:) { $!radius }
}
my $p = Pizza.from-ingredients: &lt;cheese pepperoni vegetables&gt;;
say $p.ingredients;     # OUTPUT: «[cheese pepperoni vegetables]␤»
say $p.get-radius;      # OUTPUT: «42␤»
say Pizza.get-radius;   # This will fail.
CATCH { default { put .^name ~ &quot;:\n&quot; ~ .Str } };
# OUTPUT: «X::Parameter::InvalidConcreteness:␤
#          Invocant of method &#39;get-radius&#39; must be
#          an object instance of type &#39;Pizza&#39;,
#          not a type object of type &#39;Pizza&#39;.
#          Did you forget a &#39;.new&#39;?»
</pre>
<p>A method can be both a class and object method by using the <a href="/Documentable/integration-test/syntax/multi">multi</a> declarator:</p>
<pre class="pod-block-code">class C {
    multi method f(::?CLASS:U:) { say &quot;class method&quot;  }
    multi method f(::?CLASS:D:) { say &quot;object method&quot; }
}
C.f;       # OUTPUT: «class method␤»
C.new.f;   # OUTPUT: «object method␤»
</pre>
<h2 id="self"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-self"><span class="index-entry"><code>self</code></span></a></a></h2>
<p>Inside a method, the term <code>self</code> is available and bound to the invocant object. <code>self</code> can be used to call further methods on the invocant, including constructors:</p>
<pre class="pod-block-code">class Box {
  has $.data;

  method make-new-box-from() {
      self.new: data =&gt; $!data;
  }
}
</pre>
<p><code>self</code> can be used in class or instance methods as well, though beware of trying to invoke one type of method from the other:</p>
<pre class="pod-block-code">class C {
    method g()            { 42     }
    method f(::?CLASS:U:) { self.g }
    method d(::?CLASS:D:) { self.f }
}
C.f;        # OUTPUT: «42␤»
C.new.d;    # This will fail.
CATCH { default { put .^name ~ &quot;:\n&quot; ~ .Str } };
# OUTPUT: «X::Parameter::InvalidConcreteness:␤
#          Invocant of method &#39;f&#39; must be a type object of type &#39;C&#39;,
#          not an object instance of type &#39;C&#39;.  Did you forget a &#39;multi&#39;?»
</pre>
<p><code>self</code> can also be used with attributes, as long as they have an accessor. <code>self.a</code> will call the accessor for an attribute declared as <code>has $.a</code>. However, there is a difference between <code>self.a</code> and <code>$.a</code>, since the latter will itemize; <code>$.a</code> will be equivalent to <code>self.a.item</code> or <code>$(self.a)</code>.</p>
<pre class="pod-block-code">class A {
    has Int @.numbers;
    has $.x = (1, 2, 3);

    method show-diff() { .say for self.x; .say for $.x }

    method twice  { self.times: 2 }
    method thrice { $.times: 3    }

    method times($val = 1) { @!numbers.map(* * $val).list }
};

my $obj = A.new(numbers =&gt; [1, 2, 3]);
$obj.show-diff;   # OUTPUT: «1␤2␤3␤(1 2 3)␤»
say $obj.twice;   # OUTPUT: «(2 4 6)␤»
say $obj.thrice;  # OUTPUT: «(3 6 9)␤»
</pre>
<p>The colon-syntax for method arguments is supported for method calls using either <code>self</code> or the shortcut, as illustrated with the methods <code>twice</code> and <code>thrice</code> in the example above.</p>
<p>Note that if the relevant methods <code>bless</code>, <code>CREATE</code> of <a href="/Documentable/integration-test/type/Mu">Mu</a> are not overloaded, <code>self</code> will point to the type object in those methods.</p>
<p>On the other hand, the submethods <code>BUILD</code> and <code>TWEAK</code> are called on instances, in different stages of initialization. Submethods of the same name from subclasses have not yet run, so you should not rely on potentially virtual method calls inside these methods.</p>
<p><a name="Documentable/integration-test/index-entry-Private_methods"></a></p>
<h2 id="Private_methods"><a class="u" href="#___top" title="go to top of document">Private methods</a></h2>
<p>Methods with an exclamation mark <code>!</code> before the method name are not callable from anywhere outside the defining class; such methods are private in the sense that they are not visible from outside the class that declares them. Private methods are invoked with an exclamation mark instead of a dot:</p>
<pre class="pod-block-code">class FunMath {
    has $.value is required;
    method !do-subtraction( $num ) {
        if $num ~~ Str {
            return $!value + (-1 * $num.chars);
        }
        return $!value + (-1 * $num);
    }
    method minus( $minuend: $subtrahend ) {
        # invoking the private method on the explicit invocant
        $minuend!do-subtraction($subtrahend);
    }
}
my $five = FunMath.new(value =&gt; 5);
say $five.minus(6);         # OUTPUT: «-1␤»

say $five.do-subtraction(6);
CATCH { default { put .^name ~ &quot;:\n&quot; ~ .Str } }
# OUTPUT: «X::Method::NotFound:
# No such method &#39;do-subtraction&#39; for invocant of type
# &#39;FunMath&#39;. Did you mean &#39;!do-subtraction&#39;?␤»
</pre>
<p>Private methods are not inherited by subclasses.</p>
<p><a name="Documentable/integration-test/index-entry-Submethods"></a></p>
<h2 id="Submethods"><a class="u" href="#___top" title="go to top of document">Submethods</a></h2>
<p>Submethods are public methods that will not be inherited by subclasses. The name stems from the fact that they are semantically similar to subroutines.</p>
<p>Submethods are useful for object construction and destruction tasks, as well as for tasks that are so specific to a certain type that subtypes would certainly have to override them.</p>
<p>For example, the <a href="/Documentable/integration-test/type/Mu#method_new">default method new</a> calls submethod <code>BUILD</code> on each class in an <a href="#Inheritance">inheritance</a> chain:</p>
<pre class="pod-block-code">class Point2D {
    has $.x;
    has $.y;

    submethod BUILD(:$!x, :$!y) {
        say &quot;Initializing Point2D&quot;;
    }
}

class InvertiblePoint2D is Point2D {
    submethod BUILD() {
        say &quot;Initializing InvertiblePoint2D&quot;;
    }
    method invert {
        self.new(x =&gt; - $.x, y =&gt; - $.y);
    }
}

say InvertiblePoint2D.new(x =&gt; 1, y =&gt; 2);
# OUTPUT: «Initializing Point2D␤»
# OUTPUT: «Initializing InvertiblePoint2D␤»
# OUTPUT: «InvertiblePoint2D.new(x =&gt; 1, y =&gt; 2)␤»
</pre>
<p>See also: <a href="#Object_construction">Object construction</a>.</p>
<h2 id="Inheritance"><a class="u" href="#___top" title="go to top of document">Inheritance</a></h2>
<p>Classes can have <em>parent classes</em>.</p>
<pre class="pod-block-code">class Child is Parent1 is Parent2 { }
</pre>
<p><a name="Documentable/integration-test/index-entry-MRO"></a> If a method is called on the child class, and the child class does not provide that method, the method of that name in one of the parent classes is invoked instead, if it exists. The order in which parent classes are consulted is called the <em>method resolution order</em> (MRO). Raku uses the <a href="https://en.wikipedia.org/wiki/C3_linearization">C3 method resolution order</a>. You can ask a type for its MRO through a call to its metaclass:</p>
<pre class="pod-block-code">say List.^mro;      # ((List) (Cool) (Any) (Mu))
</pre>
<p>If a class does not specify a parent class, <a href="/Documentable/integration-test/type/Any">Any</a> is assumed by default. All classes directly or indirectly derive from <a href="/Documentable/integration-test/type/Mu">Mu</a>, the root of the type hierarchy.</p>
<p>All calls to public methods are &quot;virtual&quot; in the C++ sense, which means that the actual type of an object determines which method to call, not the declared type:</p>
<pre class="pod-block-code">class Parent {
    method frob {
        say &quot;the parent class frobs&quot;
    }
}

class Child is Parent {
    method frob {
        say &quot;the child&#39;s somewhat more fancy frob is called&quot;
    }
}

my Parent $test;
$test = Child.new;
$test.frob;          # calls the frob method of Child rather than Parent
# OUTPUT: «the child&#39;s somewhat more fancy frob is called␤»
</pre>
<p>If you want to explicitly call the parent method on a child object, refer to its full name in the parent namespace:</p>
<pre class="pod-block-code">$test.Parent::frob;  # calls the frob method of Parent
# OUTPUT: «the parent class frobs␤»
</pre>
<p><a name="Documentable/integration-test/index-entry-delegation_(trait_handles)"></a></p>
<h2 id="Delegation"><a class="u" href="#___top" title="go to top of document">Delegation</a></h2>
<p>Delegation is a technique whereby a member of an object (the <em>delegatee</em>) is evaluated in the context of another original object (the <em>delegator</em>). In other words, all method calls on the delegator are <em>delegated</em> to the delegatee.</p>
<p>In Raku, delegation is specified by applying the <a href="/Documentable/integration-test/language/typesystem#trait_handles">handles</a> trait to an attribute. The arguments provided to the trait specify the methods the current object and the delegatee object will have in common. Instead of a list of method names, a <code>Pair</code> (for renaming), a list of <code>Pairs</code>, a <code>Regex</code> or a <code>Whatever</code> can be provided.</p>
<pre class="pod-block-code">class Book {
    has Str  $.title;
    has Str  $.author;
    has Str  $.language;
    has Cool $.publication;
}

class Product {
    has Book $.book handles(&#39;title&#39;, &#39;author&#39;, &#39;language&#39;, year =&gt; &#39;publication&#39;);
}

my $book = Book.new:
    :title&lt;Dune&gt;,
    :author(&#39;Frank Herbert&#39;),
    :language&lt;English&gt;,
    :publication&lt;1965&gt;
;

given Product.new(:$book) {
    say .title;    # OUTPUT: «Dune␤»
    say .author;   # OUTPUT: «Frank Herbert␤»
    say .language; # OUTPUT: «English␤»
    say .year;     # OUTPUT: «1965␤»
}
</pre>
<p>In the example above, the class <code>Product</code> defines the attribute <code>$.book</code> and mark it with the <code>handles</code> trait to specify the methods that will be forwarded to the class <code>Book</code> whenever they&#39;re invoked on an instance object of the <code>Product</code> class. There are a few things to notice here:</p>
<ul><li><p>We didn&#39;t write any methods inside the <code>Product</code> class that we invoked in its instance object. Instead, we instructed the class to delegate a call to any those methods to the <code>Book</code> class.</p>
</li>
<li><p>We&#39;ve specified the method names <code>title</code>, <code>author</code>, and <code>language</code> as they appear in the <code>Book</code> class. On the other hand, we&#39;ve renamed the <code>publication</code> method to <code>year</code> by providing the appropriate <code>Pair</code>.</p>
</li>
</ul>
<p>Delegation can be used as an alternative to inheritance by delegating to the parent class and not inheriting all of its methods. For example, the following <code>Queue</code> class delegates several methods proper of queues to the <a href="/Documentable/integration-test/type/Array">Array</a> class while also providing a preferred interface for a few of those methods (e.g., <code>enqueue</code> for <code>push</code>):</p>
<pre class="pod-block-code">class Queue {
    has @!q handles(
        enqueue =&gt; &#39;push&#39;, dequeue =&gt; &#39;shift&#39;,
        &#39;push&#39;, &#39;shift&#39;, &#39;head&#39;, &#39;tail&#39;, &#39;elems&#39;, &#39;splice&#39;
    );

    method gist {
        &#39;[&#39; ~ @!q.join(&#39;, &#39;) ~ &#39;]&#39;
    }
}

my Queue $q .= new;
$q.enqueue($_) for 1..5;
$q.push(6);
say $q.shift;                  # OUTPUT: «1␤»
say $q.dequeue while $q.elems; # OUTPUT: «2␤3␤4␤5␤6␤»

$q.enqueue($_) for &lt;Perl Python Raku Ruby&gt;;
say $q.head;                   # OUTPUT: «Perl␤»
say $q.tail;                   # OUTPUT: «Ruby␤»
say $q;                        # OUTPUT: «[Perl, Python, Raku, Ruby]␤»
$q.dequeue while $q.elems;
say $q;                        # OUTPUT: «[]␤»
</pre>
<p><a name="Documentable/integration-test/index-entry-new_(method)"></a></p>
<h2 id="Object_construction"><a class="u" href="#___top" title="go to top of document">Object construction</a></h2>
<p>Objects are generally created through method calls, either on the type object or on another object of the same type.</p>
<p>Class <a href="/Documentable/integration-test/type/Mu">Mu</a> provides a constructor method called <a href="/Documentable/integration-test/routine/new">new</a>, which takes named <a href="/Documentable/integration-test/language/functions#Arguments">arguments</a> and uses them to initialize public attributes.</p>
<pre class="pod-block-code">class Point {
    has $.x;
    has $.y;
}
my $p = Point.new( x =&gt; 5, y =&gt; 2);
#             ^^^ inherited from class Mu
say &quot;x: &quot;, $p.x;
say &quot;y: &quot;, $p.y;
# OUTPUT: «x: 5␤»
# OUTPUT: «y: 2␤»
</pre>
<p><code>Mu.new</code> calls method <a href="/Documentable/integration-test/routine/bless">bless</a> on its invocant, passing all the named <a href="/Documentable/integration-test/language/functions#Arguments">arguments</a>. <code>bless</code> creates the new object, and then walks all subclasses in reverse method resolution order (i.e. from <a href="/Documentable/integration-test/type/Mu">Mu</a> to most derived classes) and in each class checks for the existence of a method named <code>BUILD</code>. If the method exists, the method is called with all the named arguments from the <code>new</code> method. If not, the public attributes from this class are initialized from named arguments of the same name. In either case, if neither <code>BUILD</code> nor the default mechanism has initialized the attribute, default values are applied. This means that <code>BUILD</code> may change an attribute, but it does not have access to the contents of the attribute declared as its default; these are available only during <code>TWEAK</code> (see below), which can &#39;see&#39; the contents of an attribute initialized in the declaration of the class.</p>
<p><a name="Documentable/integration-test/index-entry-TWEAK"></a> After the <code>BUILD</code> methods have been called, methods named <code>TWEAK</code> are called, if they exist, again with all the named arguments that were passed to <code>new</code>. See an example of its use below.</p>
<p>Due to the default behavior of <code>BUILD</code> and <code>TWEAK</code> submethods, named arguments to the constructor <code>new</code> derived from <code>Mu</code> can correspond directly to public attributes of any of the classes in the method resolution order, or to any named parameter of any <code>BUILD</code> or <code>TWEAK</code> submethod.</p>
<p>This object construction scheme has several implications for customized constructors. First, custom <code>BUILD</code> methods should always be submethods, otherwise they break attribute initialization in subclasses. Second, <code>BUILD</code> submethods can be used to run custom code at object construction time. They can also be used for creating aliases for attribute initialization:</p>
<pre class="pod-block-code">class EncodedBuffer {
    has $.enc;
    has $.data;

    submethod BUILD(:encoding(:$enc), :$data) {
        $!enc  :=  $enc;
        $!data := $data;
    }
}
my $b1 = EncodedBuffer.new( encoding =&gt; &#39;UTF-8&#39;, data =&gt; [64, 65] );
my $b2 = EncodedBuffer.new( enc      =&gt; &#39;UTF-8&#39;, data =&gt; [64, 65] );
#  both enc and encoding are allowed now
</pre>
<p>Since passing arguments to a routine binds the arguments to the parameters, a separate binding step is unnecessary if the attribute is used as a parameter. Hence the example above could also have been written as:</p>
<pre class="pod-block-code">submethod BUILD(:encoding(:$!enc), :$!data) {
    # nothing to do here anymore, the signature binding
    # does all the work for us.
}
</pre>
<p>However, be careful when using this auto-binding of attributes when the attribute may have special type requirements, such as an <code>:$!id</code> that must be a positive integer. Remember, default values will be assigned unless you specifically take care of this attribute, and that default value will be <code>Any</code>, which would cause a type error.</p>
<p>The third implication is that if you want a constructor that accepts positional arguments, you must write your own <code>new</code> method:</p>
<pre class="pod-block-code">class Point {
    has $.x;
    has $.y;
    method new($x, $y) {
        self.bless(:$x, :$y);
    }
}
</pre>
<p>However this is considered poor practice, because it makes correct initialization of objects from subclasses harder.</p>
<p>Another thing to note is that the name <code>new</code> is not special in Raku. It is merely a common convention, one that is followed quite thoroughly in <a href="/Documentable/integration-test/routine/new">most Raku classes</a>. You can call <code>bless</code> from any method at all, or use <code>CREATE</code> to fiddle around with low-level workings.</p>
<p>The <code>TWEAK</code> submethod allows you to check things or modify attributes after object construction:</p>
<pre class="pod-block-code">class RectangleWithCachedArea {
    has ($.x1, $.x2, $.y1, $.y2);
    has $.area;
    submethod TWEAK() {
        $!area = abs( ($!x2 - $!x1) * ( $!y2 - $!y1) );
    }
}

say RectangleWithCachedArea.new( x2 =&gt; 5, x1 =&gt; 1, y2 =&gt; 1, y1 =&gt; 0).area;
# OUTPUT: «4␤»
</pre>
<h2 id="Object_cloning"><a class="u" href="#___top" title="go to top of document">Object cloning</a></h2>
<p>The cloning is done using the <a href="/Documentable/integration-test/routine/clone">clone</a> method available on all objects, which shallow-clones both public and private attributes. New values for <em>public</em> attributes can be supplied as named arguments.</p>
<pre class="pod-block-code">class Foo {
    has $.foo = 42;
    has $.bar = 100;
}

my $o1 = Foo.new;
my $o2 = $o1.clone: :bar(5000);
say $o1; # Foo.new(foo =&gt; 42, bar =&gt; 100)
say $o2; # Foo.new(foo =&gt; 42, bar =&gt; 5000)
</pre>
<p>See document for <a href="/Documentable/integration-test/routine/clone">clone</a> for details on how non-scalar attributes get cloned, as well as examples of implementing your own custom clone methods.</p>

        </div>
    </div>

    

    <footer class="pretty-box yellow">
        <p>
            Generated from <a href="https://github.com/Raku/doc/tree/master/docs/">https://github.com/Raku/doc/tree/master/docs/</a>.
        </p>
        <p>
            This is a work in progress to document Raku (formerly known as Perl 6), and
            known to be incomplete.
        </p>
        <p>
            <a href="https://github.com/raku/doc/blob/master/CONTRIBUTING.md#reporting-bugs">
                Please report any issues
            </a>
            Your contribution is appreciated.
        </p>
        <p>
            This documentation is provided under the terms of the
            <a href="https://raw.githubusercontent.com/raku/doc/master/LICENSE">
                Artistic License 2.0
            </a>. The Camelia image is
            <a href="https://raw.githubusercontent.com/raku/mu/master/misc/camelia.txt">
                copyright © 2009 by Larry Wall.
            </a>
            <!-- CREDITS -->
            <!--External Link Image by Zapyon, CCA-SA 4.0. Derived from Wikimedia Foundation https://commons.wikimedia.org/wiki/File:External-link-04-bold-12x12.svg -->
        </p>
    </footer>

    <script type="text/javascript" src="/Documentable/integration-test/js/app.js?v=1"></script>
    <script type="text/javascript" src="/Documentable/integration-test/js/search.js?v=3"></script>
</body>
</html>


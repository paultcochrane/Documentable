<!doctype html>
<html lang="en">
<head>
    <title>Operators</title>
    <meta charset="UTF-8"/>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <link rel="icon" href="/Documentable/integration-test/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" type="text/css" href="/Documentable/integration-test/css/app.css" media="screen" title="default" />
    <noscript> <style> #search { visibility: hidden; } </style> </noscript>
</head>

<body class="pod">

    <div id="___top"></div>

    <div id="header" class="pretty-box green">

        <a href="/Documentable/integration-test/">
            <img src="/Documentable/integration-test/images/Camelia.svg"alt="»ö«"id="logo"width="62"height="48"/> &nbsp;Raku Documentation
        </a>

        <div id="search" class="ui-widget">
            <div class="green">
                <input placeholder="Loading..." id="query" accesskey="f" title="Enter term to search for (hit Esc to focus)"/>
            </div>
            <p id="not-found-message">
                Not in Index (<a href="" id="try-web-search">try site search</a>)
            </p>
        </div>
        
        <div class="menu">
            
            <div class="menu-items dark-green">
                <a class='menu-item darker-green' href='https://raku.org'><strong>Raku homepage</strong></a>
                    <a class="menu-item selected darker-green" href="/Documentable/integration-test/language.html"> Language </a>
                    <a class="menu-item " href="/Documentable/integration-test/type.html"> Types </a>
                    <a class="menu-item " href="/Documentable/integration-test/routine.html"> Routines </a>
                    <a class="menu-item " href="https://webchat.freenode.net/?channels=#raku"> Chat with us </a>
            </div>
            
            
            
        
        </div>
    </div>

    <div id="content" class="pretty-box yellow content_fragment">

        <div align="right" style="display:;">
            <button title="Edit this page"  class="pencil" onclick="location='https://github.com/Raku/doc/tree/master/docs/Language/operators.pod6'">
                <svg width="14px" height="16px" viewBox="0 0 14 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                    <defs></defs>
                    <g id="Octicons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g id="pencil" fill="#000000">
                            <path d="M0,12 L0,15 L3,15 L11,7 L8,4 L0,12 L0,12 Z M3,14 L1,14 L1,12 L2,12 L2,13 L3,13 L3,14 L3,14 Z M13.3,4.7 L12,6 L9,3 L10.3,1.7 C10.69,1.31 11.32,1.31 11.71,1.7 L13.3,3.29 C13.69,3.68 13.69,4.31 13.3,4.7 L13.3,4.7 Z" id="Shape"></path>
                        </g>
                    </g>
                </svg>
            </button>
        </div>

        <h1 class="title">Operators</h1>
        <p class="subtitle">Common Raku infixes, prefixes, postfixes, and more!</p>

        <nav class="indexgroup">
<table id="TOC">
<caption><h2 id="TOC_Title">Table of Contents</h2></caption>
     <tr class="toc-level-1"><td class="toc-number">1</td><td class="toc-text"><a href="#Operator_precedence">Operator precedence</a></td></tr>
                                                                                                                                                                    <tr class="toc-level-1"><td class="toc-number">2</td><td class="toc-text"><a href="#Operator_classification">Operator classification</a></td></tr>
                                     <tr class="toc-level-1"><td class="toc-number">3</td><td class="toc-text"><a href="#Metaoperators">Metaoperators</a></td></tr>
    <tr class="toc-level-1"><td class="toc-number">4</td><td class="toc-text"><a href="#Substitution_operators">Substitution operators</a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">4.1</td><td class="toc-text"><a href="#s///_in-place_substitution"><code class="pod-code-inline">s///</code> in-place substitution</a></td></tr>
                                     <tr class="toc-level-2"><td class="toc-number">4.2</td><td class="toc-text"><a href="#S///_non-destructive_substitution"><code class="pod-code-inline">S///</code> non-destructive substitution</a></td></tr>
                             <tr class="toc-level-2"><td class="toc-number">4.3</td><td class="toc-text"><a href="#tr///_in-place_transliteration"><code class="pod-code-inline">tr///</code> in-place transliteration</a></td></tr>
                   <tr class="toc-level-2"><td class="toc-number">4.4</td><td class="toc-text"><a href="#TR///_non-destructive_transliteration"><code class="pod-code-inline">TR///</code> non-destructive transliteration</a></td></tr>
         <tr class="toc-level-1"><td class="toc-number">5</td><td class="toc-text"><a href="#Assignment_operators">Assignment operators</a></td></tr>
                                                                                                <tr class="toc-level-1"><td class="toc-number">6</td><td class="toc-text"><a href="#Negated_relational_operators">Negated relational operators   </a></td></tr>
                    <tr class="toc-level-1"><td class="toc-number">7</td><td class="toc-text"><a href="#Reversed_operators">Reversed operators </a></td></tr>
        <tr class="toc-level-1"><td class="toc-number">8</td><td class="toc-text"><a href="#Hyper_operators">Hyper operators</a></td></tr>
                                                    <tr class="toc-level-1"><td class="toc-number">9</td><td class="toc-text"><a href="#Reduction_metaoperators">Reduction metaoperators</a></td></tr>
                           <tr class="toc-level-1"><td class="toc-number">10</td><td class="toc-text"><a href="#Cross_operators">Cross operators </a></td></tr>
     <tr class="toc-level-1"><td class="toc-number">11</td><td class="toc-text"><a href="#Zip_metaoperator">Zip metaoperator </a></td></tr>
             <tr class="toc-level-1"><td class="toc-number">12</td><td class="toc-text"><a href="#Sequential_operators">Sequential operators </a></td></tr>
     <tr class="toc-level-1"><td class="toc-number">13</td><td class="toc-text"><a href="#Nesting_of_metaoperators">Nesting of metaoperators</a></td></tr>
   <tr class="toc-level-1"><td class="toc-number">14</td><td class="toc-text"><a href="#Term_precedence"> Term precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">14.1</td><td class="toc-text"><a href="#term_&lt;_&gt;">term <code class="pod-code-inline">&lt; &gt;</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">14.2</td><td class="toc-text"><a href="#term_(_)">term <code class="pod-code-inline">( )</code></a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">14.3</td><td class="toc-text"><a href="#term_{_}">term <code class="pod-code-inline">{ }</code></a></td></tr>
                            <tr class="toc-level-2"><td class="toc-number">14.4</td><td class="toc-text"><a href="#circumfix_[_]">circumfix <code class="pod-code-inline">[ ]</code></a></td></tr>
             <tr class="toc-level-1"><td class="toc-number">15</td><td class="toc-text"><a href="#Terms">Terms</a></td></tr>
    <tr class="toc-level-1"><td class="toc-number">16</td><td class="toc-text"><a href="#Method_postfix_precedence">Method postfix precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">16.1</td><td class="toc-text"><a href="#postcircumfix_[_]">postcircumfix <code class="pod-code-inline">[ ]</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">16.2</td><td class="toc-text"><a href="#postcircumfix_{_}">postcircumfix <code class="pod-code-inline">{ }</code></a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">16.3</td><td class="toc-text"><a href="#postcircumfix_&lt;&gt;">postcircumfix <code class="pod-code-inline">&lt;&gt;</code></a></td></tr>
                <tr class="toc-level-2"><td class="toc-number">16.4</td><td class="toc-text"><a href="#postcircumfix_&lt;_&gt;">postcircumfix <code class="pod-code-inline">&lt; &gt;</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">16.5</td><td class="toc-text"><a href="#postcircumfix_«_»">postcircumfix <code class="pod-code-inline">« »</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">16.6</td><td class="toc-text"><a href="#postcircumfix_(_)">postcircumfix <code class="pod-code-inline">( )</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">16.7</td><td class="toc-text"><a href="#methodop_.">methodop <code class="pod-code-inline">.</code></a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">16.8</td><td class="toc-text"><a href="#methodop_.&amp;">methodop <code class="pod-code-inline">.&amp;</code></a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">16.9</td><td class="toc-text"><a href="#methodop_.=">methodop <code class="pod-code-inline">.=</code></a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">16.10</td><td class="toc-text"><a href="#methodop_.^">methodop <code class="pod-code-inline">.^</code></a></td></tr>
                              <tr class="toc-level-2"><td class="toc-number">16.11</td><td class="toc-text"><a href="#methodop_.?">methodop <code class="pod-code-inline">.?</code></a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">16.12</td><td class="toc-text"><a href="#methodop_.+">methodop <code class="pod-code-inline">.+</code></a></td></tr>
                  <tr class="toc-level-2"><td class="toc-number">16.13</td><td class="toc-text"><a href="#methodop_.*">methodop <code class="pod-code-inline">.*</code></a></td></tr>
                         <tr class="toc-level-2"><td class="toc-number">16.14</td><td class="toc-text"><a href="#methodop_»._/_methodop_&gt;&gt;.">methodop <code class="pod-code-inline">».</code> / methodop <code class="pod-code-inline">&gt;&gt;.</code></a></td></tr>
                                                                    <tr class="toc-level-2"><td class="toc-number">16.15</td><td class="toc-text"><a href="#methodop_.postfix_/_.postcircumfix">methodop <code class="pod-code-inline">.postfix</code> / <code class="pod-code-inline">.postcircumfix</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">16.16</td><td class="toc-text"><a href="#methodop_.:&lt;prefix_operator&gt;">methodop <code class="pod-code-inline">.:&lt;prefix operator&gt;</code></a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">16.17</td><td class="toc-text"><a href="#methodop_.::">methodop <code class="pod-code-inline">.::</code></a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">16.18</td><td class="toc-text"><a href="#postfix_,=">postfix <code class="pod-code-inline">,=</code></a></td></tr>
   <tr class="toc-level-1"><td class="toc-number">17</td><td class="toc-text"><a href="#Autoincrement_precedence">Autoincrement precedence</a></td></tr>
  <tr class="toc-level-2"><td class="toc-number">17.1</td><td class="toc-text"><a href="#prefix_++">prefix <code class="pod-code-inline">++</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">17.2</td><td class="toc-text"><a href="#prefix_--">prefix <code class="pod-code-inline">--</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">17.3</td><td class="toc-text"><a href="#postfix_++">postfix <code class="pod-code-inline">++</code></a></td></tr>
                                 <tr class="toc-level-2"><td class="toc-number">17.4</td><td class="toc-text"><a href="#postfix_--">postfix <code class="pod-code-inline">--</code></a></td></tr>
                   <tr class="toc-level-1"><td class="toc-number">18</td><td class="toc-text"><a href="#Exponentiation_precedence">Exponentiation precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">18.1</td><td class="toc-text"><a href="#infix_**">infix <code class="pod-code-inline">**</code></a></td></tr>
                <tr class="toc-level-1"><td class="toc-number">19</td><td class="toc-text"><a href="#Symbolic_unary_precedence">Symbolic unary precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">19.1</td><td class="toc-text"><a href="#prefix_?">prefix <code class="pod-code-inline">?</code></a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">19.2</td><td class="toc-text"><a href="#prefix_!">prefix <code class="pod-code-inline">!</code></a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">19.3</td><td class="toc-text"><a href="#prefix_+">prefix <code class="pod-code-inline">+</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">19.4</td><td class="toc-text"><a href="#prefix_-">prefix <code class="pod-code-inline">-</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">19.5</td><td class="toc-text"><a href="#prefix_~">prefix <code class="pod-code-inline">~</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">19.6</td><td class="toc-text"><a href="#prefix_|">prefix <code class="pod-code-inline">|</code></a></td></tr>
                            <tr class="toc-level-2"><td class="toc-number">19.7</td><td class="toc-text"><a href="#prefix_+^">prefix <code class="pod-code-inline">+^</code></a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">19.8</td><td class="toc-text"><a href="#prefix_~^">prefix <code class="pod-code-inline">~^</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">19.9</td><td class="toc-text"><a href="#prefix_?^">prefix <code class="pod-code-inline">?^</code></a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">19.10</td><td class="toc-text"><a href="#prefix_^">prefix <code class="pod-code-inline">^</code></a></td></tr>
         <tr class="toc-level-1"><td class="toc-number">20</td><td class="toc-text"><a href="#Dotty_infix_precedence">Dotty infix precedence</a></td></tr>
  <tr class="toc-level-2"><td class="toc-number">20.1</td><td class="toc-text"><a href="#infix_.=">infix <code class="pod-code-inline">.=</code></a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">20.2</td><td class="toc-text"><a href="#infix_.">infix <code class="pod-code-inline">.</code></a></td></tr>
      <tr class="toc-level-1"><td class="toc-number">21</td><td class="toc-text"><a href="#Multiplicative_precedence">Multiplicative precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">21.1</td><td class="toc-text"><a href="#infix_*">infix <code class="pod-code-inline">*</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">21.2</td><td class="toc-text"><a href="#infix_/">infix <code class="pod-code-inline">/</code></a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">21.3</td><td class="toc-text"><a href="#infix_div">infix <code class="pod-code-inline">div</code></a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">21.4</td><td class="toc-text"><a href="#infix_%">infix <code class="pod-code-inline">%</code></a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">21.5</td><td class="toc-text"><a href="#infix_%%">infix <code class="pod-code-inline">%%</code></a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">21.6</td><td class="toc-text"><a href="#infix_mod">infix <code class="pod-code-inline">mod</code></a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">21.7</td><td class="toc-text"><a href="#infix_+&amp;">infix <code class="pod-code-inline">+&amp;</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">21.8</td><td class="toc-text"><a href="#infix_+&lt;">infix <code class="pod-code-inline">+&lt;</code></a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">21.9</td><td class="toc-text"><a href="#infix_+&gt;">infix <code class="pod-code-inline">+&gt;</code></a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">21.10</td><td class="toc-text"><a href="#infix_~&amp;">infix <code class="pod-code-inline">~&amp;</code></a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">21.11</td><td class="toc-text"><a href="#infix_~&lt;">infix <code class="pod-code-inline">~&lt;</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">21.12</td><td class="toc-text"><a href="#infix_~&gt;">infix <code class="pod-code-inline">~&gt;</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">21.13</td><td class="toc-text"><a href="#infix_?&amp;">infix <code class="pod-code-inline">?&amp;</code></a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">21.14</td><td class="toc-text"><a href="#infix_gcd">infix <code class="pod-code-inline">gcd</code></a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">21.15</td><td class="toc-text"><a href="#infix_lcm">infix <code class="pod-code-inline">lcm</code></a></td></tr>
      <tr class="toc-level-1"><td class="toc-number">22</td><td class="toc-text"><a href="#Additive_precedence">Additive precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">22.1</td><td class="toc-text"><a href="#infix_+">infix <code class="pod-code-inline">+</code></a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">22.2</td><td class="toc-text"><a href="#infix_-">infix <code class="pod-code-inline">-</code></a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">22.3</td><td class="toc-text"><a href="#infix_+|">infix <code class="pod-code-inline">+|</code></a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">22.4</td><td class="toc-text"><a href="#infix_+^">infix <code class="pod-code-inline">+^</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">22.5</td><td class="toc-text"><a href="#infix_~|">infix <code class="pod-code-inline">~|</code></a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">22.6</td><td class="toc-text"><a href="#infix_~^">infix <code class="pod-code-inline">~^</code></a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">22.7</td><td class="toc-text"><a href="#infix_?^">infix <code class="pod-code-inline">?^</code></a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">22.8</td><td class="toc-text"><a href="#infix_?|">infix <code class="pod-code-inline">?|</code></a></td></tr>
      <tr class="toc-level-1"><td class="toc-number">23</td><td class="toc-text"><a href="#Replication_precedence">Replication precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">23.1</td><td class="toc-text"><a href="#infix_x">infix <code class="pod-code-inline">x</code></a></td></tr>
                            <tr class="toc-level-2"><td class="toc-number">23.2</td><td class="toc-text"><a href="#infix_xx">infix <code class="pod-code-inline">xx</code></a></td></tr>
                                     <tr class="toc-level-1"><td class="toc-number">24</td><td class="toc-text"><a href="#Concatenation">Concatenation</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">24.1</td><td class="toc-text"><a href="#infix_~">infix <code class="pod-code-inline">~</code></a></td></tr>
                      <tr class="toc-level-2"><td class="toc-number">24.2</td><td class="toc-text"><a href="#infix_∘">infix <code class="pod-code-inline">∘</code></a></td></tr>
                                                          <tr class="toc-level-1"><td class="toc-number">25</td><td class="toc-text"><a href="#Junctive_AND_(all)_precedence">Junctive AND (all) precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">25.1</td><td class="toc-text"><a href="#infix_&amp;">infix <code class="pod-code-inline">&amp;</code></a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">25.2</td><td class="toc-text"><a href="#infix_(&amp;),_infix_∩">infix <code class="pod-code-inline">(&amp;)</code> , infix <code class="pod-code-inline">∩</code></a></td></tr>
                                      <tr class="toc-level-2"><td class="toc-number">25.3</td><td class="toc-text"><a href="#infix_(.),_infix_⊍">infix <code class="pod-code-inline">(.)</code> , infix <code class="pod-code-inline">⊍</code></a></td></tr>
                       <tr class="toc-level-1"><td class="toc-number">26</td><td class="toc-text"><a href="#Junctive_OR_(any)_precedence">Junctive OR (any) precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">26.1</td><td class="toc-text"><a href="#infix_|">infix <code class="pod-code-inline">|</code></a></td></tr>
                  <tr class="toc-level-2"><td class="toc-number">26.2</td><td class="toc-text"><a href="#infix_(|),_infix_∪">infix <code class="pod-code-inline">(|)</code> , infix <code class="pod-code-inline">∪</code></a></td></tr>
                                    <tr class="toc-level-2"><td class="toc-number">26.3</td><td class="toc-text"><a href="#infix_(+),_infix_⊎">infix <code class="pod-code-inline">(+)</code> , infix <code class="pod-code-inline">⊎</code></a></td></tr>
                          <tr class="toc-level-2"><td class="toc-number">26.4</td><td class="toc-text"><a href="#infix_(-),_infix_∖">infix <code class="pod-code-inline">(-)</code> , infix <code class="pod-code-inline">∖</code></a></td></tr>
                                      <tr class="toc-level-2"><td class="toc-number">26.5</td><td class="toc-text"><a href="#infix_^">infix <code class="pod-code-inline">^</code></a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">26.6</td><td class="toc-text"><a href="#infix_(^),_infix_⊖">infix <code class="pod-code-inline">(^)</code> , infix <code class="pod-code-inline">⊖</code></a></td></tr>
                                            <tr class="toc-level-1"><td class="toc-number">27</td><td class="toc-text"><a href="#Named_unary_precedence">Named unary precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">27.1</td><td class="toc-text"><a href="#prefix_temp">prefix <code class="pod-code-inline">temp</code></a></td></tr>
                                                     <tr class="toc-level-2"><td class="toc-number">27.2</td><td class="toc-text"><a href="#prefix_let">prefix <code class="pod-code-inline">let</code></a></td></tr>
                                 <tr class="toc-level-1"><td class="toc-number">28</td><td class="toc-text"><a href="#Nonchaining_binary_precedence">Nonchaining binary precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">28.1</td><td class="toc-text"><a href="#infix_does">infix <code class="pod-code-inline">does</code></a></td></tr>
                    <tr class="toc-level-2"><td class="toc-number">28.2</td><td class="toc-text"><a href="#infix_but">infix <code class="pod-code-inline">but</code></a></td></tr>
                                       <tr class="toc-level-2"><td class="toc-number">28.3</td><td class="toc-text"><a href="#infix_cmp">infix <code class="pod-code-inline">cmp</code></a></td></tr>
                 <tr class="toc-level-2"><td class="toc-number">28.4</td><td class="toc-text"><a href="#infix_coll">infix <code class="pod-code-inline">coll</code></a></td></tr>
                     <tr class="toc-level-2"><td class="toc-number">28.5</td><td class="toc-text"><a href="#infix_unicmp">infix <code class="pod-code-inline">unicmp</code></a></td></tr>
                  <tr class="toc-level-2"><td class="toc-number">28.6</td><td class="toc-text"><a href="#infix_leg">infix <code class="pod-code-inline">leg</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">28.7</td><td class="toc-text"><a href="#infix_&lt;=&gt;">infix <code class="pod-code-inline">&lt;=&gt;</code></a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">28.8</td><td class="toc-text"><a href="#infix_..">infix <code class="pod-code-inline">..</code></a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">28.9</td><td class="toc-text"><a href="#infix_..^">infix <code class="pod-code-inline">..^</code></a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">28.10</td><td class="toc-text"><a href="#infix_^..">infix <code class="pod-code-inline">^..</code></a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">28.11</td><td class="toc-text"><a href="#infix_^..^">infix <code class="pod-code-inline">^..^</code></a></td></tr>
      <tr class="toc-level-1"><td class="toc-number">29</td><td class="toc-text"><a href="#Chaining_binary_precedence">Chaining binary precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">29.1</td><td class="toc-text"><a href="#infix_==">infix <code class="pod-code-inline">==</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">29.2</td><td class="toc-text"><a href="#infix_!=">infix <code class="pod-code-inline">!=</code></a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">29.3</td><td class="toc-text"><a href="#infix_≠">infix <code class="pod-code-inline">≠</code></a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">29.4</td><td class="toc-text"><a href="#infix_&lt;">infix <code class="pod-code-inline">&lt;</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">29.5</td><td class="toc-text"><a href="#infix_&lt;=">infix <code class="pod-code-inline">&lt;=</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">29.6</td><td class="toc-text"><a href="#infix_≤">infix <code class="pod-code-inline">≤</code></a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">29.7</td><td class="toc-text"><a href="#infix_&gt;">infix <code class="pod-code-inline">&gt;</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">29.8</td><td class="toc-text"><a href="#infix_&gt;=">infix <code class="pod-code-inline">&gt;=</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">29.9</td><td class="toc-text"><a href="#infix_≥">infix <code class="pod-code-inline">≥</code></a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">29.10</td><td class="toc-text"><a href="#infix_eq">infix <code class="pod-code-inline">eq</code></a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">29.11</td><td class="toc-text"><a href="#infix_ne">infix <code class="pod-code-inline">ne</code></a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">29.12</td><td class="toc-text"><a href="#infix_gt">infix <code class="pod-code-inline">gt</code></a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">29.13</td><td class="toc-text"><a href="#infix_ge">infix <code class="pod-code-inline">ge</code></a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">29.14</td><td class="toc-text"><a href="#infix_lt">infix <code class="pod-code-inline">lt</code></a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">29.15</td><td class="toc-text"><a href="#infix_le">infix <code class="pod-code-inline">le</code></a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">29.16</td><td class="toc-text"><a href="#infix_before">infix <code class="pod-code-inline">before</code></a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">29.17</td><td class="toc-text"><a href="#infix_after">infix <code class="pod-code-inline">after</code></a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">29.18</td><td class="toc-text"><a href="#infix_eqv">infix <code class="pod-code-inline">eqv</code></a></td></tr>
                                                                     <tr class="toc-level-2"><td class="toc-number">29.19</td><td class="toc-text"><a href="#infix_===">infix <code class="pod-code-inline">===</code></a></td></tr>
                      <tr class="toc-level-2"><td class="toc-number">29.20</td><td class="toc-text"><a href="#infix_=:=">infix <code class="pod-code-inline">=:=</code></a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">29.21</td><td class="toc-text"><a href="#infix_~~">infix <code class="pod-code-inline">~~</code></a></td></tr>
                       <tr class="toc-level-2"><td class="toc-number">29.22</td><td class="toc-text"><a href="#infix_=~=">infix <code class="pod-code-inline">=~=</code></a></td></tr>
                       <tr class="toc-level-2"><td class="toc-number">29.23</td><td class="toc-text"><a href="#infix_(elem),_infix_∈">infix (elem), infix ∈</a></td></tr>
                     <tr class="toc-level-2"><td class="toc-number">29.24</td><td class="toc-text"><a href="#infix_∉">infix <code class="pod-code-inline">∉</code></a></td></tr>
                       <tr class="toc-level-2"><td class="toc-number">29.25</td><td class="toc-text"><a href="#infix_(cont),_infix_∋">infix (cont), infix ∋</a></td></tr>
                     <tr class="toc-level-2"><td class="toc-number">29.26</td><td class="toc-text"><a href="#infix_∌">infix <code class="pod-code-inline">∌</code></a></td></tr>
                       <tr class="toc-level-2"><td class="toc-number">29.27</td><td class="toc-text"><a href="#infix_(&lt;),_infix_⊂">infix <code class="pod-code-inline">(&lt;)</code> , infix <code class="pod-code-inline">⊂</code></a></td></tr>
                               <tr class="toc-level-2"><td class="toc-number">29.28</td><td class="toc-text"><a href="#infix_⊄">infix <code class="pod-code-inline">⊄</code></a></td></tr>
                         <tr class="toc-level-2"><td class="toc-number">29.29</td><td class="toc-text"><a href="#infix_(&lt;=),_infix_⊆">infix <code class="pod-code-inline">(&lt;=)</code> , infix <code class="pod-code-inline">⊆</code></a></td></tr>
                               <tr class="toc-level-2"><td class="toc-number">29.30</td><td class="toc-text"><a href="#infix_⊈">infix <code class="pod-code-inline">⊈</code></a></td></tr>
                         <tr class="toc-level-2"><td class="toc-number">29.31</td><td class="toc-text"><a href="#infix_(&gt;),_infix_⊃">infix <code class="pod-code-inline">(&gt;)</code> , infix <code class="pod-code-inline">⊃</code></a></td></tr>
                               <tr class="toc-level-2"><td class="toc-number">29.32</td><td class="toc-text"><a href="#infix_⊅">infix <code class="pod-code-inline">⊅</code></a></td></tr>
                         <tr class="toc-level-2"><td class="toc-number">29.33</td><td class="toc-text"><a href="#infix_(&gt;=),_infix_⊇">infix <code class="pod-code-inline">(&gt;=)</code> , infix <code class="pod-code-inline">⊇</code></a></td></tr>
                               <tr class="toc-level-2"><td class="toc-number">29.34</td><td class="toc-text"><a href="#infix_⊉">infix <code class="pod-code-inline">⊉</code></a></td></tr>
                         <tr class="toc-level-1"><td class="toc-number">30</td><td class="toc-text"><a href="#Tight_AND_precedence">Tight AND precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">30.1</td><td class="toc-text"><a href="#infix_&amp;&amp;">infix <code class="pod-code-inline">&amp;&amp;</code></a></td></tr>
      <tr class="toc-level-1"><td class="toc-number">31</td><td class="toc-text"><a href="#Tight_OR_precedence">Tight OR precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">31.1</td><td class="toc-text"><a href="#infix_||">infix <code class="pod-code-inline">||</code></a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">31.2</td><td class="toc-text"><a href="#infix_^^">infix <code class="pod-code-inline">^^</code></a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">31.3</td><td class="toc-text"><a href="#infix_//">infix <code class="pod-code-inline">//</code></a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">31.4</td><td class="toc-text"><a href="#infix_min">infix <code class="pod-code-inline">min</code></a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">31.5</td><td class="toc-text"><a href="#infix_max">infix <code class="pod-code-inline">max</code></a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">31.6</td><td class="toc-text"><a href="#infix_minmax">infix <code class="pod-code-inline">minmax</code></a></td></tr>
                                            <tr class="toc-level-1"><td class="toc-number">32</td><td class="toc-text"><a href="#Conditional_operator_precedence">Conditional operator precedence</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">32.1</td><td class="toc-text"><a href="#infix_??_!!">infix <code class="pod-code-inline">?? !!</code></a></td></tr>
                 <tr class="toc-level-2"><td class="toc-number">32.2</td><td class="toc-text"><a href="#infix_ff">infix <code class="pod-code-inline">ff</code></a></td></tr>
                                                                    <tr class="toc-level-2"><td class="toc-number">32.3</td><td class="toc-text"><a href="#infix_^ff">infix <code class="pod-code-inline">^ff</code></a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">32.4</td><td class="toc-text"><a href="#infix_ff^">infix <code class="pod-code-inline">ff^</code></a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">32.5</td><td class="toc-text"><a href="#infix_^ff^">infix <code class="pod-code-inline">^ff^</code></a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">32.6</td><td class="toc-text"><a href="#infix_fff">infix <code class="pod-code-inline">fff</code></a></td></tr>
                               <tr class="toc-level-2"><td class="toc-number">32.7</td><td class="toc-text"><a href="#infix_^fff">infix <code class="pod-code-inline">^fff</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">32.8</td><td class="toc-text"><a href="#infix_fff^">infix <code class="pod-code-inline">fff^</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">32.9</td><td class="toc-text"><a href="#infix_^fff^">infix <code class="pod-code-inline">^fff^</code></a></td></tr>
          <tr class="toc-level-1"><td class="toc-number">33</td><td class="toc-text"><a href="#Item_assignment_precedence">Item assignment precedence</a></td></tr>
  <tr class="toc-level-2"><td class="toc-number">33.1</td><td class="toc-text"><a href="#infix_=_(item_assignment)">infix <code class="pod-code-inline">=</code> (item assignment)</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">33.2</td><td class="toc-text"><a href="#infix_=&gt;">infix <code class="pod-code-inline">=&gt;</code></a></td></tr>
                    <tr class="toc-level-1"><td class="toc-number">34</td><td class="toc-text"><a href="#Loose_unary_precedence">Loose unary precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">34.1</td><td class="toc-text"><a href="#prefix_not">prefix <code class="pod-code-inline">not</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">34.2</td><td class="toc-text"><a href="#prefix_so">prefix <code class="pod-code-inline">so</code></a></td></tr>
     <tr class="toc-level-1"><td class="toc-number">35</td><td class="toc-text"><a href="#Comma_operator_precedence">Comma operator precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">35.1</td><td class="toc-text"><a href="#infix_,">infix <code class="pod-code-inline">,</code></a></td></tr>
                       <tr class="toc-level-2"><td class="toc-number">35.2</td><td class="toc-text"><a href="#infix_:">infix <code class="pod-code-inline">:</code></a></td></tr>
        <tr class="toc-level-1"><td class="toc-number">36</td><td class="toc-text"><a href="#List_infix_precedence">List infix precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">36.1</td><td class="toc-text"><a href="#infix_Z">infix <code class="pod-code-inline">Z</code></a></td></tr>
                                   <tr class="toc-level-2"><td class="toc-number">36.2</td><td class="toc-text"><a href="#infix_X">infix <code class="pod-code-inline">X</code></a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">36.3</td><td class="toc-text"><a href="#infix_...">infix <code class="pod-code-inline">...</code>       </a></td></tr>
                                                                     <tr class="toc-level-1"><td class="toc-number">37</td><td class="toc-text"><a href="#List_prefix_precedence">List prefix precedence</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">37.1</td><td class="toc-text"><a href="#infix_=_(list_assignment)">infix <code class="pod-code-inline">=</code> (list assignment)</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">37.2</td><td class="toc-text"><a href="#infix_:=">infix <code class="pod-code-inline">:=</code></a></td></tr>
                                     <tr class="toc-level-2"><td class="toc-number">37.3</td><td class="toc-text"><a href="#infix_::=">infix <code class="pod-code-inline">::=</code></a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">37.4</td><td class="toc-text"><a href="#listop_...">listop <code class="pod-code-inline">...</code></a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">37.5</td><td class="toc-text"><a href="#listop_!!!">listop <code class="pod-code-inline">!!!</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">37.6</td><td class="toc-text"><a href="#listop_???">listop <code class="pod-code-inline">???</code></a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">37.7</td><td class="toc-text"><a href="#Reduction_operators">Reduction operators</a></td></tr>
        <tr class="toc-level-1"><td class="toc-number">38</td><td class="toc-text"><a href="#Loose_AND_precedence">Loose AND precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">38.1</td><td class="toc-text"><a href="#infix_and">infix <code class="pod-code-inline">and</code></a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">38.2</td><td class="toc-text"><a href="#infix_andthen">infix <code class="pod-code-inline">andthen</code></a></td></tr>
                                          <tr class="toc-level-2"><td class="toc-number">38.3</td><td class="toc-text"><a href="#infix_notandthen">infix <code class="pod-code-inline">notandthen</code></a></td></tr>
                                                                      <tr class="toc-level-1"><td class="toc-number">39</td><td class="toc-text"><a href="#Loose_OR_precedence">Loose OR precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">39.1</td><td class="toc-text"><a href="#infix_or">infix <code class="pod-code-inline">or</code></a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">39.2</td><td class="toc-text"><a href="#infix_orelse">infix <code class="pod-code-inline">orelse</code></a></td></tr>
                           <tr class="toc-level-2"><td class="toc-number">39.3</td><td class="toc-text"><a href="#infix_xor">infix <code class="pod-code-inline">xor</code></a></td></tr>
                     <tr class="toc-level-1"><td class="toc-number">40</td><td class="toc-text"><a href="#Sequencer_precedence">Sequencer precedence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">40.1</td><td class="toc-text"><a href="#infix_==&gt;">infix <code class="pod-code-inline">==&gt;</code></a></td></tr>
                          <tr class="toc-level-2"><td class="toc-number">40.2</td><td class="toc-text"><a href="#infix_&lt;==">infix <code class="pod-code-inline">&lt;==</code></a></td></tr>
         <tr class="toc-level-1"><td class="toc-number">41</td><td class="toc-text"><a href="#Identity">Identity</a></td></tr>
                                
</table>
</nav>

        <div class="pod-body ">
            <p>See <a href="/Documentable/integration-test/language/optut">creating operators</a> on how to define new operators.</p>
<h1 id="Operator_precedence"><a class="u" href="#___top" title="go to top of document">Operator precedence</a></h1>
<p>The precedence and associativity of Raku operators determine the order of evaluation of operands in expressions.</p>
<p>Where two operators with a different precedence act on the same operand, the subexpression involving the higher-precedence operator is evaluated first. For instance, in the expression <code>1 + 2 * 3</code>, both the binary <code>+</code> operator for addition and the binary <code>*</code> operator for multiplication act on the operand <code>2</code>. Because the <code>*</code> operator has a higher precedence than the <code>+</code> operator, the subexpression <code>2 * 3</code> will be evaluated first. Consequently, the resulting value of the overall expression is <code>7</code> and not <code>9</code>.</p>
<p>Instead of &quot;precedence&quot; one can also speak of &quot;binding&quot;: operators with a higher precedence are then said to have a tighter binding to the operand(s) in question, while operators with a lower precedence are said to have a looser binding. In practice one may also encounter blends of terminology, such as statements that an operator has a tighter or looser precedence.</p>
<p>Where two operators with a same precedence level act on an operand, the associativity of the operators determines which subexpression/operator is evaluated first. For instance, in the expression <code>100 / 2 * 10</code>, the binary division operator <code>/</code> and the binary multiplication operator <code>*</code> have equal precedence, so that the order of their evaluation is determined by their associativity. As the two operators are <em>left associative</em>, operations are grouped from the left like this: <code>(100 / 2) * 10</code>. The expression thus evaluates to <code>500</code>, rather than to <code>5</code>.</p>
<p>The following table summarizes the precedence levels (column labeled <code>Level</code>) offered by Raku, listing them in order from high to low precedence. For each precedence level the table also indicates the associativity of the operators assigned to that level (column labeled <code>A</code>), and some exemplary operators (column labeled <code>Examples</code>).</p>
<table class="pod-table">
<thead><tr>
<th>A</th> <th>Level</th> <th>Examples</th>
</tr></thead>
<tbody>
<tr> <td>N</td> <td>Terms</td> <td>42 3.14 &quot;eek&quot; qq[&quot;foo&quot;] $x :!verbose @$array rand time now ∅</td> </tr> <tr> <td>L</td> <td>Method postfix</td> <td>.meth .+ .? .* .() .[] .{} .&lt;&gt; .«» .:: .= .^ .:</td> </tr> <tr> <td>N</td> <td>Autoincrement</td> <td>++ --</td> </tr> <tr> <td>R</td> <td>Exponentiation</td> <td>**</td> </tr> <tr> <td>L</td> <td>Symbolic unary</td> <td>! + - ~ ? | || +^ ~^ ?^ ^</td> </tr> <tr> <td>L</td> <td>Dotty infix</td> <td>.= .</td> </tr> <tr> <td>L</td> <td>Multiplicative</td> <td>* × / ÷ % %% +&amp; +&lt; +&gt; ~&amp; ~&lt; ~&gt; ?&amp; div mod gcd lcm</td> </tr> <tr> <td>L</td> <td>Additive</td> <td>+ - − +| +^ ~| ~^ ?| ?^</td> </tr> <tr> <td>L</td> <td>Replication</td> <td>x xx</td> </tr> <tr> <td>X</td> <td>Concatenation</td> <td>~ o ∘</td> </tr> <tr> <td>X</td> <td>Junctive and</td> <td>&amp; (&amp;) (.) ∩ ⊍</td> </tr> <tr> <td>X</td> <td>Junctive or</td> <td>| ^ (|) (^) (+) (-) ∪ ⊖ ⊎ ∖</td> </tr> <tr> <td>L</td> <td>Named unary</td> <td>temp let</td> </tr> <tr> <td>N</td> <td>Structural infix</td> <td>but does &lt;=&gt; leg unicmp cmp coll .. ..^ ^.. ^..^</td> </tr> <tr> <td>C</td> <td>Chaining infix</td> <td>!= ≠ == &lt; &lt;= ≤ &gt; &gt;= ≥ eq ne lt le gt ge ~~ === eqv !eqv =~= ≅ (elem) (cont) (&lt;) (&gt;) (&lt;=) (&gt;=) (&lt;+) (&gt;+) ∈ ∉ ∋ ∌ ⊂ ⊄ ⊃ ⊅ ⊆ ⊈ ⊇ ⊉ ≼ ≽</td> </tr> <tr> <td>X</td> <td>Tight and</td> <td>&amp;&amp;</td> </tr> <tr> <td>X</td> <td>Tight or</td> <td>|| ^^ // min max</td> </tr> <tr> <td>R</td> <td>Conditional</td> <td>?? !! ff ff^ ^ff ^ff^ fff fff^ ^fff ^fff^</td> </tr> <tr> <td>R</td> <td>Item assignment</td> <td>= =&gt; += -= **= xx=</td> </tr> <tr> <td>L</td> <td>Loose unary</td> <td>so not</td> </tr> <tr> <td>X</td> <td>Comma operator</td> <td>, :</td> </tr> <tr> <td>X</td> <td>List infix</td> <td>Z minmax X X~ X* Xeqv ... … ...^ …^</td> </tr> <tr> <td>R</td> <td>List prefix</td> <td>print push say die map substr ... [+] [*] any Z=</td> </tr> <tr> <td>X</td> <td>Loose and</td> <td>and andthen notandthen</td> </tr> <tr> <td>X</td> <td>Loose or</td> <td>or xor orelse</td> </tr> <tr> <td>X</td> <td>Sequencer</td> <td>&lt;==, ==&gt;, &lt;&lt;==, ==&gt;&gt;</td> </tr> <tr> <td>N</td> <td>Terminator</td> <td>; {...}, unless, extra ), ], }</td> </tr>
</tbody>
</table><p>The following table further clarifies the meaning of the associativity symbols (<code>L R N C X</code>) specified above in column <code>A</code>. Using a fictitious <code>!</code> binary operator symbol, it shows how each associativity affects the interpretation of an expression involving two such operators of equal precedence:</p>
<table class="pod-table">
<thead><tr>
<th>A</th> <th>Assoc</th> <th>Meaning of $a ! $b ! $c</th>
</tr></thead>
<tbody>
<tr> <td>L</td> <td>left</td> <td>($a ! $b) ! $c</td> </tr> <tr> <td>R</td> <td>right</td> <td>$a ! ($b ! $c)</td> </tr> <tr> <td>N</td> <td>non</td> <td>ILLEGAL</td> </tr> <tr> <td>C</td> <td>chain</td> <td>($a ! $b) and ($b ! $c)</td> </tr> <tr> <td>X</td> <td>list</td> <td>infix:&lt;!&gt;($a; $b; $c)</td> </tr>
</tbody>
</table><p>For unary operators generically represented by a <code>!</code> symbol, the associativities <code>L R N</code> lead to the following interpretations:</p>
<table class="pod-table">
<thead><tr>
<th>A</th> <th>Assoc</th> <th>Meaning of !$a!</th>
</tr></thead>
<tbody>
<tr> <td>L</td> <td>left</td> <td>(!$a)!</td> </tr> <tr> <td>R</td> <td>right</td> <td>!($a!)</td> </tr> <tr> <td>N</td> <td>non</td> <td>ILLEGAL</td> </tr>
</tbody>
</table><p>In the operator descriptions below, a default associativity of <em>left</em> is assumed.</p>
<h1 id="Operator_classification"><a class="u" href="#___top" title="go to top of document">Operator classification</a></h1>
<p><a name="Documentable/integration-test/index-entry-prefix_operator"></a> <a name="Documentable/integration-test/index-entry-infix_operator"></a> <a name="Documentable/integration-test/index-entry-postfix_operator"></a> <a name="Documentable/integration-test/index-entry-circumfix_operator"></a> <a name="Documentable/integration-test/index-entry-postcircumfix_operator"></a> <a name="Documentable/integration-test/index-entry-method_operators"></a></p>
<p>Operators can occur in several positions relative to a term:</p>
<table class="pod-table">
<tbody>
<tr> <td>+term</td> <td>prefix</td> </tr> <tr> <td>term1 + term2</td> <td>infix</td> </tr> <tr> <td>term++</td> <td>postfix</td> </tr> <tr> <td>(term)</td> <td>circumfix</td> </tr> <tr> <td>term1[term2]</td> <td>postcircumfix</td> </tr> <tr> <td>.+(term)</td> <td>method</td> </tr>
</tbody>
</table><p>Each operator (except method operators) is also available as a subroutine. The name of the routine is formed from the operator category, followed by a colon, then a list quote construct with the symbol(s) that make up the operator:</p>
<pre class="pod-block-code">infix:&lt;+&gt;(1, 2);                # same as 1 + 2
circumfix:«[ ]»(&lt;a b c&gt;);       # same as [&lt;a b c&gt;]</pre>
<p>As a special case, a <em>listop</em> (list operator) can stand either as a term or as a prefix. Subroutine calls are the most common listops. Other cases include metareduced infix operators (<code>[+] 1, 2, 3</code>) and the <a href="#prefix_...">prefix ...</a> etc. stub operators.</p>
<p>Defining custom operators is covered in <a href="/Documentable/integration-test/language/functions#Defining_operators">Defining operators functions</a>.</p>
<h1 id="Metaoperators"><a class="u" href="#___top" title="go to top of document">Metaoperators</a></h1>
<p>Metaoperators can be parameterized with other operators or subroutines in the same way as functions can take functions as parameters. To use a subroutine as a parameter, prefix its name with a <code>&amp;</code>. Raku will generate the actual combined operator in the background, allowing the mechanism to be applied to user defined operators. To disambiguate chained metaoperators, enclose the inner operator in square brackets. There are quite a few metaoperators with different semantics as explained, next.</p>
<h1 id="Substitution_operators"><a class="u" href="#___top" title="go to top of document">Substitution operators</a></h1>
<p>Each substitution operator comes into two main forms: a lowercase one (e.g., <code>s///</code>) that performs <em>in-place</em> (i.e., <em>destructive</em> behavior; and an uppercase form (e.g., <code>S///</code>) that provides a <em>non-destructive</em> behavior.</p>
<h2 id="s///_in-place_substitution"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-testindex-entry-s///_in-place_substitution"><span class="index-entry"><code>s///</code> in-place substitution</span></a></a></h2>
<pre class="pod-block-code">my $str = &#39;old string&#39;;
$str ~~ s/o .+ d/new/;
say $str; # OUTPUT: «new string␤»</pre>
<p><code>s///</code> operates on the <code>$_</code> topical variable, changing it in place. It uses the given <a href="/Documentable/integration-test/type/Regex"><code>Regex</code></a> to find portions to replace and changes them to the provided replacement string. Sets <code>$/</code> to the <a href="/Documentable/integration-test/type/Match"><code>Match</code></a> object or, if multiple matches were made, a <a href="/Documentable/integration-test/type/List"><code>List</code></a> of <code>Match</code> objects. Returns <code>$/</code>.</p>
<p>It&#39;s common to use this operator with the <code>~~</code> smartmatch operator, as it aliases left-hand side to <code>$_</code>, which <code>s///</code> uses.</p>
<p>Regex captures can be referenced in the replacement part; it takes the same adverbs as the <a href="/Documentable/integration-test/routine/subst"><code>.subst</code> method</a>, which go between the <code>s</code> and the opening <code>/</code>, separated with optional whitespace:</p>
<pre class="pod-block-code">my $str = &#39;foo muCKed into the lEn&#39;;

# replace second &#39;o&#39; with &#39;x&#39;
$str ~~ s:2nd/o/x/;

# replace &#39;M&#39; or &#39;L&#39; followed by non-whitespace stuff with &#39;d&#39;
# and lower-cased version of that stuff:
$str ~~ s :g :i/&lt;[ML]&gt; (\S+)/d{lc $0}/;

say $str; # OUTPUT: «fox ducked into the den␤»</pre>
<p>You can also use a different delimiter:</p>
<pre class="pod-block-code">my $str = &#39;foober&#39;;
$str ~~ s!foo!fox!;
$str ~~ s{b(.)r} = &quot; d$0n&quot;;
say $str; # OUTPUT: «fox den␤»</pre>
<p>Non-paired characters can simply replace the original slashes. Paired characters, like curly braces, are used only on the match portion, with the substitution given by assignment (of anything: a string, a routine call, etc.).</p>
<h2 id="S///_non-destructive_substitution"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-testindex-entry-S///_non-destructive_substitution"><span class="index-entry"><code>S///</code> non-destructive substitution</span></a></a></h2>
<pre class="pod-block-code">say S/o .+ d/new/ with &#39;old string&#39;;      # OUTPUT: «new string␤»
S:g/« (.)/$0.uc()/.say for &lt;foo bar ber&gt;; # OUTPUT: «Foo␤Bar␤Ber␤»</pre>
<p><code>S///</code> uses the same semantics as the <code>s///</code> operator, except it leaves the original string intact and <em>returns the resultant string</em> instead of <code>$/</code> (<code>$/</code> still being set to the same values as with <code>s///</code>).</p>
<p><strong>Note:</strong> since the result is obtained as a return value, using this operator with the <code>~~</code> smartmatch operator is a mistake and will issue a warning. To execute the substitution on a variable that isn&#39;t the <code>$_</code> this operator uses, alias it to <code>$_</code> with <code>given</code>, <code>with</code>, or any other way. Alternatively, use the <a href="/Documentable/integration-test/routine/subst"><code>.subst</code> method</a>.</p>
<h2 id="tr///_in-place_transliteration"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-testindex-entry-tr///_in-place_transliteration"><span class="index-entry"><code>tr///</code> in-place transliteration</span></a></a></h2>
<pre class="pod-block-code">my $str = &#39;old string&#39;;
$str ~~ tr/dol/wne/;
say $str; # OUTPUT: «new string␤»</pre>
<p><code>tr///</code> operates on the <code>$_</code> topical variable and changes it in place. It behaves similar to <a href="/Documentable/integration-test/routine/trans"><code>Str.trans</code></a> called with a single <a href="/Documentable/integration-test/type/Pair">Pair</a> argument, where key is the matching part (characters <code>dol</code> in the example above) and value is the replacement part (characters <code>wne</code> in the example above). Accepts the same adverbs as <a href="/Documentable/integration-test/routine/trans"><code>Str.trans</code></a>. Returns the <a href="/Documentable/integration-test/type/StrDistance">StrDistance</a> object that measures the distance between original value and the resultant string.</p>
<pre class="pod-block-code">my $str = &#39;old string&#39;;
$str ~~ tr:c:d/dol st//;
say $str; # OUTPUT: «old st␤»</pre>
<h2 id="TR///_non-destructive_transliteration"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-testindex-entry-TR///_non-destructive_transliteration"><span class="index-entry"><code>TR///</code> non-destructive transliteration</span></a></a></h2>
<pre class="pod-block-code">with &#39;old string&#39; {
    say TR/dol/wne/; # OUTPUT: «new string␤»
}</pre>
<p><code>TR///</code> behaves the same as the <code>tr///</code> operator, except that it leaves the <code>$_</code> value untouched and instead returns the resultant string.</p>
<pre class="pod-block-code">say TR:d/dol // with &#39;old string&#39;; # OUTPUT: «string␤»</pre>
<h1 id="Assignment_operators"><a class="u" href="#___top" title="go to top of document">Assignment operators</a></h1>
<p>Raku has a variety of assignment operators, which can be roughly classified as simple assignment operators and compound assignment operators.</p>
<p>The simple assignment operator symbol is <code>=</code>. It is &#39;overloaded&#39; in the sense that it can mean either <a href="/Documentable/integration-test/language/operators#infix_=_(item_assignment)">item assignment</a> or <a href="/Documentable/integration-test/language/operators#infix_=_(list_assignment)">list assignment</a> depending on the context in which it is used:</p>
<pre class="pod-block-code">my $x = 1;        # item assignment; $x = 1
my @x = 1,2,3;    # list assignment; @x = [1,2,3]</pre>
<p>See the section on <a href="/Documentable/integration-test/language/variables#Item_and_list_assignment">item and list assignment</a> for a more elaborate and comparative discussion of these two types of assignment.</p>
<p>The compound assignment operators are <a href="/Documentable/integration-test/language/operators#Metaoperators">metaoperators</a>: they combine the simple assignment operator <code>=</code> with an infix operator to form a new operator that performs the operation specified by the infix operator before assigning the result to the left operand. Some examples of built-in compound assignment operators are <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>min=</code>, and <code>~=</code>. Here is how they work:</p>
<pre class="pod-block-code">my $a = 32;
$a += 10;         # $a = 42
$a -= 2;          # $a = 40

$a = 3;
$a min= 5;        # $a = 3
$a min= 2;        # $a = 2

my $s = &#39;a&#39;;
$s ~= &#39;b&#39;;        # $s = &#39;ab&#39;

# And an example of a custom operator:
sub infix:&lt;space-concat&gt; ($a, $b) { $a ~ &quot; &quot; ~ $b };
my $a = &#39;word1&#39;;
$a space-concat= &#39;word2&#39;;                 # OUTPUT: «&#39;word1 word2&#39;␤»</pre>
<p>One thing the simple and compound assignment operators have in common is that they form so-called <em>assignment expressions</em> that return or evaluate to the assigned value:</p>
<pre class="pod-block-code">my sub fac (Int $n) { [*] 1..$n };        # sub for calculating factorial
my @x = ( my $y = fac(100), $y*101 );     # @x = [100!, 101!]

my $i = 0;
repeat { say $i } while ($i += 1) &lt; 10;   # OUTPUT: «0,1,2,...9␤»</pre>
<p>In the first example, the assignment expression <code>my $y = fac(100)</code> declares <code>$y</code>, assigns the value <code>fac(100)</code> to it, and finally returns the assigned value <code>fac(100)</code>. The returned value is then taken into account for constructing the List. In the second example the compound-assignment expression <code>$i += 1</code> assigns the value <code>$i + 1</code> to <code>$i</code>, and subsequently evaluates to the assigned value <code>$i+1</code>, thus allowing the returned value to be used for judging the while loop condition.</p>
<p>In dealing with simple and compound assignment operators, it is tempting to think that for instance the following two statements are (always) equivalent:</p>
<pre class="pod-block-code">    expression1 += expression2;                     # compound assignment
    expression1  = expression1 + expression2;       # simple assignment
</pre>
<p>They are not, however, for two reasons. Firstly, <code>expression1</code> in the compound assignment statement is evaluated only once, whereas <code>expression1</code> in the simple assignment statement is evaluated twice. Secondly, the compound assignment statement may, depending on the infix operator in question, implicitly initialize <code>expression1</code> if it is a variable with an undefined value. Such initialization will not occur for <code>expression1</code> in the simple assignment statement.</p>
<p>The aforementioned two differences between the simple and compound assignment statements are briefly elucidated below.</p>
<p>The first difference is common amongst programming languages and mostly self-explanatory. In the compound assignment, there is only one <code>expression1</code> that is explicitly specified to serve both as a term of the addition to be performed and as the location where the result of the addition, the sum, is to be stored. There is thus no need to evaluate it twice. The simple assignment, in contrast, is more generic in the sense that the value of the <code>expression1</code> that serves as a term of the addition need not necessarily be the same as the value of the <code>expression1</code> that defines the location where the sum must be stored. The two expressions are therefore evaluated separately. The distinction is particularly relevant in cases where the evaluation of <code>expression1</code> has side effects in the form of changes to one or more variables:</p>
<pre class="pod-block-code">my @arr = [10, 20, 30];
my $i = 0;

if rand &lt; 1/2 {
    @arr[++$i] += 1;                # @arr = [10,21,30]
} else {
    @arr[++$i] = @arr[++$i] + 1;    # @arr = [10,31,30] (or [10,20,21]?)
}                                   # the result may be implementation-specific
say @arr;</pre>
<p>The second difference pointed out above is related to the widespread practice of using compound assignment operators in <em>accumulator patterns</em>. Such patterns involve a so-called <em>accumulator</em>: a variable that calculates the sum or a product of a series of values in a loop. To obviate the need for explicit accumulator initialization, Raku&#39;s compound assignment operators silently take care of the initialization where this is sensibly possible:</p>
<pre class="pod-block-code">my @str = &quot;Cleanliness is next to godliness&quot;.comb;
my ($len, $str);
for @str -&gt; $c {
  $len += 1;
  $str ~= $c;
}
say &quot;The string &#39;$str&#39; has $len characters.&quot;;</pre>
<p>In this example the accumulators <code>$len</code> and <code>$str</code> are implicitly initialized to <code>0</code> and <code>&quot;&quot;</code>, respectively, which illustrates that the initialization value is operator-specific. In this regard it is also noted that not all compound assignment operators can sensibly initialize an undefined left-hand side variable. The <code>/=</code> operator, for instance, will not arbitrarily select a value for the dividend; instead, it will throw an exception.</p>
<p>Although not strictly operators, methods can be used in the same fashion as compound assignment operators:</p>
<pre class="pod-block-code">my $a = 3.14;
$a .= round;      # $a = $a.round; OUTPUT: «3»</pre>
<h1 id="Negated_relational_operators"><a class="u" href="#___top" title="go to top of document">Negated relational operators <a name="Documentable/integration-test/index-entry-!_(negation_metaoperator)"></a><a name="Documentable/integration-test/index-entry-!=="></a><a name="Documentable/integration-test/index-entry-!eq"></a></a></h1>
<p>The result of a relational operator returning <code>Bool</code> can be negated by prefixing with <code>!</code>. To avoid visual confusion with the <code>!!</code> operator, you may not modify any operator already beginning with <code>!</code>.</p>
<p>There are shortcuts for <code>!==</code> and <code>!eq</code>, namely <code>!=</code> and <code>ne</code>.</p>
<pre class="pod-block-code">my $a = True;
say so $a != True;    # OUTPUT: «False␤»
my $i = 10;

my $release = Date.new(:2015year, :12month, :24day);
my $today = Date.today;
say so $release !before $today;     # OUTPUT: «False␤»</pre>
<h1 id="Reversed_operators"><a class="u" href="#___top" title="go to top of document">Reversed operators <a name="Documentable/integration-test/index-entry-R_reverse_metaoperator"></a></a></h1>
<p>Any infix operator may be called with its two arguments reversed by prefixing with <code>R</code>. Associativity of operands is reversed as well.</p>
<pre class="pod-block-code">say 4 R/ 12;               # OUTPUT: «3␤»
say [R/] 2, 4, 16;         # OUTPUT: «2␤»
say [RZ~] &lt;1 2 3&gt;,&lt;4 5 6&gt;  # OUTPUT: «(41 52 63)␤»</pre>
<p><a name="Documentable/integration-test/index-entry-»=«"></a> <a name="Documentable/integration-test/index-entry-«=»"></a></p>
<h1 id="Hyper_operators"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-hyper_<<-hyper_>>-hyper_«-hyper_»-Hyper_operators"><span class="index-entry">Hyper operators</span></a></a></h1>
<p>Hyper operators include <code>«</code> and <code>»</code>, with their ASCII variants <code>&lt;&lt;</code> and <code>&gt;&gt;</code>. They apply a given operator enclosed (or preceded or followed, in the case of unary operators) by <code>«</code> and/or <code>»</code> to one or two lists, returning the resulting list, with the pointy part of <code>«</code> or <code>»</code> aimed at the shorter list. Single elements are turned to a list, so they can be used too. If one of the lists is shorter than the other, the operator will cycle over the shorter list until all elements of the longer list are processed.</p>
<pre class="pod-block-code">say (1, 2, 3) »*» 2;          # OUTPUT: «(2 4 6)␤»
say (1, 2, 3, 4) »~» &lt;a b&gt;;   # OUTPUT: «(1a 2b 3a 4b)␤»
say (1, 2, 3) »+« (4, 5, 6);  # OUTPUT: «(5 7 9)␤»
say (&amp;sin, &amp;cos, &amp;sqrt)».(0.5);
# OUTPUT: «(0.479425538604203 0.877582561890373 0.707106781186548)␤»</pre>
<p>The last example illustrates how postcircumfix operators (in this case .()) can also be hypered.</p>
<pre class="pod-block-code">my @a = &lt;1 2 3&gt;;
my @b = &lt;4 5 6&gt;;
say (@a,@b)»[1]; # OUTPUT: «(2 5)␤»</pre>
<p>In this case, it&#39;s the <a href="/Documentable/integration-test/language/operators#circumfix_[_]">postcircumfix[]</a> which is being hypered.</p>
<p>Assignment metaoperators can be <em>hyped</em>.</p>
<pre class="pod-block-code">my @a = 1, 2, 3;
say @a »+=» 1;    # OUTPUT: «[2 3 4]␤»
my ($a, $b, $c);
(($a, $b), $c) «=» ((1, 2), 3);
say &quot;$a, $c&quot;;       #  OUTPUT: «1, 3␤»</pre>
<p>Hyper forms of unary operators have the pointy bit aimed at the operator and the blunt end at the list to be operated on.</p>
<pre class="pod-block-code">my @wisdom = True, False, True;
say !« @wisdom;     # OUTPUT: «[False True False]␤»

my @a = 1, 2, 3;
@a»++;
say @a;             # OUTPUT: «[2 3 4]␤»</pre>
<p>Hyper operators are defined recursively on nested arrays.</p>
<pre class="pod-block-code">say -« [[1, 2], 3]; # OUTPUT: «[[-1 -2] -3]␤»</pre>
<p>Also, methods can be called in an out of order, concurrent fashion. The resulting list will be in order. Note that all hyper operators are candidates for parallelism and will cause tears if the methods have side effects. The optimizer has full reign over hyper operators, which is the reason that they cannot be defined by the user.</p>
<pre class="pod-block-code">class CarefulClass { method take-care {} }
my CarefulClass @objs;
my @results = @objs».take-care();

my @slops;        # May Contain Nuts
@slops».?this-method-may-not-exist();</pre>
<p>Hyper operators can work with hashes. The pointy direction indicates if missing keys are to be ignored in the resulting hash. The enclosed operator operates on all values that have keys in both hashes.</p>
<table class="pod-table">
<tbody>
<tr> <td>%foo «+» %bar;</td> <td>intersection of keys</td> </tr> <tr> <td>%foo »+« %bar;</td> <td>union of keys</td> </tr> <tr> <td>%outer »+» %inner;</td> <td>only keys of %inner that exist in %outer will occur in the result</td> </tr>
</tbody>
</table><pre class="pod-block-code">my %outer = 1, 2, 3 Z=&gt; &lt;a b c&gt;;
my %inner = 1, 2 Z=&gt; &lt;x z&gt;;
say %outer «~» %inner;          # OUTPUT: «{&quot;1&quot; =&gt; &quot;ax&quot;, &quot;2&quot; =&gt; &quot;bz&quot;}␤»</pre>
<p>Hyper operators can take user-defined operators as their operator argument.</p>
<pre class="pod-block-code">sub pretty-file-size (Int $size --&gt; Str) {
    # rounding version of infix:&lt;/&gt;(Int, Int)
    sub infix:&lt;r/&gt;(Int \i1, Int \i2) {
        round(i1 / i2, 0.1)
    }

    # we build a vector of fractions of $size and zip that with the fitting prefix
    for $size «[r/]« (2**60, 2**50, 2**40, 2**30, 2**20, 2**10)
              Z      &lt;EB     PB     TB     GB     MB     KB&gt; -&gt; [\v,\suffix] {
        # starting with the biggest suffix,
        # we take the first that is 0.5 of that suffix or bigger
        return v ~ &#39; &#39; ~ suffix if v &gt; 0.4
    }
    # this be smaller or equal then 0.4 KB
    return $size.Str;
}

for 60, 50, 40, 30, 20, 10 -&gt; $test {
    my &amp;a = { (2 ** $test) * (1/4, 1/2, 1, 10, 100).pick * (1..10).pick };
    print pretty-file-size(a.Int) xx 2, &#39; &#39;;
}

# OUTPUT: «10 EB 4 EB 2 PB 5 PB 0.5 PB 4 TB 300 GB 4.5 GB 50 MB 200 MB 9 KB 0.6 MB␤»</pre>
<p>Whether hyperoperators descend into child lists depends on the <a href="/Documentable/integration-test/language/typesystem#trait_is_nodal">nodality</a> of the inner operator of a chain. For the hyper method call operator (».), the nodality of the target method is significant.</p>
<pre class="pod-block-code">say (&lt;a b&gt;, &lt;c d e&gt;)».elems;        # OUTPUT: «(2 3)␤»
say (&lt;a b&gt;, &lt;c d e&gt;)».&amp;{ .elems };  # OUTPUT: «((1 1) (1 1 1))␤»</pre>
<p>You can chain hyper operators to destructure a List of Lists.</p>
<pre class="pod-block-code">my $neighbors = ((-1, 0), (0, -1), (0, 1), (1, 0));
my $p = (2, 3);
say $neighbors »&gt;&gt;+&lt;&lt;» ($p, *);   # OUTPUT: «((1 3) (2 2) (2 4) (3 3))␤»</pre>
<p><a name="Documentable/integration-test/index-entry-[]_(reduction_metaoperators)"></a><a name="Documentable/integration-test/index-entry-[+]_(reduction_metaoperators)"></a></p>
<h1 id="Reduction_metaoperators"><a class="u" href="#___top" title="go to top of document">Reduction metaoperators</a></h1>
<p>The reduction metaoperator, <code>[ ]</code>, reduces a list with the given infix operator. It gives the same result as the <a href="/Documentable/integration-test/routine/reduce">reduce</a> routine - see there for details.</p>
<pre class="pod-block-code"># These two are equivalent:
say [+] 1, 2, 3;                # OUTPUT: «6␤»
say reduce &amp;infix:&lt;+&gt;, 1, 2, 3; # OUTPUT: «6␤»</pre>
<p>No whitespace is allowed between the square brackets and the operator. To wrap a function instead of an operator, provide an additional layer of square brackets:</p>
<pre class="pod-block-code">sub plus { $^a + $^b };
say [[&amp;plus]] 1, 2, 3;          # OUTPUT: «6␤»</pre>
<p>The argument list is iterated without flattening. This means that you can pass a nested list to the reducing form of a list infix operator:</p>
<pre class="pod-block-code">say [X~] (1, 2), &lt;a b&gt;;         # OUTPUT: «(1a 1b 2a 2b)␤»</pre>
<p>which is equivalent to <code>1, 2 X~ &lt;a b&gt;</code>.</p>
<p><a name="Documentable/integration-test/index-entry-[\]_(triangular_reduction_metaoperators)"></a> By default, only the final result of the reduction is returned. Prefix the wrapped operator with a <code>\</code>, to return a lazy list of all intermediate values instead. This is called a &quot;triangular reduce&quot;. If the <em>non-meta</em> part contains a <code>\</code> already, quote it with <code>[]</code> (e.g. <code>[\[\x]]</code>).</p>
<pre class="pod-block-code">my @n = [\~] 1..*;
say @n[^5];         # OUTPUT: «(1 12 123 1234 12345)␤»</pre>
<h1 id="Cross_operators"><a class="u" href="#___top" title="go to top of document">Cross operators <a name="Documentable/integration-test/index-entry-X_(cross_metaoperator)"></a></a></h1>
<p>The cross metaoperator, <code>X</code>, will apply a given infix operator in order of cross product to all lists, such that the rightmost operand varies most quickly.</p>
<pre class="pod-block-code">1..3 X~ &lt;a b&gt; # OUTPUT: «&lt;1a, 1b, 2a, 2b, 3a, 3b&gt;␤»</pre>
<h1 id="Zip_metaoperator"><a class="u" href="#___top" title="go to top of document">Zip metaoperator <a name="Documentable/integration-test/index-entry-Z_(zip_metaoperator)"></a></a></h1>
<p>The zip metaoperator (which is not the same thing as <a href="#infix_Z">Z</a>) will apply a given infix operator to pairs taken one left, one right, from its arguments. The resulting list is returned.</p>
<pre class="pod-block-code">my @l = &lt;a b c&gt; Z~ 1, 2, 3;     # OUTPUT: «[a1 b2 c3]␤»</pre>
<p>If one of the operands runs out of elements prematurely, the zip operator will stop. An infinite list can be used to repeat elements. A list with a final element of <code>*</code> will repeat its 2nd last element indefinitely.</p>
<pre class="pod-block-code">my @l = &lt;a b c d&gt; Z~ &#39;:&#39; xx *;  # OUTPUT: «&lt;a: b: c: d:&gt;»
   @l = &lt;a b c d&gt; Z~ 1, 2, *;   # OUTPUT: «&lt;a1 b2 c2 d2&gt;»</pre>
<p>If an infix operator is not given, the <code>,</code> (comma operator) will be used by default:</p>
<pre class="pod-block-code">my @l = 1 Z 2;  # OUTPUT: «[(1 2)]»</pre>
<h1 id="Sequential_operators"><a class="u" href="#___top" title="go to top of document">Sequential operators <a name="Documentable/integration-test/index-entry-S_sequential_metaoperator"></a></a></h1>
<p>The sequential metaoperator, <code>S</code>, will suppress any concurrency or reordering done by the optimizer. Most simple infix operators are supported.</p>
<pre class="pod-block-code">say so 1 S&amp; 2 S&amp; 3;  # OUTPUT: «True␤»</pre>
<h1 id="Nesting_of_metaoperators"><a class="u" href="#___top" title="go to top of document">Nesting of metaoperators</a></h1>
<p>To avoid ambiguity when chaining metaoperators, use square brackets to help the compiler understand you.</p>
<pre class="pod-block-code">my @a = 1, 2, 3;
my @b = 5, 6, 7;
@a X[+=] @b;
say @a;         # OUTPUT: «[19 20 21]␤»</pre>
<h1 id="Term_precedence"><a class="u" href="#___top" title="go to top of document">Term precedence</a></h1>
<h2 id="term_<_>"><a class="u" href="#___top" title="go to top of document">term <code>&lt; &gt;</code></a></h2>
<p>The <a name="Documentable/integration-test/index-entry-qw-quote-words-quote-words"><span class="index-entry">quote-words</span></a> construct breaks up the contents on whitespace and returns a <a href="/Documentable/integration-test/type/List">List</a> of the words. If a word looks like a number literal or a <code>Pair</code> literal, it&#39;s converted to the appropriate number.</p>
<pre class="pod-block-code">say &lt;a b c&gt;[1];   # OUTPUT: «b␤»</pre>
<h2 id="term_(_)"><a class="u" href="#___top" title="go to top of document">term <code>( )</code></a></h2>
<p>The <a name="Documentable/integration-test/index-entry-grouping_operator"><span class="index-entry">grouping operator</span></a>.</p>
<p>An empty group <code>()</code> creates an <a href="/Documentable/integration-test/type/List#index-entry-()_empty_list">empty list</a>. Parentheses around non-empty expressions simply structure the expression, but do not have additional semantics.</p>
<p>In an argument list, putting parenthesis around an argument prevents it from being interpreted as a named argument.</p>
<pre class="pod-block-code">multi sub p(:$a!) { say &#39;named&#39;      }
multi sub p($a)   { say &#39;positional&#39; }
p a =&gt; 1;           # OUTPUT: «named␤»
p (a =&gt; 1);         # OUTPUT: «positional␤»</pre>
<h2 id="term_{_}"><a class="u" href="#___top" title="go to top of document">term <code>{ }</code></a></h2>
<p><a href="/Documentable/integration-test/type/Block">Block</a> or <a href="/Documentable/integration-test/type/Hash">Hash</a> constructor.<a name="Documentable/integration-test/index-entry-block_constructor-hash_constructor"></a></p>
<p>If the content is empty, or contains a single list that starts with a <a href="/Documentable/integration-test/type/Pair">Pair</a> literal or <code>%</code>-sigiled variable, and the <a href="/Documentable/integration-test/syntax/$_"><code>$_</code> variable</a> or placeholder parameters are not used, the constructor returns a <a href="/Documentable/integration-test/type/Hash">Hash</a>. Otherwise it constructs a <a href="/Documentable/integration-test/type/Block">Block</a>.</p>
<p>To force construction of a <a href="/Documentable/integration-test/type/Block">Block</a>, follow the opening brace with a semicolon. To always ensure you end up with a <a href="/Documentable/integration-test/type/Hash">Hash</a>, you can use <code>%( )</code> coercer or <a href="/Documentable/integration-test/routine/hash">hash</a> routine instead:</p>
<pre class="pod-block-code">{}.^name.say;        # OUTPUT: «Hash␤»
{;}.^name.say;       # OUTPUT: «Block␤»

{:$_}.^name.say;     # OUTPUT: «Block␤»
%(:$_).^name.say;    # OUTPUT: «Hash␤»
hash(:$_).^name.say; # OUTPUT: «Hash␤»</pre>
<h2 id="circumfix_[_]"><a class="u" href="#___top" title="go to top of document">circumfix <code>[ ]</code></a></h2>
<p>The <a name="Documentable/integration-test/index-entry-Array_constructor"><span class="index-entry"><a href="/Documentable/integration-test/type/Array">Array</a> constructor</span></a> returns an itemized <a href="/Documentable/integration-test/type/Array">Array</a> that does not flatten in list context. Check this:</p>
<pre class="pod-block-code">say .raku for [3,2,[1,0]]; # OUTPUT: «3␤2␤$[1, 0]␤»</pre>
<p>This array is itemized, in the sense that every element constitutes an item, as shown by the <code>$</code> preceding the last element of the array, the <a href="/Documentable/integration-test/type/Any#index-entry-%24_%28item_contextualizer%29">(list) item contextualizer</a>.</p>
<h1 id="Terms"><a class="u" href="#___top" title="go to top of document">Terms</a></h1>
<p>Terms have their <a href="/Documentable/integration-test/language/terms">own extended documentation</a>.</p>
<h1 id="Method_postfix_precedence"><a class="u" href="#___top" title="go to top of document">Method postfix precedence</a></h1>
<h2 id="postcircumfix_[_]"><a class="u" href="#___top" title="go to top of document">postcircumfix <code>[ ]</code></a></h2>
<pre class="pod-block-code">sub postcircumfix:&lt;[ ]&gt;(@container, **@index,
                        :$k, :$v, :$kv, :$p, :$exists, :$delete)</pre>
<p>Universal interface for positional access to zero or more elements of a @container, a.k.a. &quot;<a name="Documentable/integration-test/index-entry-array_indexing_operator-array_subscript_operator-array_indexing_operator"><span class="index-entry">array indexing operator</span></a>&quot;.</p>
<pre class="pod-block-code">my @alphabet = &#39;a&#39; .. &#39;z&#39;;
say @alphabet[0];                   # OUTPUT: «a␤»
say @alphabet[1];                   # OUTPUT: «b␤»
say @alphabet[*-1];                 # OUTPUT: «z␤»
say @alphabet[100]:exists;          # OUTPUT: «False␤»
say @alphabet[15, 4, 17, 11].join;  # OUTPUT: «perl␤»
say @alphabet[23 .. *].raku;        # OUTPUT: «(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)␤»

@alphabet[1, 2] = &quot;B&quot;, &quot;C&quot;;
say @alphabet[0..3].raku;           # OUTPUT: «(&quot;a&quot;, &quot;B&quot;, &quot;C&quot;, &quot;d&quot;)␤»</pre>
<p>See <a href="/Documentable/integration-test/language/subscripts">Subscripts</a>, for a more detailed explanation of this operator&#39;s behavior and for how to implement support for it in custom types.</p>
<h2 id="postcircumfix_{_}"><a class="u" href="#___top" title="go to top of document">postcircumfix <code>{ }</code></a></h2>
<pre class="pod-block-code">sub postcircumfix:&lt;{ }&gt;(%container, **@key,
                        :$k, :$v, :$kv, :$p, :$exists, :$delete)</pre>
<p>Universal interface for associative access to zero or more elements of a %container, a.k.a. &quot;<a name="Documentable/integration-test/index-entry-hash_indexing_operator-hash_subscript_operator-hash_indexing_operator"><span class="index-entry">hash indexing operator</span></a>&quot;.</p>
<pre class="pod-block-code">my %color = kiwi =&gt; &quot;green&quot;, banana =&gt; &quot;yellow&quot;, cherry =&gt; &quot;red&quot;;
say %color{&quot;banana&quot;};                 # OUTPUT: «yellow␤»
say %color{&quot;cherry&quot;, &quot;kiwi&quot;}.raku;    # OUTPUT: «(&quot;red&quot;, &quot;green&quot;)␤»
say %color{&quot;strawberry&quot;}:exists;      # OUTPUT: «False␤»

%color{&quot;banana&quot;, &quot;lime&quot;} = &quot;yellowish&quot;, &quot;green&quot;;
%color{&quot;cherry&quot;}:delete; # note that value is always returned but removal only happens when delete is true.
say %color;             # OUTPUT: «banana =&gt; yellowish, kiwi =&gt; green, lime =&gt; green␤»</pre>
<p>See <a href="/Documentable/integration-test/routine/< >#(Operators)_postcircumfix_<_>"><code>postcircumfix &lt; &gt;</code></a> and <a href="/Documentable/integration-test/routine/« »#(Operators)_postcircumfix_«_»"><code>postcircumfix « »</code></a> for convenient shortcuts, and <a href="/Documentable/integration-test/language/subscripts">Subscripts</a> for a more detailed explanation of this operator&#39;s behavior and how to implement support for it in custom types.</p>
<h2 id="postcircumfix_<>"><a class="u" href="#___top" title="go to top of document">postcircumfix <code>&lt;&gt;</code></a></h2>
<p>Decontainerization operator, which extracts the value from a container and makes it independent of the container type.</p>
<pre class="pod-block-code">use JSON::Tiny;

my $config = from-json(&#39;{ &quot;files&quot;: 3, &quot;path&quot;: &quot;/home/some-user/raku.pod6&quot; }&#39;);
say $config.raku;      # OUTPUT: «${:files(3), :path(&quot;/home/some-user/raku.pod6&quot;)}»
my %config-hash = $config&lt;&gt;;
say %config-hash.raku; # OUTPUT: «{:files(3), :path(&quot;/home/some-user/raku.pod6&quot;)}»
</pre>
<p>It&#39;s a <code>Hash</code> in both cases, and it can be used like that; however, in the first case it was in item context, and in the second case it has been extracted to its proper context.</p>
<h2 id="postcircumfix_<_>"><a class="u" href="#___top" title="go to top of document">postcircumfix <code>&lt; &gt;</code></a></h2>
<p>Shortcut for <a href="/Documentable/integration-test/routine/{ }#(Operators)_postcircumfix_{_}"><code>postcircumfix { }</code></a> that quotes its argument using the same rules as the <a href="/Documentable/integration-test/routine/< >#circumfix_<_>">quote-words operator</a> of the same name.</p>
<pre class="pod-block-code">my %color = kiwi =&gt; &quot;green&quot;, banana =&gt; &quot;yellow&quot;, cherry =&gt; &quot;red&quot;;
say %color&lt;banana&gt;;               # OUTPUT: «yellow␤»
say %color&lt;cherry kiwi&gt;.raku;     # OUTPUT: «(&quot;red&quot;, &quot;green&quot;)␤»
say %color&lt;strawberry&gt;:exists;    # OUTPUT: «False␤»</pre>
<p>Technically, not a real operator; it&#39;s syntactic sugar that&#39;s turned into the <code>{ }</code> postcircumfix operator at compile-time.</p>
<h2 id="postcircumfix_«_»"><a class="u" href="#___top" title="go to top of document">postcircumfix <code>« »</code></a></h2>
<p>Shortcut for <a href="/Documentable/integration-test/routine/{ }#(Operators)_postcircumfix_{_}"><code>postcircumfix { }</code></a> that quotes its argument using the same rules as the <a href="/Documentable/integration-test/language/quoting#Word_quoting_with_interpolation_and_quote_protection:_«_»">interpolating quote-words operator</a> of the same name.</p>
<pre class="pod-block-code">my %color = kiwi =&gt; &quot;green&quot;, banana =&gt; &quot;yellow&quot;, cherry =&gt; &quot;red&quot;;
my $fruit = &quot;kiwi&quot;;
say %color«cherry &quot;$fruit&quot;».raku;   # OUTPUT: «(&quot;red&quot;, &quot;green&quot;)␤»</pre>
<p>Technically, not a real operator; it&#39;s syntactic sugar that&#39;s turned into the <code>{ }</code> postcircumfix operator at compile-time.</p>
<h2 id="postcircumfix_(_)"><a class="u" href="#___top" title="go to top of document">postcircumfix <code>( )</code></a></h2>
<p>The <a name="Documentable/integration-test/index-entry-call_operator"><span class="index-entry">call operator</span></a> treats the invocant as a <a href="/Documentable/integration-test/type/Callable">Callable</a> and invokes it, using the expression between the parentheses as arguments.</p>
<p>Note that an identifier followed by a pair of parentheses is always parsed as a subroutine call.</p>
<p>If you want your objects to respond to the call operator, implement a <a href="/Documentable/integration-test/routine/CALL-ME"><code>method CALL-ME</code></a>.</p>
<h2 id="methodop_."><a class="u" href="#___top" title="go to top of document">methodop <code>.</code></a></h2>
<p>The operator for calling one method, <code>$invocant.method</code>.<a name="Documentable/integration-test/index-entry-method_call"></a></p>
<p>Technically, not a real operator; it&#39;s syntax special-cased in the compiler.</p>
<p><a name="Documentable/integration-test/index-entry-methodop_.&"></a></p>
<h2 id="methodop_.&"><a class="u" href="#___top" title="go to top of document">methodop <code>.&amp;</code></a></h2>
<p>The operator to call a subroutine (with at least one positional argument), such as a method. The invocant will be bound to the first positional argument.</p>
<p>Technically, not a real operator; it&#39;s syntax special-cased in the compiler.</p>
<pre class="pod-block-code">my sub f($invocant){ &quot;The arg has a value of $invocant&quot; }
42.&amp;f;
# OUTPUT: «The arg has a value of 42␤»

42.&amp;(-&gt; $invocant { &quot;The arg has a value of $invocant&quot; });
# OUTPUT: «The arg has a value of 42␤»</pre>
<h2 id="methodop_.="><a class="u" href="#___top" title="go to top of document">methodop <code>.=</code></a></h2>
<p>A <a name="Documentable/integration-test/index-entry-mutating_method_call"><span class="index-entry">mutating method call</span></a>. <code>$invocant.=method</code> desugars to <code>$invocant = $invocant.method</code>, similar to <a href="/Documentable/integration-test/routine/=">=</a> .</p>
<p>Technically, not a real operator; it&#39;s syntax special-cased in the compiler.</p>
<p><a name="Documentable/integration-test/index-entry-methodop_.$CIRCUMFLEX_ACCENT"></a></p>
<h2 id="methodop_.^"><a class="u" href="#___top" title="go to top of document">methodop <code>.^</code></a></h2>
<p>A <a name="Documentable/integration-test/index-entry-metamethod_call"><span class="index-entry">metamethod call</span></a>. <code>$invocant.^method</code> calls <code>method</code> on <code>$invocant</code>&#39;s metaclass. It desugars to <code>$invocant.HOW.method($invocant, ...)</code>. See <a href="/Documentable/integration-test/language/mop">the metaobject protocol documentation</a> for more information.</p>
<p>Technically, not a real operator; it&#39;s syntax special-cased in the compiler. It can be also applied, within classes, to access metamethods on self:</p>
<pre class="pod-block-code">class Foo {
    has $.a = 3;
    method bar {
        return $.^name
    }
};
say Foo.new.bar; # OUTPUT: «Foo␤»
</pre>
<p><a name="Documentable/integration-test/index-entry-methodop_.?"></a></p>
<h2 id="methodop_.?"><a class="u" href="#___top" title="go to top of document">methodop <code>.?</code></a></h2>
<p><a name="Documentable/integration-test/index-entry-Safe_call_operator"><span class="index-entry">Safe call operator</span></a>. <code>$invocant.?method</code> calls method <code>method</code> on <code>$invocant</code> if it has a method of such name. Otherwise it returns <a href="/Documentable/integration-test/type/Nil">Nil</a>.</p>
<p>Technically, not a real operator; it&#39;s syntax special-cased in the compiler.</p>
<p><a name="Documentable/integration-test/index-entry-methodop_.+"></a></p>
<h2 id="methodop_.+"><a class="u" href="#___top" title="go to top of document">methodop <code>.+</code></a></h2>
<p><code>$foo.+meth</code> walks the <a href="/Documentable/integration-test/language/objects#index-entry-MRO">MRO</a> and calls all the methods called <code>meth</code> and submethods called <code>meth</code> if the type is the same as type of <code>$foo</code>. Those methods might be multis, in which case the matching candidate would be called.</p>
<p>After that, a <a href="/Documentable/integration-test/type/List">List</a> of the results are returned. If no such method was found, it throws a <a href="/Documentable/integration-test/type/X::Method::NotFound">X::Method::NotFound</a> exception.</p>
<pre class="pod-block-code">class A {
  method foo { say &quot;from A&quot;; }
}
class B is A {
  multi method foo { say &quot;from B&quot;; }
  multi method foo(Str) { say &quot;from B (Str)&quot;; }
}
class C is B is A {
  multi method foo { say &quot;from C&quot;; }
  multi method foo(Str) { say &quot;from C (Str)&quot;; }
}

say C.+foo; # OUTPUT: «from C␤from B␤from A␤(True True True)␤»</pre>
<p><a name="Documentable/integration-test/index-entry-methodop_.*"></a></p>
<h2 id="methodop_.*"><a class="u" href="#___top" title="go to top of document">methodop <code>.*</code></a></h2>
<p><code>$foo.*meth</code> walks the <a href="/Documentable/integration-test/language/objects#index-entry-MRO">MRO</a> and calls all the methods called <code>meth</code> and submethods called <code>meth</code> if the type is the same as type of <code>$foo</code>. Those methods might be multis, in which case the matching candidate would be called.</p>
<p>After that, a <a href="/Documentable/integration-test/type/List">List</a> of the results are returned. If no such method was found, an empty <a href="/Documentable/integration-test/type/List">List</a> is returned.</p>
<p>Technically, postfix <code>.+</code> calls <code>.*</code> at first. Read postfix <code>.+</code> section to see examples.</p>
<p><a name="Documentable/integration-test/index-entry-methodop_»..html"></a><a name="Documentable/integration-test/index-entry-methodop_>>..html"></a></p>
<h2 id="methodop_»._/_methodop_>>."><a class="u" href="#___top" title="go to top of document">methodop <code>».</code> / methodop <code>&gt;&gt;.</code></a></h2>
<p>This is the <a name="Documentable/integration-test/index-entry-hyper_method_call_operator"><span class="index-entry">hyper method call operator</span></a>. Will call a method on all elements of a <code>List</code> out of order and return the list of return values in order.</p>
<pre class="pod-block-code">my @a = &lt;a b c&gt;;
my @b = @a».ord;                  # OUTPUT: «[97, 98, 99]␤»
# The first parameter of a method is the invocant.
sub foo(Str:D $c){ $c.ord * 2 };
# So we can pretend to have a method call with a sub that got a good
# first positional argument.
say @a».&amp;foo;
# Blocks have an implicit positional arguments that lands in $_. The latter can
# be omitted for method calls.
say @a».&amp;{ .ord};
</pre>
<p>Hyper method calls may appear to be the same as doing a <a href="/Documentable/integration-test/routine/map">map</a> call, however along with being a hint to the compiler that it can parallelize the call, the behavior is also affected by <a href="/Documentable/integration-test/routine/is%20nodal">nodality of the method</a> being invoked, depending on which either <a href="/Documentable/integration-test/routine/nodemap">nodemap</a> or <a href="/Documentable/integration-test/routine/deepmap">deepmap</a> semantics are used to perform the call.</p>
<p>The nodality is checked by looking up whether the <a href="/Documentable/integration-test/type/Callable">Callable</a> provides <code>nodal</code> method. If the hyper is applied to a method, that <a href="/Documentable/integration-test/type/Callable">Callable</a> is that method name, looked up on <a href="/Documentable/integration-test/type/List">List</a> type; if the hyper is applied to a routine (e.g. <code>».&amp;foo</code>), that routine functions as that <a href="/Documentable/integration-test/type/Callable">Callable</a>. If the <a href="/Documentable/integration-test/type/Callable">Callable</a> is determined to provide <code>nodal</code> method, <a href="/Documentable/integration-test/routine/nodemap">nodemap</a> semantics are used to perform the hyper call, otherwise <a href="/Documentable/integration-test/routine/duckmap">duckmap</a> semantics are used.</p>
<p>Take care to avoid a <a href="/Documentable/integration-test/language/traps#Using_»_and_map_interchangeably">common mistake</a> of expecting side-effects to occur in order. The following <code>say</code> is <strong>not</strong> guaranteed to produce the output in order:</p>
<pre class="pod-block-code">@a».say;  # WRONG! Could produce a␤b␤c␤ or c␤b␤a␤ or any other order
</pre>
<p><a name="Documentable/integration-test/index-entry-.(_)"></a><a name="Documentable/integration-test/index-entry-.[_]"></a><a name="Documentable/integration-test/index-entry-.{_}"></a></p>
<h2 id="methodop_.postfix_/_.postcircumfix"><a class="u" href="#___top" title="go to top of document">methodop <code>.postfix</code> / <code>.postcircumfix</code></a></h2>
<p>In most cases, a dot may be placed before a postfix or postcircumfix:</p>
<pre class="pod-block-code">my @a;
@a[1, 2, 3];
@a.[1, 2, 3]; # Same</pre>
<p>This can be useful for visual clarity or brevity. For example, if an object&#39;s attribute is a function, putting a pair of parentheses after the attribute name will become part of the method call. So, either two pairs of parentheses must be used or a dot has to come before the parentheses to separate it from the method call.</p>
<pre class="pod-block-code">class Operation {
    has $.symbol;
    has &amp;.function;
}
my $addition = Operation.new(:symbol&lt;+&gt;, :function{ $^a + $^b });
say $addition.function()(1, 2);   # OUTPUT: «3␤»
# OR
say $addition.function.(1, 2);    # OUTPUT: «3␤»</pre>
<p>If the postfix is an identifier, however, it will be interpreted as a normal method call.</p>
<pre class="pod-block-code">1.i # No such method &#39;i&#39; for invocant of type &#39;Int&#39;
</pre>
<p>Technically, not a real operator; it&#39;s syntax special-cased in the compiler.</p>
<p><a name="Documentable/integration-test/index-entry-postfix_operator_call"></a></p>
<h2 id="methodop_.:<prefix_operator>"><a class="u" href="#___top" title="go to top of document">methodop <code>.:&lt;prefix operator&gt;</code></a></h2>
<p>An operator in prefix form can still be called like a method, that is, using the <code>.</code> methodop notation, by preceding it by a colon. For example:</p>
<pre class="pod-block-code">my $a = 1;
say ++$a;       # OUTPUT: «2␤»
say $a.:&lt;++&gt;;   # OUTPUT: «3␤»</pre>
<p>Technically, not a real operator; it&#39;s syntax special-cased in the compiler, that is why it&#39;s classified as a <em>methodop</em>.</p>
<h2 id="methodop_.::"><a class="u" href="#___top" title="go to top of document">methodop <code>.::</code></a></h2>
<p>A <a name="Documentable/integration-test/index-entry-class-qualified_method_call"><span class="index-entry">class-qualified method call</span></a>, used to call a method as defined in a parent class or role, even after it has been redefined in the child class.</p>
<pre class="pod-block-code">class Bar {
    method baz { 42 }
}
class Foo is Bar {
    method baz { &quot;nope&quot; }
}
say Foo.Bar::baz;       # OUTPUT: «42␤»</pre>
<h2 id="postfix_,="><a class="u" href="#___top" title="go to top of document">postfix <code>,=</code></a></h2>
<p>Creates an object that concatenates, in a class-dependent way, the contents of the variable on the left hand side and the expression on the right hand side:</p>
<pre class="pod-block-code">my %a = :11a, :22b;
%a ,= :33x;
say %a # OUTPUT: «{a =&gt; 11, b =&gt; 22, x =&gt; 33}␤»</pre>
<h1 id="Autoincrement_precedence"><a class="u" href="#___top" title="go to top of document">Autoincrement precedence</a></h1>
<p><a name="Documentable/integration-test/index-entry-prefix_increment_operator"></a></p>
<h2 id="prefix_++"><a class="u" href="#___top" title="go to top of document">prefix <a name="Documentable/integration-test/index-entry-prefix_++-++"><span class="index-entry"><code>++</code></span></a></a></h2>
<pre class="pod-block-code">multi sub prefix:&lt;++&gt;($x is rw) is assoc&lt;non&gt;</pre>
<p>Increments its argument by one and returns the updated value.</p>
<pre class="pod-block-code">my $x = 3;
say ++$x;   # OUTPUT: «4␤»
say $x;     # OUTPUT: «4␤»</pre>
<p>It works by calling the <a href="/Documentable/integration-test/routine/succ">succ</a> method (for <em>successor</em>) on its argument, which gives custom types the freedom to implement their own increment semantics.</p>
<p><a name="Documentable/integration-test/index-entry-prefix_decrement_operator"></a></p>
<h2 id="prefix_--"><a class="u" href="#___top" title="go to top of document">prefix <a name="Documentable/integration-test/index-entry-prefix_-----"><span class="index-entry"><code>--</code></span></a></a></h2>
<pre class="pod-block-code">multi sub prefix:&lt;--&gt;($x is rw) is assoc&lt;non&gt;</pre>
<p>Decrements its argument by one and returns the updated value.</p>
<pre class="pod-block-code">my $x = 3;
say --$x;   # OUTPUT: «2␤»
say $x;     # OUTPUT: «2␤»</pre>
<p>It works by calling the <a href="/Documentable/integration-test/routine/pred">pred</a> method (for <em>predecessor</em>) on its argument, which gives custom types the freedom to implement their own decrement semantics.</p>
<p><a name="Documentable/integration-test/index-entry-postfix_increment_operator"></a></p>
<h2 id="postfix_++"><a class="u" href="#___top" title="go to top of document">postfix <a name="Documentable/integration-test/index-entry-postfix_++-++"><span class="index-entry"><code>++</code></span></a></a></h2>
<pre class="pod-block-code">multi sub postfix:&lt;++&gt;($x is rw) is assoc&lt;non&gt;</pre>
<p>Increments its argument by one and returns the original value.</p>
<pre class="pod-block-code">my $x = 3;
say $x++;   # OUTPUT: «3␤»
say $x;     # OUTPUT: «4␤»</pre>
<p>It works by calling the <a href="/Documentable/integration-test/routine/succ">succ</a> method (for <em>successor</em>) on its argument, which gives custom types the freedom to implement their own increment semantics; when undefined, it sets the value to 1 and returns it.</p>
<pre class="pod-block-code">my $x;
$x++;
say $x;     # OUTPUT: «1␤»</pre>
<p>Note that this does not necessarily return its argument; e.g., for undefined values, it returns 0:</p>
<pre class="pod-block-code">my $x;
say $x++;   # OUTPUT: «0␤»
say $x;     # OUTPUT: «1␤»</pre>
<p>Increment on <a href="/Documentable/integration-test/type/Str">Str</a> will increment the number part of a string and assign the resulting string to the container. A <code>is rw</code>-container is required.</p>
<pre class="pod-block-code">my $filename = &quot;somefile-001.txt&quot;;
say $filename++ for 1..3;
# OUTPUT: «somefile-001.txt␤somefile-002.txt␤somefile-003.txt␤»</pre>
<p>This will act on any Unicode numeral:</p>
<pre class="pod-block-code">my $was٧ = &quot;ثمانية٧&quot;;
$was٧++;
say $was٧; # OUTPUT: «ثمانية٨␤»
</pre>
<p>Including, since version 6.d, Thai numerals</p>
<pre class="pod-block-code">my $เลขไทย=&quot;๙๙&quot;;
$เลขไทย++;
say $เลขไทย; # OUTPUT: «๑๐๐␤»
</pre>
<p><a name="Documentable/integration-test/index-entry-postfix_decrement_operator"></a></p>
<h2 id="postfix_--"><a class="u" href="#___top" title="go to top of document">postfix <a name="Documentable/integration-test/index-entry-postfix_-----"><span class="index-entry"><code>--</code></span></a></a></h2>
<pre class="pod-block-code">multi sub postfix:&lt;--&gt;($x is rw) is assoc&lt;non&gt;</pre>
<p>Decrements its argument by one and returns the original value.</p>
<pre class="pod-block-code">my $x = 3;
say $x--;   # OUTPUT: «3␤»
say $x;     # OUTPUT: «2␤»</pre>
<p>It works by calling the <a href="/Documentable/integration-test/routine/pred">pred</a> method (for <em>predecessor</em>) on its argument, which gives custom types the freedom to implement their own decrement semantics.</p>
<p>Note that this does not necessarily return its argument;e.g., for undefined values, it returns 0:</p>
<pre class="pod-block-code">my $x;
say $x--;   # OUTPUT: «0␤»
say $x;     # OUTPUT: «-1␤»</pre>
<p>Decrement on <a href="/Documentable/integration-test/type/Str">Str</a> will decrement the number part of a string and assign the resulting string to the container. A <code>is rw</code>-container is required. Crossing 0 is prohibited and throws <code>X::AdHoc</code>.</p>
<pre class="pod-block-code">my $filename = &quot;somefile-003.txt&quot;;
say $filename-- for 1..3;
# OUTPUT: «somefile-003.txt␤somefile-002.txt␤somefile-001.txt␤»</pre>
<h1 id="Exponentiation_precedence"><a class="u" href="#___top" title="go to top of document">Exponentiation precedence</a></h1>
<h2 id="infix_**"><a class="u" href="#___top" title="go to top of document">infix <code>**</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;**&gt;(Any, Any --&gt; Numeric:D) is assoc&lt;right&gt;</pre>
<p>The <a name="Documentable/integration-test/index-entry-exponentiation_operator"><span class="index-entry">exponentiation operator</span></a> coerces both arguments to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> and calculates the left-hand-side raised to the power of the right-hand side.</p>
<p>If the right-hand side is a non-negative integer and the left-hand side is an arbitrary precision type (<a href="/Documentable/integration-test/type/Int">Int</a>, <a href="/Documentable/integration-test/type/FatRat">FatRat</a>), then the calculation is carried out without loss of precision.</p>
<p>Unicode superscripts will behave in exactly the same way.</p>
<pre class="pod-block-code">sub squared( Int $num ) { $num² };
say squared($_) for ^5; OUTPUT: «0␤1␤4␤9␤16␤»</pre>
<p>It also works for sequences of several Unicode superscript numbers:</p>
<pre class="pod-block-code">sub twenty-second-power( Int $num ) { $num²² };
say twenty-second-power($_) for ^5; # OUTPUT: «0␤1␤4194304␤31381059609␤17592186044416␤»</pre>
<h1 id="Symbolic_unary_precedence"><a class="u" href="#___top" title="go to top of document">Symbolic unary precedence</a></h1>
<h2 id="prefix_?"><a class="u" href="#___top" title="go to top of document">prefix <code>?</code></a></h2>
<pre class="pod-block-code">multi sub prefix:&lt;?&gt;(Mu --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Boolean_context_operator"><span class="index-entry">Boolean context operator</span></a>.</p>
<p>Coerces the argument to <a href="/Documentable/integration-test/type/Bool">Bool</a> by calling the <code>Bool</code> method on it. Note that this collapses <a href="/Documentable/integration-test/type/Junction">Junction</a>s.</p>
<h2 id="prefix_!"><a class="u" href="#___top" title="go to top of document">prefix <code>!</code></a></h2>
<pre class="pod-block-code">multi sub prefix:&lt;!&gt;(Mu --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Negated_boolean_context_operator"><span class="index-entry">Negated boolean context operator</span></a>.</p>
<p>Coerces the argument to <a href="/Documentable/integration-test/type/Bool">Bool</a> by calling the <code>Bool</code> method on it, and returns the negation of the result. Note that this collapses <a href="/Documentable/integration-test/type/Junction">Junction</a>s.</p>
<h2 id="prefix_+"><a class="u" href="#___top" title="go to top of document">prefix <code>+</code></a></h2>
<pre class="pod-block-code">multi sub prefix:&lt;+&gt;(Any --&gt; Numeric:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Numeric_context_operator"><span class="index-entry">Numeric context operator</span></a>.</p>
<p>Coerces the argument to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> by calling the <code>Numeric</code> method on it.</p>
<h2 id="prefix_-"><a class="u" href="#___top" title="go to top of document">prefix <code>-</code></a></h2>
<pre class="pod-block-code">multi sub prefix:&lt;-&gt;(Any --&gt; Numeric:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Negative_numeric_context_operator"><span class="index-entry">Negative numeric context operator</span></a>.</p>
<p>Coerces the argument to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> by calling the <code>Numeric</code> method on it, and then negates the result.</p>
<h2 id="prefix_~"><a class="u" href="#___top" title="go to top of document">prefix <code>~</code></a></h2>
<pre class="pod-block-code">multi sub prefix:&lt;~&gt;(Any --&gt; Str:D)</pre>
<p><a name="Documentable/integration-test/index-entry-String_context_operator"><span class="index-entry">String context operator</span></a>.</p>
<p>Coerces the argument to <a href="/Documentable/integration-test/type/Str">Str</a> by calling the <a href="/Documentable/integration-test/type/List#method_Str">Str</a> method on it.</p>
<h2 id="prefix_|"><a class="u" href="#___top" title="go to top of document">prefix <code>|</code></a></h2>
<p>Flattens objects of type <a href="/Documentable/integration-test/type/Capture">Capture</a>, <a href="/Documentable/integration-test/type/Pair">Pair</a>, <a href="/Documentable/integration-test/type/List">List</a>, <a href="/Documentable/integration-test/type/Map">Map</a> and <a href="/Documentable/integration-test/type/Hash">Hash</a> into an argument list.</p>
<pre class="pod-block-code">sub slurpee( |args ){
    say args.raku
};
slurpee( &lt;a b c d&gt;, { e =&gt; 3 }, &#39;e&#39; =&gt; &#39;f&#39; =&gt; 33 )
# OUTPUT: «\((&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), {:e(3)}, :e(:f(33)))␤»</pre>
<p>Please see the <a href="/Documentable/integration-test/type/Signature#Capture_parameters"><code>Signature</code> page, specially the section on Captures</a> for more information on the subject.</p>
<p>Outside of argument lists, it returns a <a href="/Documentable/integration-test/type/Slip">Slip</a>, which makes it flatten into the outer list. Inside <a href="/Documentable/integration-test/language/list#Argument_list_(Capture)_context">argument list</a> <a href="/Documentable/integration-test/type/Positional"><code>Positional</code>s</a> are turned into positional arguments and <a href="/Documentable/integration-test/type/Associative"><code>Associative</code>s</a> are turned into named arguments.</p>
<h2 id="prefix_+^"><a class="u" href="#___top" title="go to top of document">prefix <code>+^</code></a></h2>
<pre class="pod-block-code">multi sub prefix:&lt;+^&gt;(Any --&gt; Int:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Integer_bitwise_negation_operator"><span class="index-entry">Integer bitwise negation operator</span></a>: converts the number to binary using as many bytes as needed by the number plus one; flips all bits and returns the result assuming it is a <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two&#39;s complement</a> representation.</p>
<pre class="pod-block-code">say +^255; # OUTPUT: «-256␤»
</pre>
<p>In this case, 255 is 11111111 and would need a single byte. We use the representation in bytes needed for this value plus one, converting it to 0000 0000 1111 1111. Bitwise negation turns it into 1111 1111 0000 0000 and this is the representation in two&#39;s complement of -256, which is returned.</p>
<pre class="pod-block-code">say +^1;        # OUTPUT: «-2␤»
say +^(-256);   # OUTPUT: «255␤»
</pre>
<p>Negative numbers are assumed to be represented as two&#39;s complements, and thus circle back to the original number.</p>
<h2 id="prefix_~^"><a class="u" href="#___top" title="go to top of document">prefix <code>~^</code></a></h2>
<p>Coerces the argument to a non-variable-encoding string buffer type (e.g. <code>buf8</code>, <code>buf16</code>, <code>buf32</code>) and then flips each bit in that buffer.</p>
<p>Please note that this has not yet been implemented.</p>
<h2 id="prefix_?^"><a class="u" href="#___top" title="go to top of document">prefix <code>?^</code></a></h2>
<pre class="pod-block-code">multi sub prefix:&lt;?^&gt;(Mu --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Boolean_bitwise_negation_operator"><span class="index-entry">Boolean bitwise negation operator</span></a>: Coerces the argument to <a href="/Documentable/integration-test/type/Bool">Bool</a> and then does a bit flip, which makes it the same as <code>prefix:&lt;!&gt; </code>.</p>
<h2 id="prefix_^"><a class="u" href="#___top" title="go to top of document">prefix <code>^</code></a></h2>
<pre class="pod-block-code">multi sub prefix:&lt;^&gt;(Any --&gt; Range:D)</pre>
<p><em>upto</em> operator.<a name="Documentable/integration-test/index-entry-upto_operator"></a></p>
<p>Coerces the argument to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and generates a range from 0 up to (but excluding) the argument.</p>
<pre class="pod-block-code">say ^5;         # OUTPUT: «0..^5␤»
for ^5 { }      # 5 iterations</pre>
<h1 id="Dotty_infix_precedence"><a class="u" href="#___top" title="go to top of document">Dotty infix precedence</a></h1>
<p>These operators are like their Method Postfix counterparts, but require surrounding whitespace (before and/or after) to distinguish them.</p>
<h2 id="infix_.="><a class="u" href="#___top" title="go to top of document">infix <code>.=</code></a></h2>
<p>Calls the right-side method on the value in the left-side container, replacing the resulting value in the left-side container.</p>
<p>In most cases, this behaves identically to the postfix mutator, but the precedence is lower:</p>
<pre class="pod-block-code">my $a = -5;
say ++$a.=abs;
# OUTPUT: «6␤»
</pre>
<pre class="pod-block-code">say ++$a .= abs;
# OUTPUT: «Cannot modify an immutable Int␤
#           in block &lt;unit&gt; at &lt;tmp&gt; line 1␤␤»
</pre>
<h2 id="infix_."><a class="u" href="#___top" title="go to top of document">infix <code>.</code></a></h2>
<p>Calls the following method (whose name must be alphabetic) on the left-side invocant.</p>
<p>Note that the infix form of the operator has a slightly lower precedence than postfix <code>.meth</code>.</p>
<pre class="pod-block-code">say -5.abs;      # like: -(5.abs)
# OUTPUT: «-5␤»
say -5 . abs;    # like: (-5) . abs
# OUTPUT: «5␤»
say -5 .abs;     # following whitespace is optional
# OUTPUT: «5␤»</pre>
<h1 id="Multiplicative_precedence"><a class="u" href="#___top" title="go to top of document">Multiplicative precedence</a></h1>
<h2 id="infix_*"><a class="u" href="#___top" title="go to top of document">infix <code>*</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;*&gt;(Any, Any --&gt; Numeric:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Multiplication_operator"><span class="index-entry">Multiplication operator</span></a>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> and multiplies them. The result is of the wider type. See <a href="/Documentable/integration-test/type/Numeric">Numeric</a> for details.</p>
<h2 id="infix_/"><a class="u" href="#___top" title="go to top of document">infix <code>/</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;/&gt;(Any, Any --&gt; Numeric:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Division_operator"><span class="index-entry">Division operator</span></a>.</p>
<p>Coerces both argument to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> and divides the left through the right number. Division of <a href="/Documentable/integration-test/type/Int">Int</a> values returns <a href="/Documentable/integration-test/type/Rat">Rat</a>, otherwise the &quot;wider type&quot; rule described in <a href="/Documentable/integration-test/type/Numeric">Numeric</a> holds.</p>
<h2 id="infix_div"><a class="u" href="#___top" title="go to top of document">infix <code>div</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;div&gt;(Int:D, Int:D --&gt; Int:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Integer_division_operator"><span class="index-entry">Integer division operator</span></a>. Rounds down.</p>
<h2 id="infix_%"><a class="u" href="#___top" title="go to top of document">infix <code>%</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;%&gt;($x, $y --&gt; Numeric:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Modulo_operator"><span class="index-entry">Modulo operator</span></a>. Coerces to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> first.</p>
<p>Generally the following identity holds:</p>
<pre class="pod-block-code">my ($x, $y) = 1,2;
$x % $y == $x - floor($x / $y) * $y</pre>
<h2 id="infix_%%"><a class="u" href="#___top" title="go to top of document">infix <code>%%</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;%%&gt;($a, $b --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Divisibility_operator"><span class="index-entry">Divisibility operator</span></a>. Returns <code>True</code> if <code>$a % $b == 0</code>.</p>
<h2 id="infix_mod"><a class="u" href="#___top" title="go to top of document">infix <code>mod</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;mod&gt;(Int:D $a, Int:D $b --&gt; Int:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Integer_modulo_operator"><span class="index-entry">Integer modulo operator</span></a>. Returns the remainder of an integer modulo operation.</p>
<h2 id="infix_+&"><a class="u" href="#___top" title="go to top of document">infix <code>+&amp;</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;+&amp;&gt;($a, $b --&gt; Int:D)</pre>
<p>Numeric bitwise <em>AND</em> operator. Coerces both arguments to <a href="/Documentable/integration-test/type/Int">Int</a> and does a bitwise <em>AND</em> operation assuming two&#39;s complement.<a name="Documentable/integration-test/index-entry-Numeric_bitwise_AND_operator"></a></p>
<h2 id="infix_+<"><a class="u" href="#___top" title="go to top of document">infix <code>+&lt;</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;&lt; +&lt; &gt;&gt;($a, $b --&gt; Int:D)</pre>
<p>Integer bit shift to the left.<a name="Documentable/integration-test/index-entry-integer_bit_shift_operator_left"></a></p>
<h2 id="infix_+>"><a class="u" href="#___top" title="go to top of document">infix <code>+&gt;</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;&lt; +&gt; &gt;&gt;($a, $b --&gt; Int:D)</pre>
<p>Integer bit shift to the right.<a name="Documentable/integration-test/index-entry-integer_bit_shift_operator_right"></a></p>
<h2 id="infix_~&"><a class="u" href="#___top" title="go to top of document">infix <code>~&amp;</code></a></h2>
<p>Coerces each argument to a non-variable-encoding string buffer type (e.g. <code>buf8</code>, <code>buf16</code>, <code>buf32</code>) and then performs a numeric bitwise AND on corresponding integers of the two buffers, padding the shorter buffer with zeroes.</p>
<h2 id="infix_~<"><a class="u" href="#___top" title="go to top of document">infix <code>~&lt;</code></a></h2>
<p>Coerces the left argument to a non-variable-encoding string buffer type (e.g. <code>buf8</code>, <code>buf16</code>, <code>buf32</code>) and then performs a numeric bitwise left shift on the bits of the buffer.</p>
<p>Please note that this has not yet been implemented.</p>
<h2 id="infix_~>"><a class="u" href="#___top" title="go to top of document">infix <code>~&gt;</code></a></h2>
<p>Coerces the left argument to a non-variable-encoding string buffer type (e.g. <code>buf8</code>, <code>buf16</code>, <code>buf32</code>) and then performs a numeric bitwise right shift on the bits of the buffer.</p>
<p>Please note that this has not yet been implemented.</p>
<h2 id="infix_?&"><a class="u" href="#___top" title="go to top of document">infix <code>?&amp;</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;?&amp;&gt;(Mu $x = Bool::True)
multi sub infix:&lt;?&amp;&gt;(Mu \a, Mu \b)</pre>
<p><a name="Documentable/integration-test/index-entry-Boolean_logical_AND_operator"><span class="index-entry">Boolean logical AND operator</span></a>. Coerces the argument(s) to <a href="/Documentable/integration-test/type/Bool">Bool</a> and performs logical AND on it(them): it will return True if and only if both arguments are True. On a single argument it behaves as identity, returning the coerced value.</p>
<h2 id="infix_gcd"><a class="u" href="#___top" title="go to top of document">infix <code>gcd</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;gcd&gt;($a, $b --&gt; Int:D)</pre>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Int">Int</a> and returns the greatest common divisor.<a name="Documentable/integration-test/index-entry-greatest_common_divisor_operator"></a> If one of its arguments is 0, the other is returned (when both arguments are 0, the operator returns 0).</p>
<h2 id="infix_lcm"><a class="u" href="#___top" title="go to top of document">infix <code>lcm</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;lcm&gt;($a, $b --&gt; Int:D)</pre>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Int">Int</a> and returns the least common multiple; that is, the smallest integer that is evenly divisible by both arguments.<a name="Documentable/integration-test/index-entry-least_common_multiple_operator"></a></p>
<h1 id="Additive_precedence"><a class="u" href="#___top" title="go to top of document">Additive precedence</a></h1>
<h2 id="infix_+"><a class="u" href="#___top" title="go to top of document">infix <code>+</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;+&gt;($a, $b --&gt; Numeric:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Addition_operator"><span class="index-entry">Addition operator</span></a>: Coerces both arguments to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> and adds them. From version 6.d it works also on <a href="/Documentable/integration-test/type/Duration"><code>Duration</code></a>, <a href="/Documentable/integration-test/type/DateTime"><code>DateTime</code></a> and <a href="/Documentable/integration-test/type/Real"><code>Real</code></a> types.</p>
<h2 id="infix_-"><a class="u" href="#___top" title="go to top of document">infix <code>-</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;-&gt;($a, $b --&gt; Numeric:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Subtraction_operator"><span class="index-entry">Subtraction operator</span></a>: Coerces both arguments to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> and subtracts the second from the first. From version 6.d it works also on <a href="/Documentable/integration-test/type/Duration"><code>Duration</code></a>, <a href="/Documentable/integration-test/type/DateTime"><code>DateTime</code></a> and <a href="/Documentable/integration-test/type/Real"><code>Real</code></a> types.</p>
<h2 id="infix_+|"><a class="u" href="#___top" title="go to top of document">infix <code>+|</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;+|&gt;($a, $b --&gt; Int:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Integer_bitwise_OR_operator"><span class="index-entry">Integer bitwise OR operator</span></a>: Coerces both arguments to <a href="/Documentable/integration-test/type/Int">Int</a> and does a bitwise <em>OR</em> (inclusive OR) operation.</p>
<h2 id="infix_+^"><a class="u" href="#___top" title="go to top of document">infix <code>+^</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;+^&gt;($a, $b --&gt; Int:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Integer_bitwise_XOR_operator"><span class="index-entry">Integer bitwise XOR operator</span></a>: Coerces both arguments to <a href="/Documentable/integration-test/type/Int">Int</a> and does a bitwise <em>XOR</em> (exclusive OR) operation.</p>
<pre class="pod-block-code">say (0b00001101 +^ 0b00001001).base(2); # OUTPUT: «100␤»
</pre>
<h2 id="infix_~|"><a class="u" href="#___top" title="go to top of document">infix <code>~|</code></a></h2>
<p>Coerces each argument to a non-variable-encoding string buffer type (e.g. <code>buf8</code>, <code>buf16</code>, <code>buf32</code>) and then performs a numeric bitwise OR on corresponding integers of the two buffers, padding the shorter buffer with zeroes.</p>
<h2 id="infix_~^"><a class="u" href="#___top" title="go to top of document">infix <code>~^</code></a></h2>
<p>Coerces each argument to a non-variable-encoding string buffer type (e.g. <code>buf8</code>, <code>buf16</code>, <code>buf32</code>) and then performs a numeric bitwise XOR on corresponding integers of the two buffers, padding the shorter buffer with zeroes.</p>
<h2 id="infix_?^"><a class="u" href="#___top" title="go to top of document">infix <code>?^</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;?^&gt;(Mu $x = Bool::False)
multi sub infix:&lt;?^&gt;(Mu \a, Mu \b)</pre>
<p><a name="Documentable/integration-test/index-entry-Boolean_logical_XOR_operator"><span class="index-entry">Boolean logical XOR operator</span></a>. Coerces the argument(s) to <a href="/Documentable/integration-test/type/Bool">Bool</a> and performs logical XOR on it(them): it will return True if and only if just one of the argument is True. On a single argument it behaves as identity, returning the coerced value.</p>
<h2 id="infix_?|"><a class="u" href="#___top" title="go to top of document">infix <code>?|</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;?|&gt;(Mu $x = Bool::False)
multi sub infix:&lt;?|&gt;(Mu \a, Mu \b)</pre>
<p><a name="Documentable/integration-test/index-entry-Boolean_logical_OR_operator"><span class="index-entry">Boolean logical OR operator</span></a>. Coerces the argument(s) to <a href="/Documentable/integration-test/type/Bool">Bool</a> and performs logical OR (inclusive OR) on it(them): it will return True if at least one of the argument is True. On a single argument it behaves as identity, returning the coerced value.</p>
<h1 id="Replication_precedence"><a class="u" href="#___top" title="go to top of document">Replication precedence</a></h1>
<h2 id="infix_x"><a class="u" href="#___top" title="go to top of document">infix <code>x</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;x&gt;($a, $b --&gt; Str:D)</pre>
<p><a name="Documentable/integration-test/index-entry-String_repetition_operator"><span class="index-entry">String repetition operator</span></a>.</p>
<p>Repeats the string <code>$a</code> <code>$b</code> times, if necessary coercing <code>$a</code> to <a href="/Documentable/integration-test/type/Str"><code>Str</code></a> and <code>$b</code> to <a href="/Documentable/integration-test/type/Int"><code>Int</code></a>. Returns an empty string if <code>$b &lt;= 0 </code>. An exception <code>X::Numeric::CannotConvert</code> will be thrown if <code>$b</code> is <code>-Inf</code> or <code>NaN</code>.</p>
<pre class="pod-block-code">say &#39;ab&#39; x 3;           # OUTPUT: «ababab␤»
say 42 x 3;             # OUTPUT: «424242␤»

my $a = &#39;a&#39;.IO;
my $b = 3.5;
say $a x $b;            # OUTPUT: «aaa␤»</pre>
<h2 id="infix_xx"><a class="u" href="#___top" title="go to top of document">infix <code>xx</code></a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub infix:&lt;xx&gt;()
multi sub infix:&lt;xx&gt;(Mu \x)
multi sub infix:&lt;xx&gt;(&amp;x, Num:D() $n)
multi sub infix:&lt;xx&gt;(&amp;x, Whatever)
multi sub infix:&lt;xx&gt;(&amp;x, Bool:D $b)
multi sub infix:&lt;xx&gt;(&amp;x, Int:D $n)
multi sub infix:&lt;xx&gt;(Mu \x, Num:D() $n)
multi sub infix:&lt;xx&gt;(Mu \x, Whatever)
multi sub infix:&lt;xx&gt;(Mu \x, Bool:D $b)
multi sub infix:&lt;xx&gt;(Mu \x, Int:D $n)</pre>
<p><a name="Documentable/integration-test/index-entry-List_repetition_operator"><span class="index-entry">List repetition operator</span></a></p>
<p>In general, it returns a Sequence of <code>$a</code> repeated and evaluated <code>$b</code> times (<code>$b</code> is coerced to <a href="/Documentable/integration-test/type/Int">Int</a>). If <code>$b &lt;= 0 </code>, the empty list is returned. It will return an error with no operand, and return the operand itself with a single operand. An exception <code>X::Numeric::CannotConvert</code> will be thrown if <code>$b</code> is <code>-Inf</code> or <code>NaN</code>.</p>
<p>The left-hand side is evaluated for each repetition, so</p>
<pre class="pod-block-code">say [1, 2] xx 5;
# OUTPUT: «([1 2] [1 2] [1 2] [1 2] [1 2])␤»</pre>
<p>returns five distinct arrays (but with the same content each time), and</p>
<pre class="pod-block-code">rand xx 3</pre>
<p>returns three pseudo random numbers that are determined independently.</p>
<p>The right-hand side can be <code>*</code>, in which case a lazy, infinite list is returned. If it&#39;s a <code>Bool</code>, a <code>Seq</code> with a single element is returned if it&#39;s <code>True</code>.</p>
<h1 id="Concatenation"><a class="u" href="#___top" title="go to top of document">Concatenation</a></h1>
<p>Same as the rest of the infix operators, these can be combined with metaoperators such as <a href="/Documentable/integration-test/language/operators#Assignment_operators">assignment</a>, for instance.</p>
<h2 id="infix_~"><a class="u" href="#___top" title="go to top of document">infix <code>~</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;~&gt;(Any,   Any)
multi sub infix:&lt;~&gt;(Str:D, Str:D)
multi sub infix:&lt;~&gt;(Buf:D, Buf:D)
multi sub infix:&lt;~&gt;(Blob:D $a, Blob:D $b)
multi sub infix:&lt;~&gt;(Junction:D \a, Junction:D \b)</pre>
<p>This is the <a name="Documentable/integration-test/index-entry-string_concatenation_operator"><span class="index-entry">string concatenation operator</span></a>, which coerces both arguments to <a href="/Documentable/integration-test/type/Str">Str</a> and concatenates them. If both arguments are <a href="/Documentable/integration-test/type/Buf">Buf</a>, a combined buffer is returned.</p>
<pre class="pod-block-code">say &#39;ab&#39; ~ &#39;c&#39;;     # OUTPUT: «abc␤»
my $bob = Blob.new([1,2,3]);
my $bao = Blob.new([3,4,5]);
say $bao ~ $bob;     # OUTPUT: «Blob:0x&lt;03 04 05 01 02 03&gt;␤»
</pre>
<p>The arity-1 version of this operator will be called when the hyper version of the operator is used on an array or list with a single element, or simply an element</p>
<pre class="pod-block-code">say [~] Blob.new([3,4,5]);     # OUTPUT: «Blob:0x&lt;03 04 05&gt;␤»
say [~] 1|2;                   # OUTPUT: «any(1, 2)␤»
</pre>
<h2 id="infix_∘"><a class="u" href="#___top" title="go to top of document">infix <code>∘</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;∘&gt;()
multi sub infix:&lt;∘&gt;(&amp;f)
multi sub infix:&lt;∘&gt;(&amp;f, &amp;g --&gt; Block:D)</pre>
<p><a name="Documentable/integration-test/index-entry-o__operators"></a> The <a name="Documentable/integration-test/index-entry-function_composition_operator"><span class="index-entry">function composition operator</span></a> <code>infix:&lt;∘&gt;</code> or <code>infix:&lt;o&gt;</code> combines two functions, so that the left function is called with the return value of the right function. If the <a href="/Documentable/integration-test/routine/count"><code>.count</code></a> of the left function is greater than 1, the return value of the right function will be <a href="/Documentable/integration-test/type/Slip">slipped</a> into the left function.</p>
<p>Both <code>.count</code> and <code>.arity</code> of the right-hand side will be maintained, as well as the <code>.of</code> of the left hand side.</p>
<pre class="pod-block-code">    sub f($p){ say &#39;f&#39;; $p / 2 }
    sub g($p){ say &#39;g&#39;; $p * 2 }

    my &amp;composed = &amp;f ∘ &amp;g;
    say composed 2; # OUTPUT: «g␤f␤2␤»
    # equivalent to:
    say 2.&amp;g.&amp;f;
    # or to:
    say f g 2;
    say &amp;composed.arity; #  OUTPUT: «1␤»
    say &amp;composed.count; #  OUTPUT: «1␤»
    say &amp;composed.of;    #  OUTPUT: «(Mu)␤»
</pre>
<pre class="pod-block-code">    sub f($a, $b, $c) { [~] $c, $b, $a }
    sub g($str){ $str.comb }
    my &amp;composed = &amp;f ∘ &amp;g;
    say composed &#39;abc&#39;; # OUTPUT: «cba␤»
    # equivalent to:
    say f |g &#39;abc&#39;;
</pre>
<p>The single-arg candidate returns the given argument as is. The zero-arg candidate returns an identity routine that simply returns its argument.</p>
<pre class="pod-block-code">my &amp;composed = [∘] &amp;uc;
say composed &#39;foo&#39;; # OUTPUT: «FOO␤»

my &amp;composed = [∘];
say composed &#39;foo&#39;; # OUTPUT: «foo␤»</pre>
<h1 id="Junctive_AND_(all)_precedence"><a class="u" href="#___top" title="go to top of document">Junctive AND (all) precedence</a></h1>
<h2 id="infix_&"><a class="u" href="#___top" title="go to top of document">infix <code>&amp;</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;&amp;&gt;($a, $b --&gt; Junction:D) is assoc&lt;list&gt;</pre>
<p><a name="Documentable/integration-test/index-entry-All_junction_operator"><span class="index-entry">All junction operator</span></a>.</p>
<p>Creates an <em>all</em> <a href="/Documentable/integration-test/type/Junction">Junction</a> from its arguments. See <a href="/Documentable/integration-test/type/Junction">Junction</a> for more details.</p>
<h2 id="infix_(&),_infix_∩"><a class="u" href="#___top" title="go to top of document">infix <code>(&amp;)</code>, infix <code>∩</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;(&amp;)&gt;(**@p)
multi sub infix:&lt;∩&gt;(**@p)</pre>
<p><a name="Documentable/integration-test/index-entry-Intersection_operator"><span class="index-entry">Intersection operator</span></a>.</p>
<p>Returns the <strong>intersection</strong> of all of its arguments. This creates a new <a href="/Documentable/integration-test/type/Set">Set</a> that contains only the elements common to all of the arguments if none of the arguments are a <a href="/Documentable/integration-test/type/Bag">Bag</a>, <a href="/Documentable/integration-test/type/BagHash">BagHash</a>, <a href="/Documentable/integration-test/type/Mix">Mix</a> or <a href="/Documentable/integration-test/type/MixHash">MixHash</a>.</p>
<pre class="pod-block-code">say &lt;a b c&gt; (&amp;) &lt;b c d&gt;; # OUTPUT: «set(b c)␤»
&lt;a b c d&gt; ∩ &lt;b c d e&gt; ∩ &lt;c d e f&gt;; # OUTPUT: «set(c d)␤»
</pre>
<p>If any of the arguments are <a href="/Documentable/integration-test/type/Baggy">Baggy</a> or <a href="/Documentable/integration-test/type/Mixy">Mixy</a>, the result is a new <code>Bag</code> (or <code>Mix</code>) containing the common elements, each weighted by the largest <em>common</em> weight (which is the minimum of the weights of that element over all arguments).</p>
<pre class="pod-block-code">say &lt;a a b c a&gt; (&amp;) bag(&lt;a a b c c&gt;); # OUTPUT: «Bag(a(2), b, c)␤»
</pre>
<p><code>∩</code> is equivalent to <code>(&amp;)</code>, at codepoint U+2229 (INTERSECTION).</p>
<h2 id="infix_(.),_infix_⊍"><a class="u" href="#___top" title="go to top of document">infix <code>(.)</code>, infix <code>⊍</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;(.)&gt;(**@p)
multi sub infix:&lt;⊍&gt;(**@p)</pre>
<p><a name="Documentable/integration-test/index-entry-Baggy_multiplication_operator"><span class="index-entry">Baggy multiplication operator</span></a>.</p>
<p>Returns the Baggy <strong>multiplication</strong> of its arguments, i.e., a <a href="/Documentable/integration-test/type/Bag">Bag</a> that contains each element of the arguments with the weights of the element across the arguments multiplied together to get the new weight. Returns a <a href="/Documentable/integration-test/type/Mix">Mix</a> if any of the arguments is a <a href="/Documentable/integration-test/type/Mixy">Mixy</a>.</p>
<pre class="pod-block-code">say &lt;a b c&gt; (.) &lt;a b c d&gt;; # OUTPUT: «Bag(a, b, c)␤»
                           # Since 1 * 0 == 0, in the case of &#39;d&#39;
say &lt;a a b c a d&gt; ⊍ bag(&lt;a a b c c&gt;); # OUTPUT: «Bag(a(6), b, c(2))␤»
</pre>
<p><code>⊍</code> is equivalent to <code>(.)</code>, at codepoint U+228D (MULTISET MULTIPLICATION).</p>
<h1 id="Junctive_OR_(any)_precedence"><a class="u" href="#___top" title="go to top of document">Junctive OR (any) precedence</a></h1>
<h2 id="infix_|"><a class="u" href="#___top" title="go to top of document">infix <code>|</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;|&gt;($a, $b --&gt; Junction:D) is assoc&lt;list&gt;</pre>
<p><a name="Documentable/integration-test/index-entry-Any_junction_operator"></a> Creates an <em>any</em> <a href="/Documentable/integration-test/type/Junction">Junction</a> from its arguments.</p>
<pre class="pod-block-code">my $three-letters = /&lt;[a b c]&gt;/ | /&lt;[i j k]&gt;/ | /&lt;[x y z]&gt;/;
say $three-letters.raku; # OUTPUT: «any(/&lt;[a b c]&gt;/, /&lt;[i j k]&gt;/, /&lt;[x y z]&gt;/)␤»
say &#39;b&#39; ~~ $three-letters; # OUTPUT: «True␤»</pre>
<p>This first creates an <code>any</code> <code>Junction</code> of three regular expressions (every one of them matching any of 3 letters), and then uses smartmatching to check whether the letter <code>b</code> matches any of them, resulting in a positive match. See also <a href="/Documentable/integration-test/type/Junction">Junction</a> for more details.</p>
<h2 id="infix_(|),_infix_∪"><a class="u" href="#___top" title="go to top of document">infix <code>(|)</code>, infix <code>∪</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;(|)&gt;(**@p)
multi sub infix:&lt;∪&gt;(**@p)</pre>
<p><a name="Documentable/integration-test/index-entry-Union_operator"><span class="index-entry">Union operator</span></a>.</p>
<p>Returns the <strong>union</strong> of all of its arguments. This creates a new <a href="/Documentable/integration-test/type/Set">Set</a> that contains all the elements its arguments contain if none of the arguments are a <a href="/Documentable/integration-test/type/Bag">Bag</a>, <a href="/Documentable/integration-test/type/BagHash">BagHash</a>, <a href="/Documentable/integration-test/type/Mix">Mix</a> or <a href="/Documentable/integration-test/type/MixHash">MixHash</a>.</p>
<pre class="pod-block-code">say &lt;a b d&gt; ∪ bag(&lt;a a b c&gt;); # OUTPUT: «Bag(a(2), b, c, d)␤»
</pre>
<p>If any of the arguments are <a href="/Documentable/integration-test/type/Baggy">Baggy</a> or <a href="/Documentable/integration-test/type/Mixy">Mixy</a>, the result is a new <code>Bag</code> (or <code>Mix</code>) containing all the elements, each weighted by the <em>highest</em> weight that appeared for that element.</p>
<pre class="pod-block-code">say &lt;a b d&gt; ∪ bag(&lt;a a b c&gt;); # OUTPUT: «Bag(a(2), b, c, d)␤»
</pre>
<p><code>∪</code> is equivalent to <code>(|)</code>, at codepoint U+222A (UNION).</p>
<h2 id="infix_(+),_infix_⊎"><a class="u" href="#___top" title="go to top of document">infix <code>(+)</code>, infix <code>⊎</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;(+)&gt;(**@p)
multi sub infix:&lt;⊎&gt;(**@p)</pre>
<p><a name="Documentable/integration-test/index-entry-Baggy_addition_operator"><span class="index-entry">Baggy addition operator</span></a>.</p>
<p>Returns the Baggy <strong>addition</strong> of its arguments. This creates a new <a href="/Documentable/integration-test/type/Bag">Bag</a> from each element of the arguments with the weights of the element added together to get the new weight, if none of the arguments are a <a href="/Documentable/integration-test/type/Mix">Mix</a> or <a href="/Documentable/integration-test/type/MixHash">MixHash</a>.</p>
<pre class="pod-block-code">say &lt;a a b c a d&gt; (+) &lt;a a b c c&gt;; # OUTPUT: «Bag(a(5), b(2), c(3), d)␤»
</pre>
<p>If any of the arguments is a <a href="/Documentable/integration-test/type/Mixy">Mixy</a>, the result is a new <code>Mix</code>.</p>
<pre class="pod-block-code">say &lt;a b c&gt; (+) (a =&gt; 2.5, b =&gt; 3.14).Mix; # OUTPUT: «Mix(a(3.5), b(4.14), c)␤»
</pre>
<p><code>⊎</code> is equivalent to <code>(+)</code>, at codepoint U+228E (MULTISET UNION).</p>
<h2 id="infix_(-),_infix_∖"><a class="u" href="#___top" title="go to top of document">infix <code>(-)</code>, infix <code>∖</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;(-)&gt;(**@p)
multi sub infix:&lt;∖&gt;(**@p)</pre>
<p><a name="Documentable/integration-test/index-entry-Set_difference_operator"><span class="index-entry">Set difference operator</span></a>.</p>
<p>Returns the <strong>set difference</strong> of all its arguments. This creates a new <a href="/Documentable/integration-test/type/Set">Set</a> that contains all the elements the first argument has but the rest of the arguments don&#39;t, i.e., of all the elements of the first argument, minus the elements from the other arguments. But only if none of the arguments are a <a href="/Documentable/integration-test/type/Bag">Bag</a>, <a href="/Documentable/integration-test/type/BagHash">BagHash</a>, <a href="/Documentable/integration-test/type/Mix">Mix</a> or <a href="/Documentable/integration-test/type/MixHash">MixHash</a>.</p>
<pre class="pod-block-code">say &lt;a a b c a d&gt; (-) &lt;a a b c c&gt;; # OUTPUT: «set(d)␤»
say &lt;a b c d e&gt; (-) &lt;a b c&gt; (-) &lt;a b d&gt;; # OUTPUT: «set(e)␤»
</pre>
<p>If any of the arguments are <a href="/Documentable/integration-test/type/Baggy">Baggy</a> or <a href="/Documentable/integration-test/type/Mixy">Mixy</a>, the result is a new <code>Bag</code> (or <code>Mix</code>) containing all the elements remaining after the first argument with its weight subtracted by the weight of that element in each of the other arguments.</p>
<pre class="pod-block-code">say &lt;a a b c a d&gt; (-) bag(&lt;a b c c&gt;); # OUTPUT: «Bag(a(2), d)␤»
say &lt;a a b c a d&gt;  ∖  mix(&lt;a b c c&gt;); # OUTPUT: «Mix(a(2), c(-1), d)␤»
</pre>
<p><code>∖</code> is equivalent to <code>(-)</code>, at codepoint U+2216 (SET MINUS).</p>
<h2 id="infix_^"><a class="u" href="#___top" title="go to top of document">infix <code>^</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;^&gt;($a, $b --&gt; Junction:D) is assoc&lt;list&gt;</pre>
<p><a name="Documentable/integration-test/index-entry-One_junction_operator"><span class="index-entry">One junction operator</span></a>.</p>
<p>Creates a <em>one</em> <a href="/Documentable/integration-test/type/Junction">Junction</a> from its arguments. See <a href="/Documentable/integration-test/type/Junction">Junction</a> for more details.</p>
<h2 id="infix_(^),_infix_⊖"><a class="u" href="#___top" title="go to top of document">infix <code>(^)</code>, infix <code>⊖</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;(^)&gt;($a, $b)
multi sub infix:&lt;⊖&gt;($a,$b)

multi sub infix:&lt;(^)&gt;(**@p)
multi sub infix:&lt;⊖&gt;(**@p)</pre>
<p><a name="Documentable/integration-test/index-entry-Symmetric_set_difference_operator"><span class="index-entry">Symmetric set difference operator</span></a>.</p>
<p>Returns the <strong>symmetric set difference</strong> of all its arguments. This creates a new <a href="/Documentable/integration-test/type/Set">Set</a> made up of all the elements that <code>$a</code> has but <code>$b</code> doesn&#39;t and all the elements <code>$b</code> has but <code>$a</code> doesn&#39;t if none of the arguments are a <a href="/Documentable/integration-test/type/Bag">Bag</a>, <a href="/Documentable/integration-test/type/BagHash">BagHash</a>, <a href="/Documentable/integration-test/type/Mix">Mix</a> or <a href="/Documentable/integration-test/type/MixHash">MixHash</a>. Equivalent to <code>($a ∖ $b) ∪ ($b ∖ $a)</code>.</p>
<pre class="pod-block-code">say &lt;a b&gt; (^) &lt;b c&gt;; # OUTPUT: «set(a c)␤»
</pre>
<p>If any of the arguments are <a href="/Documentable/integration-test/type/Baggy">Baggy</a> or <a href="/Documentable/integration-test/type/Mixy">Mixy</a>, the result is a new <code>Bag</code> (or <code>Mix</code>).</p>
<pre class="pod-block-code">say &lt;a b&gt; ⊖ bag(&lt;b c&gt;); # OUTPUT: «Bag(a, c)␤»
</pre>
<p><code>⊖</code> is equivalent to <code>(^)</code>, at codepoint U+2296 (CIRCLED MINUS).</p>
<h1 id="Named_unary_precedence"><a class="u" href="#___top" title="go to top of document">Named unary precedence</a></h1>
<h2 id="prefix_temp"><a class="u" href="#___top" title="go to top of document">prefix <code>temp</code></a></h2>
<pre class="pod-block-code">sub prefix:&lt;temp&gt;(Mu $a is rw)</pre>
<p>&quot;temporizes&quot; the variable passed as the argument. The variable begins with the same value as it had in the outer scope, but can be assigned new values in this scope. Upon exiting the scope, the variable will be restored to its original value.</p>
<pre class="pod-block-code">my $a = &quot;three&quot;;
say $a; # OUTPUT: «three␤»
{
    temp $a;
    say $a; # OUTPUT: «three␤»
    $a = &quot;four&quot;;
    say $a; # OUTPUT: «four␤»
}
say $a; # OUTPUT: «three␤»</pre>
<p>You can also assign immediately as part of the call to temp:</p>
<pre class="pod-block-code">temp $a = &quot;five&quot;;
</pre>
<p>Be warned the <code>temp</code> effects get removed once the block is left. If you were to access the value from, say, within a <a href="/Documentable/integration-test/type/Promise">Promise</a> after the <code>temp</code> was undone, you&#39;d get the original value, not the <code>temp</code> one:</p>
<pre class="pod-block-code">my $v = &quot;original&quot;;
{
    temp $v = &quot;new one&quot;;
    start {
        say &quot;[PROMISE] Value before block is left: `$v`&quot;;
        sleep 1;
        say &quot;[PROMISE] Block was left while we slept; value is now `$v`&quot;;
    }
    sleep ½;
    say &quot;About to leave the block; value is `$v`&quot;;
}
say &quot;Left the block; value is now `$v`&quot;;
sleep 2;

# OUTPUT:
# [PROMISE] Value before block is left: `new one`
# About to leave the block; value is `new one`
# Left the block; value is now `original`
# [PROMISE] Block was left while we slept; value is now `original`
</pre>
<h2 id="prefix_let"><a class="u" href="#___top" title="go to top of document">prefix <code>let</code></a></h2>
<pre class="pod-block-code">sub prefix:&lt;let&gt;(Mu $a is rw)</pre>
<p>Refers to a variable in an outer scope whose value will be restored if the block exits unsuccessfully, implying that the block returned a defined object.</p>
<pre class="pod-block-code">my $name = &quot;Jane Doe&quot;;

{
    let $name = prompt(&quot;Say your name &quot;);
    die if !$name;
    CATCH {
        default { say &quot;No name entered&quot; }
    }
    say &quot;We have $name&quot;;
}

say &quot;We got $name&quot;;
</pre>
<p>This code provides a default name for <code>$name</code>. If the user exits from the prompt or simply does not provide a valid input for <code>$name</code>; <code>let</code> will restore the default value provided at the top. If user input is valid, it will keep that.</p>
<h1 id="Nonchaining_binary_precedence"><a class="u" href="#___top" title="go to top of document">Nonchaining binary precedence</a></h1>
<h2 id="infix_does"><a class="u" href="#___top" title="go to top of document">infix <code>does</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;does&gt;(Mu $obj, Mu $role) is assoc&lt;non&gt;</pre>
<p>Mixes <code>$role</code> into <code>$obj</code> at runtime. Requires <code>$obj</code> to be mutable.</p>
<p>Similar to <a href="/Documentable/integration-test/routine/but">but</a> operator, the <code>$role</code> can instead be an instantiated object, in which case, the operator will create a role for you automatically. The role will contain a single method named the same as <code>$obj.^name</code> and that returns <code>$obj</code>:</p>
<pre class="pod-block-code">my $o = class { method Str { &quot;original&quot; } }.new;
put $o;            # OUTPUT: «original␤»
$o does &quot;modded&quot;;
put $o;            # OUTPUT: «modded␤»</pre>
<p>If methods of the same name are present already, the last mixed in role takes precedence.</p>
<h2 id="infix_but"><a class="u" href="#___top" title="go to top of document">infix <code>but</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;but&gt;(Mu $obj1, Mu   $role) is assoc&lt;non&gt;
multi sub infix:&lt;but&gt;(Mu $obj1, Mu:D $obj2) is assoc&lt;non&gt;</pre>
<p>Creates a copy of <code>$obj</code> with <code>$role</code> mixed in. Since <code>$obj</code> is not modified, <code>but</code> can be used to created immutable values with mixins.</p>
<p>Instead of a role, you can provide an instantiated object. In this case, the operator will create a role for you automatically. The role will contain a single method named the same as <code>$obj.^name</code> and that returns <code>$obj</code>:</p>
<pre class="pod-block-code">my $forty-two = 42 but &#39;forty two&#39;;
say $forty-two+33;    # OUTPUT: «75␤»
say $forty-two.^name; # OUTPUT: «Int+{&lt;anon|1&gt;}␤»
say $forty-two.Str;   # OUTPUT: «forty two␤»
</pre>
<p>Calling <code>^name</code> shows that the variable is an <code>Int</code> with an anonymous object mixed in. However, that object is of type <code>Str</code>, so the variable, through the mixin, is endowed with a method with that name, which is what we use in the last sentence.</p>
<p>We can also mixin classes, even created on the fly.</p>
<pre class="pod-block-code">my $s = 12 but class Warbles { method hi { &#39;hello&#39; } }.new;
say $s.Warbles.hi;    # OUTPUT: «hello␤»
say $s + 42;          # OUTPUT: «54␤»
</pre>
<p>To access the mixed-in class, as above, we use the class name as is shown in the second sentence. If methods of the same name are present already, the last mixed in role takes precedence. A list of methods can be provided in parentheses separated by comma. In this case conflicts will be reported at runtime.</p>
<h2 id="infix_cmp"><a class="u" href="#___top" title="go to top of document">infix <code>cmp</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;cmp&gt;(Any,       Any)
multi sub infix:&lt;cmp&gt;(Real:D,    Real:D)
multi sub infix:&lt;cmp&gt;(Str:D,     Str:D)
multi sub infix:&lt;cmp&gt;(Version:D, Version:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Generic,_"smart"_three-way_comparator"><span class="index-entry">Generic, &quot;smart&quot; three-way comparator</span></a>.</p>
<p>Compares strings with string semantics, numbers with number semantics, <a href="/Documentable/integration-test/type/Pair">Pair</a> objects first by key and then by value etc.</p>
<p>if <code>$a eqv $b</code>, then <code>$a cmp $b</code> always returns <code>Order::Same</code>.</p>
<pre class="pod-block-code">say (a =&gt; 3) cmp (a =&gt; 4);   # OUTPUT: «Less␤»
say 4        cmp 4.0;        # OUTPUT: «Same␤»
say &#39;b&#39;      cmp &#39;a&#39;;        # OUTPUT: «More␤»</pre>
<p>Strings are compared codepoint by codepoint; if leading codepoints are the same, the result of comparing the first differing codepoint is returned or the longer string if their lengths differ.</p>
<pre class="pod-block-code">&quot;abcd&quot; cmp &quot;abcde&quot;;    # OUTPUT: «Less␤»
&quot;abcd &quot; cmp &quot;abcde&quot;;   # OUTPUT: «Less␤»
&#39;A&#39; cmp &#39;Ẳ&#39;;           # OUTPUT: «Less␤»</pre>
<h2 id="infix_coll"><a class="u" href="#___top" title="go to top of document">infix <code>coll</code></a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub infix:&lt;coll&gt;(Str:D \a, Str:D \b --&gt; Order:D)
multi sub infix:&lt;coll&gt;(Cool:D \a, Cool:D \b --&gt; Order:D)
multi sub infix:&lt;coll&gt;(Pair:D \a, Pair:D \b --&gt; Order:D)</pre>
<p><code>coll</code> is a sorting operator that takes pairs of <code>Str</code>s, <code>Cool</code>s or <code>Pair</code>s and returns an <code>Order</code> that uses the <code>$*COLLATION</code> order. The default behavior disregards diacritic marks and capitalization, for instance.</p>
<pre class="pod-block-code">say &quot;b&quot; cmp &quot;à&quot;;  # OUTPUT: «Less␤»
say &quot;b&quot; coll &quot;à&quot;; # OUTPUT: «More␤»</pre>
<p>In the first case, lexicographic or codepoint order is taken into account. In the second, which uses <code>coll</code>, the diacritic is not considered and sorting happens according to intuitive order.</p>
<p><strong>NOTE:</strong> These are not yet implemented in the JVM.</p>
<h2 id="infix_unicmp"><a class="u" href="#___top" title="go to top of document">infix <code>unicmp</code></a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub infix:&lt;unicmp&gt;(Str:D \a, Str:D \b --&gt; Order:D)
multi sub infix:&lt;unicmp&gt;(Pair:D \a, Pair:D \b --&gt; Order:D)
multi sub infix:&lt;coll&gt;(Pair:D \a, Pair:D \b --&gt; Order:D)</pre>
<p>Unlike the cmp operator which sorts according to codepoint, <code>unicmp</code> and <code>coll</code> sort according to how most users would expect, that is, disregarding aspects of the particular character like capitalization.</p>
<pre class="pod-block-code">say &#39;a&#39; unicmp &#39;Z&#39;; # Less
say &#39;a&#39; coll &#39;Z&#39;;   # Less
say &#39;a&#39; cmp &#39;Z&#39;;    # More</pre>
<p>The main difference between <code>coll</code> and <code>unicmp</code> is that the behavior of the former can be changed by the <a href="/Documentable/integration-test/type/Any#index-entry-%24*COLLATION-%24*COLLATION"><code>$*COLLATION</code></a> dynamic variable.</p>
<p><strong>NOTE:</strong> These are not yet implemented in the JVM.</p>
<h2 id="infix_leg"><a class="u" href="#___top" title="go to top of document">infix <code>leg</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;leg&gt;(Any,   Any)
multi sub infix:&lt;leg&gt;(Str:D, Str:D)</pre>
<p><a name="Documentable/integration-test/index-entry-String_three-way_comparator"><span class="index-entry">String three-way comparator</span></a>. Short for <em>less, equal or greater?</em>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Str">Str</a> and then does a lexicographic comparison.</p>
<pre class="pod-block-code">say &#39;a&#39; leg &#39;b&#39;;       # OUTPUT: «Less␤»
say &#39;a&#39; leg &#39;a&#39;;       # OUTPUT: «Same␤»
say &#39;b&#39; leg &#39;a&#39;;       # OUTPUT: «More␤»</pre>
<h2 id="infix_<=>"><a class="u" href="#___top" title="go to top of document">infix <code>&lt;=&gt;</code></a></h2>
<pre class="pod-block-code">multi sub infix:«&lt;=&gt;»($a, $b --&gt; Order:D) is assoc&lt;non&gt;</pre>
<p><a name="Documentable/integration-test/index-entry-Numeric_three-way_comparator"><span class="index-entry">Numeric three-way comparator</span></a>.<a name="Documentable/integration-test/index-entry-spaceship_operator"></a></p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Real">Real</a> and then does a numeric comparison.</p>
<h2 id="infix_.."><a class="u" href="#___top" title="go to top of document">infix <code>..</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;..&gt;($a, $b --&gt; Range:D) is assoc&lt;non&gt;</pre>
<p><a name="Documentable/integration-test/index-entry-Range_operator"><span class="index-entry">Range operator</span></a></p>
<p>Constructs a <a href="/Documentable/integration-test/type/Range">Range</a> from the arguments.</p>
<h2 id="infix_..^"><a class="u" href="#___top" title="go to top of document">infix <code>..^</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;..^&gt;($a, $b --&gt; Range:D) is assoc&lt;non&gt;</pre>
<p><a name="Documentable/integration-test/index-entry-Right-open_range_operator"><span class="index-entry">Right-open range operator</span></a>.</p>
<p>Constructs a <a href="/Documentable/integration-test/type/Range">Range</a> from the arguments, excluding the end point.</p>
<h2 id="infix_^.."><a class="u" href="#___top" title="go to top of document">infix <code>^..</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;^..&gt;($a, $b --&gt; Range:D) is assoc&lt;non&gt;</pre>
<p><a name="Documentable/integration-test/index-entry-Left-open_range_operator"><span class="index-entry">Left-open range operator</span></a>.</p>
<p>Constructs a <a href="/Documentable/integration-test/type/Range">Range</a> from the arguments, excluding the start point.</p>
<h2 id="infix_^..^"><a class="u" href="#___top" title="go to top of document">infix <code>^..^</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;^..^&gt;($a, $b --&gt; Range:D) is assoc&lt;non&gt;</pre>
<p><a name="Documentable/integration-test/index-entry-Open_range_operator"><span class="index-entry">Open range operator</span></a></p>
<p>Constructs a <a href="/Documentable/integration-test/type/Range">Range</a> from the arguments, excluding both start and end point.</p>
<h1 id="Chaining_binary_precedence"><a class="u" href="#___top" title="go to top of document">Chaining binary precedence</a></h1>
<h2 id="infix_=="><a class="u" href="#___top" title="go to top of document">infix <code>==</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;==&gt;(Any, Any)
multi sub infix:&lt;==&gt;(Int:D, Int:D)
multi sub infix:&lt;==&gt;(Num:D, Num:D)
multi sub infix:&lt;==&gt;(Rational:D, Rational:D)
multi sub infix:&lt;==&gt;(Real:D, Real:D)
multi sub infix:&lt;==&gt;(Complex:D, Complex:D)
multi sub infix:&lt;==&gt;(Numeric:D, Numeric:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Numeric_equality_operator"><span class="index-entry">Numeric equality operator</span></a>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> (if necessary); returns <code>True</code> if they are equal.</p>
<h2 id="infix_!="><a class="u" href="#___top" title="go to top of document">infix <code>!=</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;!=&gt;(Mu, Mu --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Numeric_inequality_operator"><span class="index-entry">Numeric inequality operator</span></a>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> (if necessary); returns <code>True</code> if they are distinct.</p>
<p>Is an alias to <code>!==</code>.</p>
<h2 id="infix_≠"><a class="u" href="#___top" title="go to top of document">infix <code>≠</code></a></h2>
<p>Numeric inequality operator.</p>
<p>Equivalent to <a href="/Documentable/integration-test/routine/!=">!=</a>, at codepoint U+2260 (NOT EQUAL TO).</p>
<h2 id="infix_<"><a class="u" href="#___top" title="go to top of document">infix <code>&lt;</code></a></h2>
<pre class="pod-block-code">multi sub infix:«&lt;»(Int:D, Int:D)
multi sub infix:«&lt;»(Num:D, Num:D)
multi sub infix:«&lt;»(Real:D, Real:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Numeric_less_than_operator"><span class="index-entry">Numeric less than operator</span></a>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Real">Real</a> (if necessary); returns <code>True</code> if the first argument is smaller than the second.</p>
<h2 id="infix_<="><a class="u" href="#___top" title="go to top of document">infix <code>&lt;=</code></a></h2>
<pre class="pod-block-code">multi sub infix:«&lt;=»(Int:D, Int:D)
multi sub infix:«&lt;=»(Num:D, Num:D)
multi sub infix:«&lt;=»(Real:D, Real:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Numeric_less_than_or_equal_to_operator"><span class="index-entry">Numeric less than or equal to operator</span></a>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Real">Real</a> (if necessary); returns <code>True</code> if the first argument is smaller than or equal to the second.</p>
<h2 id="infix_≤"><a class="u" href="#___top" title="go to top of document">infix <code>≤</code></a></h2>
<p>Numeric less than or equal to operator.</p>
<p>Equivalent to <a href="/Documentable/integration-test/routine/<=">&lt;=</a>, at codepoint U+2264 (LESS-THAN OR EQUAL TO).</p>
<h2 id="infix_>"><a class="u" href="#___top" title="go to top of document">infix <code>&gt;</code></a></h2>
<pre class="pod-block-code">multi sub infix:«&gt;»(Int:D, Int:D)
multi sub infix:«&gt;»(Num:D, Num:D)
multi sub infix:«&gt;»(Real:D, Real:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Numeric_greater_than_operator"><span class="index-entry">Numeric greater than operator</span></a>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Real">Real</a> (if necessary); returns <code>True</code> if the first argument is larger than the second.</p>
<h2 id="infix_>="><a class="u" href="#___top" title="go to top of document">infix <code>&gt;=</code></a></h2>
<pre class="pod-block-code">multi sub infix:«&gt;=»(Int:D, Int:D)
multi sub infix:«&gt;=»(Num:D, Num:D)
multi sub infix:«&gt;=»(Real:D, Real:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Numeric_greater_than_or_equal_to_operator"><span class="index-entry">Numeric greater than or equal to operator</span></a>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Real">Real</a> (if necessary); returns <code>True</code> if the first argument is larger than or equal to the second.</p>
<h2 id="infix_≥"><a class="u" href="#___top" title="go to top of document">infix <code>≥</code></a></h2>
<p>Numeric greater than or equal to operator.</p>
<p>Equivalent to <a href="/Documentable/integration-test/routine/>=">&gt;=</a>, at codepoint U+2265 (GREATER-THAN OR EQUAL TO).</p>
<h2 id="infix_eq"><a class="u" href="#___top" title="go to top of document">infix <code>eq</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;eq&gt;(Any,   Any)
multi sub infix:&lt;eq&gt;(Str:D, Str:D)</pre>
<p><a name="Documentable/integration-test/index-entry-String_equality_operator"><span class="index-entry">String equality operator</span></a>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Str">Str</a> (if necessary); returns <code>True</code> if both are equal.</p>
<p>Mnemonic: <em>equal</em></p>
<h2 id="infix_ne"><a class="u" href="#___top" title="go to top of document">infix <code>ne</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;ne&gt;(Mu,    Mu)
multi sub infix:&lt;ne&gt;(Str:D, Str:D)</pre>
<p><a name="Documentable/integration-test/index-entry-String_inequality_operator"><span class="index-entry">String inequality operator</span></a>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Str">Str</a> (if necessary); returns <code>False</code> if both are equal.</p>
<p>Mnemonic: <em>not equal</em></p>
<h2 id="infix_gt"><a class="u" href="#___top" title="go to top of document">infix <code>gt</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;gt&gt;(Mu,    Mu)
multi sub infix:&lt;gt&gt;(Str:D, Str:D)</pre>
<p><a name="Documentable/integration-test/index-entry-String_greater_than_operator"><span class="index-entry">String greater than operator</span></a>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Str">Str</a> (if necessary); returns <code>True</code> if the first is larger than the second, as determined by lexicographic comparison.</p>
<p>Mnemonic: <em>greater than</em></p>
<h2 id="infix_ge"><a class="u" href="#___top" title="go to top of document">infix <code>ge</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;ge&gt;(Mu,    Mu)
multi sub infix:&lt;ge&gt;(Str:D, Str:D)</pre>
<p><a name="Documentable/integration-test/index-entry-String_greater_than_or_equal_to_operator"><span class="index-entry">String greater than or equal to operator</span></a>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Str">Str</a> (if necessary); returns <code>True</code> if the first is equal to or larger than the second, as determined by lexicographic comparison.</p>
<p>Mnemonic: <em>greater or equal</em></p>
<h2 id="infix_lt"><a class="u" href="#___top" title="go to top of document">infix <code>lt</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;lt&gt;(Mu,    Mu)
multi sub infix:&lt;lt&gt;(Str:D, Str:D)</pre>
<p><a name="Documentable/integration-test/index-entry-String_less_than_operator"><span class="index-entry">String less than operator</span></a>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Str">Str</a> (if necessary); returns <code>True</code> if the first is smaller than the second, as determined by lexicographic comparison.</p>
<p>Mnemonic: <em>less than</em></p>
<h2 id="infix_le"><a class="u" href="#___top" title="go to top of document">infix <code>le</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;le&gt;(Mu,    Mu)
multi sub infix:&lt;le&gt;(Str:D, Str:D)</pre>
<p><a name="Documentable/integration-test/index-entry-String_less_than_or_equal_to_operator"><span class="index-entry">String less than or equal to operator</span></a>.</p>
<p>Coerces both arguments to <a href="/Documentable/integration-test/type/Str">Str</a> (if necessary); returns <code>True</code> if the first is equal to or smaller than the second, as determined by lexicographic comparison.</p>
<p>Mnemonic: <em>less or equal</em></p>
<h2 id="infix_before"><a class="u" href="#___top" title="go to top of document">infix <code>before</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;before&gt;(Any,       Any)
multi sub infix:&lt;before&gt;(Real:D,    Real:D)
multi sub infix:&lt;before&gt;(Str:D,     Str:D)
multi sub infix:&lt;before&gt;(Version:D, Version:D)</pre>
<p>Generic ordering, uses the same semantics as <a href="/Documentable/integration-test/routine/cmp">cmp</a>. Returns <code>True</code> if the first argument is smaller than the second.</p>
<h2 id="infix_after"><a class="u" href="#___top" title="go to top of document">infix <code>after</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;after&gt;(Any,       Any)
multi sub infix:&lt;after&gt;(Real:D,    Real:D)
multi sub infix:&lt;after&gt;(Str:D,     Str:D)
multi sub infix:&lt;after&gt;(Version:D, Version:D)</pre>
<p>Generic ordering, uses the same semantics as <a href="/Documentable/integration-test/routine/cmp">cmp</a>. Returns <code>True</code> if the first argument is larger than the second.</p>
<h2 id="infix_eqv"><a class="u" href="#___top" title="go to top of document">infix <code>eqv</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;eqv&gt;(Any, Any)</pre>
<p>This could be called an <a name="Documentable/integration-test/index-entry-equivalence_operator"><span class="index-entry">equivalence operator</span></a>, and it will return <code>True</code> if the two arguments are structurally the same, i.e. from the same type and (recursively) contain equivalent values.</p>
<pre class="pod-block-code">say [1, 2, 3] eqv [1, 2, 3];    # OUTPUT: «True␤»
say Any eqv Any;                # OUTPUT: «True␤»
say 1 eqv 2;                    # OUTPUT: «False␤»
say 1 eqv 1.0;                  # OUTPUT: «False␤»</pre>
<p>Lazy <a href="/Documentable/integration-test/type/Iterable"><code>Iterables</code></a> cannot be compared, as they&#39;re assumed to be infinite. However, the operator will do its best and return <code>False</code> if the two lazy <code>Iterables</code> are of different types or if only one <code>Iterable</code> is lazy.</p>
<pre class="pod-block-code">say (1…∞) eqv (1…∞).List; # Both lazy, but different types;   OUTPUT: «False␤»
say (1…∞) eqv (1…3);      # Same types, but only one is lazy; OUTPUT: «False␤»
(try say (1…∞) eqv (1…∞)) # Both lazy and of the same type. Cannot compare; throws.
    orelse say $!.^name;  # OUTPUT: «X::Cannot::Lazy␤»</pre>
<p>In some cases, it will be able to compare lazy operands, as long as they can be iterated</p>
<pre class="pod-block-code">my $a = lazy ^2;
my $b = $a;
$a.cache;
say $a eqv $b; # OUTPUT: «True␤»
</pre>
<p>When cached, the two lazy <code>Seq</code>s can be iterated over, and thus compared.</p>
<p>The default <code>eqv</code> operator even works with arbitrary objects. E.g., <code>eqv</code> will consider two instances of the same object as being structurally equivalent:</p>
<pre class="pod-block-code">my class A {
    has $.a;
}
say A.new(a =&gt; 5) eqv A.new(a =&gt; 5);  # OUTPUT: «True␤»</pre>
<p>Although the above example works as intended, the <code>eqv</code> code might fall back to a slower code path in order to do its job. One way to avoid this is to implement an appropriate infix <code>eqv</code> operator:</p>
<pre class="pod-block-code">my class A {
    has $.a;
}
multi infix:&lt;eqv&gt;(A $l, A $r) { $l.a eqv $r.a }
say A.new(a =&gt; 5) eqv A.new(a =&gt; 5);            # OUTPUT: «True␤»</pre>
<p>Note that <code>eqv</code> does not work recursively on every kind of container type, e.g. <code>Set</code>:</p>
<pre class="pod-block-code">my class A {
    has $.a;
}
say Set(A.new(a =&gt; 5)) eqv Set(A.new(a =&gt; 5));  # OUTPUT: «False␤»</pre>
<p>Even though the contents of the two sets are <code>eqv</code>, the sets are not. The reason is that <code>eqv</code> delegates the equality check to the <code>Set</code> object which relies on element-wise <code>===</code> comparison. Turning the class <code>A</code> into a <a href="/Documentable/integration-test/type/ValueObjAt">value type</a> by giving it a <code>WHICH</code> method produces the expected behavior:</p>
<pre class="pod-block-code">my class A {
    has $.a;
    method WHICH {
        ValueObjAt.new: &quot;A|$!a.WHICH()&quot;
    }
}
say Set(A.new(a =&gt; 5)) eqv Set(A.new(a =&gt; 5));  # OUTPUT: «True␤»</pre>
<p>You can call a single-argument version of the operator by using its full name; it will always return true.</p>
<pre class="pod-block-code">say infix:&lt;eqv&gt;(33);    # OUTPUT: «True␤»
say infix:&lt;eqv&gt;(False); # OUTPUT: «True␤»
</pre>
<h2 id="infix_==="><a class="u" href="#___top" title="go to top of document">infix <code>===</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;===&gt;(Any, Any)</pre>
<p><a name="Documentable/integration-test/index-entry-Value_identity_operator"><span class="index-entry">Value identity operator</span></a>. Returns <code>True</code> if both arguments are the same object, disregarding any containerization.</p>
<pre class="pod-block-code">my class A { };
my $a = A.new;
say $a === $a;              # OUTPUT: «True␤»
say A.new === A.new;        # OUTPUT: «False␤»
say A === A;                # OUTPUT: «True␤»</pre>
<p>For value types, <code>===</code> behaves like <code>eqv</code>:</p>
<pre class="pod-block-code">say &#39;a&#39; === &#39;a&#39;;            # OUTPUT: «True␤»
say &#39;a&#39; === &#39;b&#39;;            # OUTPUT: «False␤»

my $b = &#39;a&#39;;
say $b === &#39;a&#39;;             # OUTPUT: «True␤»

# different types
say 1 === 1.0;              # OUTPUT: «False␤»</pre>
<p><code>===</code> uses the <a href="/Documentable/integration-test/routine/WHICH">WHICH</a> method to obtain the object identity.</p>
<p>If you want to create a class that should act as a value type, then that class must create an instance method <code>WHICH</code>, that should return a <a href="/Documentable/integration-test/type/ValueObjAt">ValueObjAt</a> object that won&#39;t change for the lifetime of the object.</p>
<h2 id="infix_=:="><a class="u" href="#___top" title="go to top of document">infix <code>=:=</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;=:=&gt;(Mu \a, Mu \b)</pre>
<p><a name="Documentable/integration-test/index-entry-Container_identity_operator"><span class="index-entry">Container identity operator</span></a>. Returns <code>True</code> if both arguments are bound to the same container. If it returns <code>True</code>, it generally means that modifying one will also modify the other.</p>
<pre class="pod-block-code">my ($a, $b) = (1, 3);
say $a =:= $b;      # OUTPUT: «False␤»
$b = 2;
say $a;             # OUTPUT: «1␤»
$b := $a;
say $a =:= $b;      # OUTPUT: «True␤»
$a = 5;
say $b;             # OUTPUT: «5␤»</pre>
<p>The single argument version, called as a routine, will always return True:</p>
<pre class="pod-block-code">say infix:&lt;=:=&gt;(42);    # OUTPUT: «True␤»
say infix:&lt;=:=&gt;(False); # OUTPUT: «True␤»
</pre>
<p><a name="Documentable/integration-test/index-entry-smartmatch_operator"></a></p>
<h2 id="infix_~~"><a class="u" href="#___top" title="go to top of document">infix <code>~~</code></a></h2>
<p>The smartmatch operator aliases the left-hand side to <code>$_</code>, then evaluates the right-hand side and calls <code>.ACCEPTS($_)</code> on it. The semantics are left to the type of the right-hand side operand.</p>
<p>Here is a partial list of some of the built-in smartmatching functionality. For full details, see <a href="/Documentable/integration-test/routine/ACCEPTS">ACCEPTS</a> documentation for the type on the right-hand side of the operator.</p>
<table class="pod-table">
<thead><tr>
<th>Right-hand side</th> <th>Comparison semantics</th>
</tr></thead>
<tbody>
<tr> <td>Mu:U</td> <td>type check</td> </tr> <tr> <td>Str</td> <td>string equality</td> </tr> <tr> <td>Numeric</td> <td>numeric equality</td> </tr> <tr> <td>Regex</td> <td>regex match</td> </tr> <tr> <td>Callable</td> <td>boolean result of invocation</td> </tr> <tr> <td>Set/Bag</td> <td>equal element values</td> </tr> <tr> <td>Any:D</td> <td>object identity</td> </tr>
</tbody>
</table><h2 id="infix_=~="><a class="u" href="#___top" title="go to top of document">infix <code>=~=</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;=~=&gt;(Any, Any)
multi sub infix:&lt;=~=&gt;(Int:D, Int:D)
multi sub infix:&lt;=~=&gt;(Num:D, Num:D)
multi sub infix:&lt;=~=&gt;(Rational:D, Rational:D)
multi sub infix:&lt;=~=&gt;(Real:D, Real:D)
multi sub infix:&lt;=~=&gt;(Complex:D, Complex:D)
multi sub infix:&lt;=~=&gt;(Numeric:D, Numeric:D)</pre>
<p>The approximately-equal operator <a name="Documentable/integration-test/index-entry-infix__≅-≅"><span class="index-entry"><code>≅</code></span></a>, whose ASCII variant is <code>=~=</code>, calculates the relative difference between the left-hand and right-hand sides and returns <code>True</code> if the difference is less than <code>$*TOLERANCE</code> (which defaults to 1e-15). However, if either side is zero then it checks that the absolute difference between the sides is less than <code>$*TOLERANCE</code>. Note that this operator is not arithmetically symmetrical (doesn&#39;t do ± Δ):</p>
<pre class="pod-block-code">my $x = 1;
say ($x + $*TOLERANCE) =~= $x;   # OUTPUT: «False␤»
say ($x - $*TOLERANCE) =~= $x;   # OUTPUT: «True␤»</pre>
<p>The tolerance is supposed to be modifiable via an adverb:</p>
<pre class="pod-block-code">my ($x, $y) = 42, 42.1;
say $x =~= $y :tolerance(.1);
</pre>
<p>However, this is not yet implemented. The same effect can be achieved by assigning to $*TOLERANCE.</p>
<pre class="pod-block-code">{
    my $*TOLERANCE = .1;
    say 11 =~= 10;        # OUTPUT: «True␤»
}</pre>
<p>Note that setting $*TOLERANCE = 0 will cause all comparisons to fail.</p>
<pre class="pod-block-code">{
    my $*TOLERANCE = 0;
    say 1 =~= 1;          # OUTPUT: «False␤»
}</pre>
<h2 id="infix_(elem),_infix_∈"><a class="u" href="#___top" title="go to top of document">infix (elem), infix ∈</a></h2>
<pre class="pod-block-code">multi sub infix:&lt;(elem)&gt;($a,$b --&gt; Bool:D)
multi sub infix:&lt;∈&gt;($a,$b --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Membership_operator"><span class="index-entry">Membership operator</span></a>.</p>
<p>Returns <code>True</code> if <code>$a</code> is an <strong>element</strong> of <code>$b</code>.</p>
<pre class="pod-block-code">say 2 (elem) (1, 2, 3); # OUTPUT: «True␤»
say 4 ∈ (1, 2, 3); # OUTPUT: «False␤»
</pre>
<p><code>∈</code> is equivalent to <code>(elem)</code>, at codepoint U+2208 (ELEMENT OF).</p>
<h2 id="infix_∉"><a class="u" href="#___top" title="go to top of document">infix <code>∉</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;∉&gt;($a,$b --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Non-membership_operator"><span class="index-entry">Non-membership operator</span></a>.</p>
<p>Returns <code>True</code> if <code>$a</code> is <strong>not</strong> an <strong>element</strong> of <code>$b</code>. Equivalent to <code>!(elem)</code>.</p>
<pre class="pod-block-code">say 4 ∉ (1, 2, 3);       # OUTPUT: «True␤»
say 2 !(elem) (1, 2, 3); # OUTPUT: «False␤»
</pre>
<p><code>∉</code> is codepoint U+2209 (NOT AN ELEMENT OF).</p>
<h2 id="infix_(cont),_infix_∋"><a class="u" href="#___top" title="go to top of document">infix (cont), infix ∋</a></h2>
<pre class="pod-block-code">multi sub infix:&lt;(cont)&gt;($a,$b --&gt; Bool:D)
multi sub infix:&lt;∋&gt;($a,$b --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Membership_operator"><span class="index-entry">Membership operator</span></a>.</p>
<p>Returns <code>True</code> if <code>$a</code> <strong>contains</strong> <code>$b</code>.</p>
<pre class="pod-block-code">say (1,2,3) (cont) 2; # OUTPUT: «True␤»
say (1, 2, 3) ∋ 4;    # OUTPUT: «False␤»
</pre>
<p><code>∋</code> is equivalent to <code>(cont)</code>, at codepoint U+220B (CONTAINS AS MEMBER).</p>
<h2 id="infix_∌"><a class="u" href="#___top" title="go to top of document">infix <code>∌</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;∌&gt;($a,$b --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Non-membership_operator"><span class="index-entry">Non-membership operator</span></a>.</p>
<p>Returns <code>True</code> if <code>$a</code> does <strong>not</strong> <strong>contain</strong> <code>$b</code>. Equivalent to <code>!(cont)</code>.</p>
<pre class="pod-block-code">say (1,2,3) ∌ 4;       # OUTPUT: «True␤»
say (1,2,3) !(cont) 2; # OUTPUT: «False␤»
</pre>
<p><code>∌</code> is codepoint U+220C (DOES NOT CONTAIN AS MEMBER).</p>
<h2 id="infix_(<),_infix_⊂"><a class="u" href="#___top" title="go to top of document">infix <code>(&lt;)</code>, infix <code>⊂</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;&lt; (&lt;) &gt;&gt;($a,$b --&gt; Bool:D)
multi sub infix:&lt;⊂&gt;($a,$b --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Subset_of_operator"><span class="index-entry">Subset of operator</span></a>.</p>
<p>Returns <code>True</code> if <code>$a</code> is a <strong>strict subset</strong> of <code>$b</code>, i.e., that all the elements of <code>$a</code> are elements of <code>$b</code> but <code>$a</code> is a smaller set than <code>$b</code>.</p>
<pre class="pod-block-code">say (1,2,3) (&lt;) (2,3,1); # OUTPUT: «False␤»
say (2,3) (&lt;) (2,3,1);   # OUTPUT: «True␤»
say 4 ⊂ (1,2,3);         # OUTPUT: «False␤»
</pre>
<p><code>⊂</code> is equivalent to <code>(&lt;)</code>, at codepoint U+2282 (SUBSET OF).</p>
<h2 id="infix_⊄"><a class="u" href="#___top" title="go to top of document">infix <code>⊄</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;⊄&gt;($a,$b --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Not_a_subset_of_operator"><span class="index-entry">Not a subset of operator</span></a>.</p>
<p>Returns <code>True</code> if <code>$a</code> is <strong>not</strong> a <code>strict subset</code> of <code>$b</code>. Equivalent to <code>!(&lt;)</code>.</p>
<pre class="pod-block-code">say (1,2,3) ⊄ (2,3,1); # OUTPUT: «True␤»
say (2,3) ⊄ (2,3,1);   # OUTPUT: «False␤»
say 4 !(&lt;) (1,2,3);    # OUTPUT: «True␤»
</pre>
<p><code>⊄</code> is codepoint U+2284 (NOT A SUBSET OF).</p>
<h2 id="infix_(<=),_infix_⊆"><a class="u" href="#___top" title="go to top of document">infix <code>(&lt;=)</code>, infix <code>⊆</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;&lt; (&lt;=) &gt;&gt;($a,$b --&gt; Bool:D)
multi sub infix:&lt;⊆&gt;($a,$b --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Subset_of_or_equal_to_operator"><span class="index-entry">Subset of or equal to operator</span></a>.</p>
<p>Returns <code>True</code> if <code>$a</code> is a <strong>subset</strong> of <code>$b</code>, i.e., that all the elements of <code>$a</code> are elements of <code>$b</code> but <code>$a</code> is a smaller or equal sized set than <code>$b</code>.</p>
<pre class="pod-block-code">say (1,2,3) (&lt;=) (2,3,1); # OUTPUT: «True␤»
say (2,3) (&lt;=) (2,3,1);   # OUTPUT: «True␤»
say 4 ⊆ (1,2,3);          # OUTPUT: «False␤»
</pre>
<p><code>⊆</code> is equivalent to <code>(&lt;=)</code>, at codepoint U+2286 (SUBSET OF OR EQUAL TO).</p>
<h2 id="infix_⊈"><a class="u" href="#___top" title="go to top of document">infix <code>⊈</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;⊈&gt;($a,$b --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Not_a_subset_of_nor_equal_to_operator"><span class="index-entry">Not a subset of nor equal to operator</span></a>.</p>
<p>Returns <code>True</code> if <code>$a</code> is <strong>not</strong> a <code>subset</code> of <code>$b</code>. Equivalent to <code>!(&lt;=)</code>.</p>
<pre class="pod-block-code">say (1,2,3) ⊈ (2,3,1); # OUTPUT: «False␤»
say (2,3) ⊈ (2,3,1);   # OUTPUT: «False␤»
say 4 !(&lt;=) (1,2,3);   # OUTPUT: «True␤»
</pre>
<p><code>⊈</code> is codepoint U+2288 (NEITHER A SUBSET OF NOR EQUAL TO).</p>
<h2 id="infix_(>),_infix_⊃"><a class="u" href="#___top" title="go to top of document">infix <code>(&gt;)</code>, infix <code>⊃</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;&lt; (&gt;) &gt;&gt;($a,$b --&gt; Bool:D)
multi sub infix:&lt;⊃&gt;($a,$b --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Superset_of_operator"><span class="index-entry">Superset of operator</span></a>.</p>
<p>Returns <code>True</code> if <code>$a</code> is a <strong>strict superset</strong> of <code>$b</code>, i.e., that all the elements of <code>$b</code> are elements of <code>$a</code> but <code>$a</code> is a larger set than <code>$b</code>.</p>
<pre class="pod-block-code">say (1,2,3) (&gt;) (2,3,1); # OUTPUT: «False␤»
say (1,2,3) (&gt;) (2,3);   # OUTPUT: «True␤»
say 4 ⊃ (1,2,3);         # OUTPUT: «False␤»
</pre>
<p><code>⊃</code> is equivalent to <code>(&gt;)</code>, at codepoint U+2283 (SUPERSET OF).</p>
<h2 id="infix_⊅"><a class="u" href="#___top" title="go to top of document">infix <code>⊅</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;⊅&gt;($a,$b --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Not_a_superset_of_operator"><span class="index-entry">Not a superset of operator</span></a>.</p>
<p>Returns <code>True</code> if <code>$a</code> is <strong>not</strong> a <code>strict superset</code> of <code>$b</code>. Equivalent to <code>!(&gt;)</code>.</p>
<pre class="pod-block-code">say (1,2,3) ⊅ (2,3,1); # OUTPUT: «True␤»
say (1,2,3) ⊅ (2,3);   # OUTPUT: «False␤»
say 4 !(&gt;) (1,2,3);    # OUTPUT: «True␤»
</pre>
<p><code>⊅</code> is codepoint U+2285 (NOT A SUPERSET OF).</p>
<h2 id="infix_(>=),_infix_⊇"><a class="u" href="#___top" title="go to top of document">infix <code>(&gt;=)</code>, infix <code>⊇</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;&lt; (&gt;=) &gt;&gt;($a,$b --&gt; Bool:D)
multi sub infix:&lt;⊇&gt;($a,$b --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Superset_of_or_equal_to_operator"><span class="index-entry">Superset of or equal to operator</span></a>.</p>
<p>Returns <code>True</code> if <code>$a</code> is a <strong>superset</strong> of <code>$b</code>, i.e., that all the elements of <code>$b</code> are elements of <code>$a</code> but <code>$a</code> is a larger or equal sized set than <code>$b</code>.</p>
<pre class="pod-block-code">say (1,2,3) (&gt;=) (2,3,1); # OUTPUT: «True␤»
say (1,2,3) (&gt;=) (2,3);   # OUTPUT: «True␤»
say 4 ⊇ (1,2,3);          # OUTPUT: «False␤»
</pre>
<p><code>⊇</code> is equivalent to <code>(&gt;=)</code>, at codepoint U+2287 (SUPERSET OF OR EQUAL TO).</p>
<h2 id="infix_⊉"><a class="u" href="#___top" title="go to top of document">infix <code>⊉</code></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;⊉&gt;($a,$b --&gt; Bool:D)</pre>
<p><a name="Documentable/integration-test/index-entry-Not_a_superset_of_nor_equal_to_operator"><span class="index-entry">Not a superset of nor equal to operator</span></a>.</p>
<p>Returns <code>True</code> if <code>$a</code> is <strong>not</strong> a <code>superset</code> of <code>$b</code>. Equivalent to <code>!(&gt;=)</code>.</p>
<pre class="pod-block-code">say (1,2,3) ⊉ (2,3,1); # OUTPUT: «False␤»
say (1,2,3) ⊉ (2,3);   # OUTPUT: «False␤»
say 4 !(&gt;=) (1,2,3);   # OUTPUT: «True␤»
</pre>
<p><code>⊉</code> is codepoint U+2289 (NEITHER A SUPERSET OF OR EQUAL TO).</p>
<h1 id="Tight_AND_precedence"><a class="u" href="#___top" title="go to top of document">Tight AND precedence</a></h1>
<h2 id="infix_&&"><a class="u" href="#___top" title="go to top of document">infix <code>&amp;&amp;</code></a></h2>
<p>Returns the first argument that evaluates to <code>False</code> in boolean context, otherwise returns the last argument.</p>
<p>Note that this short-circuits, i.e. if one of the arguments evaluates to a false value, the arguments to the right are never evaluated.</p>
<pre class="pod-block-code">sub a { 1 }
sub b { 0 }
sub c { die &quot;never called&quot; };
say a() &amp;&amp; b() &amp;&amp; c();      # OUTPUT: «0␤»</pre>
<h1 id="Tight_OR_precedence"><a class="u" href="#___top" title="go to top of document">Tight OR precedence</a></h1>
<h2 id="infix_||"><a class="u" href="#___top" title="go to top of document">infix <code>||</code></a></h2>
<p>Returns the first argument that evaluates to <code>True</code> in boolean context, otherwise returns the last argument.</p>
<p>Note that this short-circuits; i.e., if one of the arguments evaluates to a true value, the remaining arguments are not evaluated.</p>
<pre class="pod-block-code">sub a { 0 }
sub b { 1 }
sub c { die &quot;never called&quot; };
say a() || b() || c();      # OUTPUT: «1␤»</pre>
<h2 id="infix_^^"><a class="u" href="#___top" title="go to top of document">infix <code>^^</code></a></h2>
<p><a name="Documentable/integration-test/index-entry-Short-circuit_exclusive-or"><span class="index-entry">Short-circuit exclusive-or</span></a>. Returns the true argument if there is one (and only one). Returns the last argument if all arguments are false. Returns <code>Nil</code> when more than one argument is true.</p>
<p>This operator short-circuits in the sense that it does not evaluate any arguments after a 2nd true result.</p>
<pre class="pod-block-code">say 0 ^^ 42;                             # OUTPUT: «42␤»
say &#39;&#39; ^^ 0;                             # OUTPUT: «0␤»
say 0 ^^ 42 ^^ 1 ^^ die &quot;never called&quot;;  # OUTPUT: «Nil␤»</pre>
<p>Note that the semantics of this operator may not be what you assume: infix <code>^^</code> flips to the first true value it finds and then flips to Nil <em>forever</em> after the second, no matter how many more true values there are. (In other words, it has &quot;find the one true value&quot; semantics, not &quot;boolean parity&quot; semantics.)</p>
<h2 id="infix_//"><a class="u" href="#___top" title="go to top of document">infix <code>//</code></a></h2>
<p>The <a name="Documentable/integration-test/index-entry-defined-or_operator-defined-or_operator"><span class="index-entry">defined-or operator</span></a> or <a name="Documentable/integration-testindex-entry-//-infix_//"><span class="index-entry">infix //</span></a> returns the first defined operand, or else the last operand. Short-circuits.</p>
<pre class="pod-block-code">say Any // 0 // 42;         # OUTPUT: «0␤»</pre>
<h2 id="infix_min"><a class="u" href="#___top" title="go to top of document">infix <code>min</code></a></h2>
<p>Returns the smallest of the arguments, as determined by <a href="/Documentable/integration-test/routine/cmp">cmp</a> semantics.</p>
<pre class="pod-block-code">my $foo = 42;
$foo min= 0   # read as: $foo decreases to 0</pre>
<h2 id="infix_max"><a class="u" href="#___top" title="go to top of document">infix <code>max</code></a></h2>
<p>Returns the largest of the arguments, as determined by <a href="/Documentable/integration-test/routine/cmp">cmp</a> semantics.</p>
<pre class="pod-block-code">my $foo = -42;
$foo max= 0   # read as: $foo increases to 0</pre>
<h2 id="infix_minmax"><a class="u" href="#___top" title="go to top of document">infix <code>minmax</code></a></h2>
<p>Returns the <a href="/Documentable/integration-test/type/Range">Range</a> starting from the lowest to the highest of the values, as determined by the <a href="/Documentable/integration-test/routine/cmp">cmp</a> semantics. For instance:</p>
<pre class="pod-block-code"># numeric comparison
10 minmax 3;     # 3..10

# string comparison
&#39;10&#39; minmax &#39;3&#39;; # &quot;10&quot;..&quot;3&quot;
&#39;z&#39; minmax &#39;k&#39;;  # &quot;k&quot;..&quot;z&quot;
</pre>
<p>If the lowest and highest values coincide, the operator returns a <a href="/Documentable/integration-test/type/Range">Range</a> made by the same value:</p>
<pre class="pod-block-code">1 minmax 1;  # 1..1
</pre>
<p>When applied to <a href="/Documentable/integration-test/type/List">List</a>s, the operator evaluates the lowest and highest values among all available values:</p>
<pre class="pod-block-code">(10,20,30) minmax (0,11,22,33);       # 0..33
(&#39;a&#39;,&#39;b&#39;,&#39;z&#39;) minmax (&#39;c&#39;,&#39;d&#39;,&#39;w&#39;);   # &quot;a&quot;..&quot;z&quot;
</pre>
<p>Similarly, when applied to <a href="/Documentable/integration-test/type/Hash">Hash</a>es, it performs a <a href="/Documentable/integration-test/routine/cmp">cmp</a> way comparison:</p>
<pre class="pod-block-code">my %winner = points =&gt; 30, misses =&gt; 10;
my %loser = points =&gt; 20, misses =&gt; 10;
%winner cmp %loser;      # More
%winner minmax %loser;
# ${:misses(10), :points(20)}..${:misses(10), :points(30)}
</pre>
<h1 id="Conditional_operator_precedence"><a class="u" href="#___top" title="go to top of document">Conditional operator precedence</a></h1>
<p><a name="Documentable/integration-test/index-entry-operator_ternary"></a> <a name="Documentable/integration-test/index-entry-operator_conditional"></a></p>
<h2 id="infix_??_!!"><a class="u" href="#___top" title="go to top of document">infix <code>?? !!</code></a></h2>
<p>Also called <em>ternary</em> or <em>conditional</em> operator, <code>$condition ?? $true !! $false</code> evaluates <code>$condition</code> and returns the expression right behind ??, in this case <code>$true</code> if it is <code>True</code>, otherwise evaluates and returns the expression behind !!, <code>$false</code> in this case.</p>
<p><a name="Documentable/integration-test/index-entry-operator_flipflop"></a></p>
<h2 id="infix_ff"><a class="u" href="#___top" title="go to top of document">infix <code>ff</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;ff&gt;(Mu $a, Mu $b)</pre>
<p>Also called the <em>flipflop operator</em>, compares both arguments to <code>$_</code> (that is, <code>$_ ~~ $a</code> and <code>$_ ~~ $b</code>). Evaluates to <code>False</code> until the left-hand smartmatch is <code>True</code>, at which point it evaluates to <code>True</code> until the right-hand smartmatch is <code>True</code>.</p>
<p>In effect, the left-hand argument is the &quot;start&quot; condition and the right-hand is the &quot;stop&quot; condition. This construct is typically used to pick up only a certain section of lines. For example:</p>
<pre class="pod-block-code">my $excerpt = q:to/END/;
Here&#39;s some unimportant text.
=begin code
    This code block is what we&#39;re after.
    We&#39;ll use &#39;ff&#39; to get it.
=end code
More unimportant text.
END

my @codelines = gather for $excerpt.lines {
    take $_ if <strong>&quot;=begin code&quot; ff &quot;=end code&quot;</strong>
}
# this will print four lines, starting with &quot;=begin code&quot; and ending with
# &quot;=end code&quot;
say @codelines.join(&quot;\n&quot;);
</pre>
<p>After matching the start condition, the operator will then match the same <code>$_</code> to the stop condition and act accordingly if successful. In this example, only the first element is printed:</p>
<pre class="pod-block-code">for &lt;AB C D B E F&gt; {
    say $_ if /A/ ff /B/;  # OUTPUT: «AB␤»
}</pre>
<p>If you only want to test against a start condition and have no stop condition, <code>*</code> can be used as such.</p>
<pre class="pod-block-code">for &lt;A B C D E&gt; {
    say $_ if /C/ ff *;    # OUTPUT: «C␤D␤E␤»
}</pre>
<p>For the <code>sed</code>-like version, which does <em>not</em> try <code>$_</code> on the stop condition after succeeding on the start condition, see <a href="/Documentable/integration-test/routine/fff">fff</a>.</p>
<p>This operator cannot be overloaded, as it&#39;s handled specially by the compiler.</p>
<h2 id="infix_^ff"><a class="u" href="#___top" title="go to top of document">infix <code>^ff</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;^ff&gt;(Mu $a, Mu $b)</pre>
<p>Works like <a href="/Documentable/integration-test/routine/ff">ff</a>, except it does not return <code>True</code> for items matching the start condition (including items also matching the stop condition).</p>
<p>A comparison:</p>
<pre class="pod-block-code">my @list = &lt;A B C&gt;;
say $_ if /A/ ff /C/ for @list;    # OUTPUT: «A␤B␤C␤»
say $_ if /A/ ^ff /C/ for @list;   # OUTPUT: «B␤C␤»</pre>
<p>The sed-like version can be found in <a href="/Documentable/integration-test/routine/$CIRCUMFLEX_ACCENTfff"><code>^fff</code></a>.</p>
<p>This operator cannot be overloaded, as it&#39;s handled specially by the compiler.</p>
<h2 id="infix_ff^"><a class="u" href="#___top" title="go to top of document">infix <code>ff^</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;ff^&gt;(Mu $a, Mu $b)</pre>
<p>Works like <a href="/Documentable/integration-test/routine/ff">ff</a>, except it does not return <code>True</code> for items matching the stop condition (including items that first matched the start condition).</p>
<pre class="pod-block-code">my @list = &lt;A B C&gt;;
say $_ if /A/ ff /C/ for @list;    # OUTPUT: «A␤B␤C␤»
say $_ if /A/ ff^ /C/ for @list;   # OUTPUT: «A␤B␤»</pre>
<p>The sed-like version can be found in <a href="/Documentable/integration-test/routine/fff$CIRCUMFLEX_ACCENT">fff^</a>.</p>
<p>This operator cannot be overloaded, as it&#39;s handled specially by the compiler.</p>
<h2 id="infix_^ff^"><a class="u" href="#___top" title="go to top of document">infix <code>^ff^</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;^ff^&gt;(Mu $a, Mu $b)</pre>
<p>Works like <a href="/Documentable/integration-test/routine/ff">ff</a>, except it does not return <code>True</code> for items matching either the stop or start condition (or both).</p>
<pre class="pod-block-code">my @list = &lt;A B C&gt;;
say $_ if /A/ ff /C/ for @list;    # OUTPUT: «A␤B␤C␤»
say $_ if /A/ ^ff^ /C/ for @list;  # OUTPUT: «B␤»</pre>
<p>The sed-like version can be found in <a href="/Documentable/integration-test/routine/$CIRCUMFLEX_ACCENTfff$CIRCUMFLEX_ACCENT"><code>^fff^</code></a>.</p>
<p>This operator cannot be overloaded, as it&#39;s handled specially by the compiler.</p>
<h2 id="infix_fff"><a class="u" href="#___top" title="go to top of document">infix <code>fff</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;fff&gt;(Mu $a, Mu $b)</pre>
<p>Performs a sed-like flipflop operation, wherein it returns <code>False</code> until the left argument smartmatches against <code>$_</code>, then returns <code>True</code> until the right argument smartmatches against <code>$_</code>.</p>
<p>Works similarly to <a href="/Documentable/integration-test/routine/ff">ff</a>, except that it only tries one argument per invocation. That is, if <code>$_</code> smartmatches the left argument, <code>fff</code> will <strong>not</strong> then try to match that same <code>$_</code> against the right argument.</p>
<pre class="pod-block-code">for &lt;AB C D B E F&gt; {
    say $_ if /A/ fff /B/;         # OUTPUT: «AB␤C␤D␤B␤»
}</pre>
<p>The non-sed-like flipflop (which after successfully matching the left argument against <code>$_</code> will try that same <code>$_</code> against the right argument and act accordingly). See <a href="/Documentable/integration-test/routine/ff">ff</a>.</p>
<p>This operator cannot be overloaded, as it&#39;s handled specially by the compiler.</p>
<h2 id="infix_^fff"><a class="u" href="#___top" title="go to top of document">infix <code>^fff</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;^fff&gt;(Mu $a, Mu $b)</pre>
<p>Like <a href="/Documentable/integration-test/routine/fff">fff</a>, except it does not return true for matches to the left argument.</p>
<pre class="pod-block-code">my @list = &lt;A B C&gt;;
say $_ if /A/ fff /C/ for @list;   # OUTPUT: «A␤B␤C␤»
say $_ if /A/ ^fff /C/ for @list;  # OUTPUT: «B␤C␤»</pre>
<p>For the non-sed version, see <a href="/Documentable/integration-test/routine/$CIRCUMFLEX_ACCENTff"><code>^ff</code></a>.</p>
<p>This operator cannot be overloaded, as it&#39;s handled specially by the compiler.</p>
<h2 id="infix_fff^"><a class="u" href="#___top" title="go to top of document">infix <code>fff^</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;fff^&gt;(Mu $a, Mu $b)</pre>
<p>Like <a href="/Documentable/integration-test/routine/fff">fff</a>, except it does not return true for matches to the right argument.</p>
<pre class="pod-block-code">my @list = &lt;A B C&gt;;
say $_ if /A/ fff /C/ for @list;   # OUTPUT: «A␤B␤C␤»
say $_ if /A/ fff^ /C/ for @list;  # OUTPUT: «A␤B␤»</pre>
<p>For the non-sed version, see <a href="/Documentable/integration-test/routine/ff$CIRCUMFLEX_ACCENT">ff^</a>.</p>
<p>This operator cannot be overloaded, as it&#39;s handled specially by the compiler.</p>
<h2 id="infix_^fff^"><a class="u" href="#___top" title="go to top of document">infix <code>^fff^</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;^fff^&gt;(Mu $a, Mu $b)</pre>
<p>Like <a href="/Documentable/integration-test/routine/fff">fff</a>, except it does not return true for matches to either the left or right argument.</p>
<pre class="pod-block-code">my @list = &lt;A B C&gt;;
say $_ if /A/ fff /C/ for @list;   # OUTPUT: «A␤B␤C␤»
say $_ if /A/ ^fff^ /C/ for @list; # OUTPUT: «B␤»</pre>
<p>For the non-sed version, see <a href="/Documentable/integration-test/routine/$CIRCUMFLEX_ACCENTff$CIRCUMFLEX_ACCENT"><code>^ff^</code></a>.</p>
<p>This operator cannot be overloaded, as it&#39;s handled specially by the compiler.</p>
<h1 id="Item_assignment_precedence"><a class="u" href="#___top" title="go to top of document">Item assignment precedence</a></h1>
<p><a name="Documentable/integration-test/index-entry-item_="></a></p>
<h2 id="infix_=_(item_assignment)"><a class="u" href="#___top" title="go to top of document">infix <code>=</code> (item assignment)</a></h2>
<pre class="pod-block-code">    sub infix:&lt;=&gt;(Mu $a is rw, Mu $b)
</pre>
<p>Called the <em>item assignment operator</em>. It copies the value of the right-hand side into the Scalar container on the left-hand side.</p>
<p>The item assignment operator should be distinguished from the <a href="/Documentable/integration-test/language/operators#infix_=_(list assignment)">list assignment operator</a>, which uses the same operator symbol <code>=</code> but has a lower precedence. The context of the left-hand side of the <code>=</code> symbol determines whether it is parsed as item assignment or list assignment. See the section on <a href="/Documentable/integration-test/language/variables#Item_and_list_assignment">item and list assignment</a> for a comparative discussion of the two assignment types.</p>
<h2 id="infix_=>"><a class="u" href="#___top" title="go to top of document">infix <code>=&gt;</code></a></h2>
<pre class="pod-block-code">sub infix:«=&gt;»($key, Mu $value --&gt; Pair:D)</pre>
<p><a href="/Documentable/integration-test/type/Pair">Pair</a> constructor.<a name="Documentable/integration-test/index-entry-pair_constructor"></a></p>
<p>Constructs a <a href="/Documentable/integration-test/type/Pair">Pair</a> object with the left-hand side as the key and the right-hand side as the value.</p>
<p>Note that the <code>=&gt; </code> operator is syntactically special-cased, in that it allows unquoted identifier on the left-hand side.</p>
<pre class="pod-block-code">my $p = a =&gt; 1;
say $p.key;         # OUTPUT: «a␤»
say $p.value;       # OUTPUT: «1␤»</pre>
<p>A <a href="/Documentable/integration-test/type/Pair">Pair</a> within an argument list with an unquoted identifier on the left is interpreted as a named argument.</p>
<p>See <a href="/Documentable/integration-test/language/terms#Pair">the Terms language documentation</a> for more ways to create <code>Pair</code> objects.</p>
<h1 id="Loose_unary_precedence"><a class="u" href="#___top" title="go to top of document">Loose unary precedence</a></h1>
<h2 id="prefix_not"><a class="u" href="#___top" title="go to top of document">prefix <code>not</code></a></h2>
<pre class="pod-block-code">multi sub prefix:&lt;not&gt;(Mu $x --&gt; Bool:D)</pre>
<p>Evaluates its argument in boolean context (and thus collapses <a href="/Documentable/integration-test/type/Junction">Junction</a>s), and negates the result. Please note that <code>not</code> is easy to misuse. See <a href="/Documentable/integration-test/language/traps#Loose_boolean_operators">traps</a>.</p>
<h2 id="prefix_so"><a class="u" href="#___top" title="go to top of document">prefix <code>so</code></a></h2>
<pre class="pod-block-code">multi sub prefix:&lt;so&gt;(Mu $x --&gt; Bool:D)</pre>
<p>Evaluates its argument in boolean context (and thus collapses <a href="/Documentable/integration-test/type/Junction">Junction</a>s), and returns the result.</p>
<h1 id="Comma_operator_precedence"><a class="u" href="#___top" title="go to top of document">Comma operator precedence</a></h1>
<h2 id="infix_,"><a class="u" href="#___top" title="go to top of document">infix <code>,</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;,&gt;(*@a --&gt; List:D) is assoc&lt;list&gt;</pre>
<p>Constructs a higher-order <a href="/Documentable/integration-test/type/Cool">Cool</a> from its arguments.</p>
<pre class="pod-block-code">my @list = :god(&#39;Þor&#39;), [&#39;is&#39;,&quot;mighty&quot;];
say @list;      # OUTPUT: «[god =&gt; Þor [is mighty]]␤»
my %hash = :god(&#39;Þor&#39;), :is(&quot;mighty&quot;);
say %hash.raku; # OUTPUT: «{:god(&quot;Þor&quot;), :is(&quot;mighty&quot;)}␤»
my %a = :11a, :22b;
say %(%a, :33x);  # OUTPUT: «{a =&gt; 11, b =&gt; 22, x =&gt; 33}␤»</pre>
<p>In the first case it returns a <a href="/Documentable/integration-test/type/List">List</a>, in the second case, since the arguments are <a href="/Documentable/integration-test/type/Pair">Pair</a>s, it builds a <a href="/Documentable/integration-test/type/Hash">Hash</a>.</p>
<p>It can also be used for constructing variables from other variables, collating elements of different types, in this case a <a href="/Documentable/integration-test/type/Hash">Hash</a> and a <a href="/Documentable/integration-test/type/Pair">Pair</a>:</p>
<pre class="pod-block-code">my %features = %hash, :wields(&quot;hammer&quot;);
say %features;  # OUTPUT: «{god =&gt; Þor, is =&gt; mighty, wields =&gt; hammer}␤»
</pre>
<p>The comma is also used syntactically as the separator of arguments in calls.</p>
<h2 id="infix_:"><a class="u" href="#___top" title="go to top of document">infix <code>:</code></a></h2>
<p>Used as an argument separator just like infix <code>,</code> and marks the argument to its left as the invocant. That turns what would otherwise be a function call into a method call.</p>
<pre class="pod-block-code">substr(&#39;abc&#39;: 1);       # same as &#39;abc&#39;.substr(1)</pre>
<p>Infix <code>:</code> is only allowed after the first argument of a non-method call. In other positions, it&#39;s a syntax error.</p>
<h1 id="List_infix_precedence"><a class="u" href="#___top" title="go to top of document">List infix precedence</a></h1>
<h2 id="infix_Z"><a class="u" href="#___top" title="go to top of document">infix <code>Z</code></a></h2>
<pre class="pod-block-code">sub infix:&lt;Z&gt;(**@lists --&gt; Seq:D) is assoc&lt;list&gt;</pre>
<p>The <a name="Documentable/integration-test/index-entry-Zip_operator"><span class="index-entry">Zip operator</span></a> interleaves the lists passed to <code>Z</code> like a zipper, taking index-corresponding elements from each operand. The returned <code>Seq</code> contains nested lists, each with a value from every operand in the chain. If one of the operands runs out of elements prematurely, the zip operator will stop.</p>
<pre class="pod-block-code">say (1, 2 Z &lt;a b c&gt; Z &lt;+ -&gt;).raku;
# OUTPUT: «((1, &quot;a&quot;, &quot;+&quot;), (2, &quot;b&quot;, &quot;-&quot;)).Seq␤»
for &lt;a b c&gt; Z &lt;1 2 3 4&gt; -&gt; [$l, $r] {
    say &quot;$l:$r&quot;
}
# OUTPUT: «a:1␤b:2␤c:3␤»
</pre>
<p>The <code>Z</code> operator also exists as a metaoperator, in which case the inner lists are replaced by the value from applying the operator to the list:</p>
<pre class="pod-block-code">say 100, 200 Z+ 42, 23;             # OUTPUT: «(142 223)␤»
say 1..3 Z~ &lt;a b c&gt; Z~ &#39;x&#39; xx 3;    # OUTPUT: «(1ax 2bx 3cx)␤»</pre>
<p>As any other infix operator, it can be used under its full name:</p>
<pre class="pod-block-code">say infix:&lt;Z&gt;(&lt;a b&gt;,&lt;c d&gt;);             # OUTPUT: «((a c) (b d))␤»
</pre>
<p>If no argument is given, it will return an empty <code>Seq</code></p>
<pre class="pod-block-code">say infix:&lt;Z&gt;();                        # OUTPUT: «()␤»
</pre>
<p><a name="Documentable/integration-test/index-entry-cross_product_operator"></a> <a name="Documentable/integration-test/index-entry-X_operators"></a></p>
<h2 id="infix_X"><a class="u" href="#___top" title="go to top of document">infix <code>X</code></a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub infix:&lt;X&gt;(+lol, :&amp;with! --&gt; Seq:D)
multi sub infix:&lt;X&gt;(+lol --&gt; Seq:D)</pre>
<p>Creates a cross product from all the lists, ordered so that the rightmost elements vary most rapidly, and returns a <code>Seq</code>:</p>
<pre class="pod-block-code">1..3 X &lt;a b c&gt; X 9
# produces ((1 a 9) (1 b 9) (1 c 9)
#           (2 a 9) (2 b 9) (2 c 9)
#           (3 a 9) (3 b 9) (3 c 9))</pre>
<p>The <code>X</code> operator also exists as a metaoperator, in which case the inner lists are replaced by the value from applying the operator to the list:</p>
<pre class="pod-block-code">1..3 X~ &lt;a b c&gt; X~ 9
# produces (1a9 1b9 1c9 2a9 2b9 2c9 3a9 3b9 3c9)</pre>
<h2 id="infix_..."><a class="u" href="#___top" title="go to top of document">infix <code>...</code> <a name="Documentable/integration-test/index-entry-..._operators"></a><a name="Documentable/integration-test/index-entry-...$CIRCUMFLEX_ACCENT_operators"></a><a name="Documentable/integration-test/index-entry-…_operators"></a><a name="Documentable/integration-test/index-entry-…$CIRCUMFLEX_ACCENT_operators"></a> <a name="Documentable/integration-test/index-entry-lazy_list_…"></a></a></h2>
<pre class="pod-block-code">multi sub infix:&lt;...&gt;(**@) is assoc&lt;list&gt;
multi sub infix:&lt;...^&gt;(**@) is assoc&lt;list&gt;</pre>
<p>The <a name="Documentable/integration-test/index-entry-sequence_operator"><span class="index-entry">sequence operator</span></a>, which can be written either as <code>...</code> or as <code>…</code> (with variants <code>...^</code> and <code>…^</code>) will produce (possibly lazy) generic sequences on demand.</p>
<p>The left-hand side will always include the initial elements; it may include a generator too (after the first element or elements). The right-hand side will have an endpoint, which can be <code>Inf</code> or <code>*</code> for &quot;infinite&quot; lists (that is, <em>lazy</em> lists whose elements are only produced on demand), an expression which will end the sequence when <code>True</code>, or other elements such as <a href="/Documentable/integration-test/type/Junction">Junctions</a>.</p>
<p>The sequence operator invokes the generator with as many arguments as necessary. The arguments are taken from the initial elements and the already generated elements. The default generator is <code>*.</code><a href="/Documentable/integration-test/routine/succ">succ</a> or <code>*.</code><a href="/Documentable/integration-test/routine/pred">pred</a>, depending on how the end points compare:</p>
<pre class="pod-block-code">say 1 ... 4;        # OUTPUT: «(1 2 3 4)␤»
say 4 ... 1;        # OUTPUT: «(4 3 2 1)␤»
say &#39;a&#39; ... &#39;e&#39;;    # OUTPUT: «(a b c d e)␤»
say &#39;e&#39; ... &#39;a&#39;;    # OUTPUT: «(e d c b a)␤»</pre>
<p>An endpoint of <code>*</code> (<a href="/Documentable/integration-test/type/Whatever">Whatever</a>), <code>Inf</code> or <code>∞</code> generates on demand an infinite sequence, with a default generator of <code>*.succ</code></p>
<pre class="pod-block-code">say (1 ... *)[^5];  # OUTPUT: «(1 2 3 4 5)␤»</pre>
<p>Custom generators need to be the last element of the list before the &#39;...&#39; operator. This one takes two arguments, and generates the eight first Fibonacci numbers</p>
<pre class="pod-block-code">say (1, 1, -&gt; $a, $b { $a + $b } ... *)[^8]; # OUTPUT: «(1 1 2 3 5 8 13 21)␤»
# same but shorter
say (1, 1, * + * ... *)[^8];                 # OUTPUT: «(1 1 2 3 5 8 13 21)␤»
</pre>
<p>Of course the generator can also take only one argument.</p>
<pre class="pod-block-code">say 5, { $_ * 2 } ... 40;                # OUTPUT: «5 10 20 40␤»</pre>
<p>There must be at least as many initial elements as arguments to the generator.</p>
<p>Without a generator and with more than one initial element and all initial elements numeric, the sequence operator tries to deduce the generator. It knows about arithmetic and geometric sequences.</p>
<pre class="pod-block-code">say 2, 4, 6 ... 12;     # OUTPUT: «(2 4 6 8 10 12)␤»
say 1, 2, 4 ... 32;     # OUTPUT: «(1 2 4 8 16 32)␤»</pre>
<p>If the endpoint is not <code>*</code>, it&#39;s smartmatched against each generated element and the sequence is terminated when the smartmatch succeeded. For the <code>...</code> operator, the final element is included, for the <code>...^</code> operator it&#39;s excluded.</p>
<p>This allows you to write</p>
<pre class="pod-block-code">say 1, 1, * + * ...^ *&gt;= 100;</pre>
<p>to generate all Fibonacci numbers up to but excluding 100.</p>
<p>The <code>...</code> operators consider the initial values as &quot;generated elements&quot; as well, so they are also checked against the endpoint:</p>
<pre class="pod-block-code">my $end = 4;
say 1, 2, 4, 8, 16 ... $end;
# OUTPUT: «(1 2 4)␤»</pre>
<h1 id="List_prefix_precedence"><a class="u" href="#___top" title="go to top of document">List prefix precedence</a></h1>
<p><a name="Documentable/integration-test/index-entry-list_="></a> <a name="Documentable/integration-test/index-entry-List_assignment_operator"></a></p>
<h2 id="infix_=_(list_assignment)"><a class="u" href="#___top" title="go to top of document">infix <code>=</code> (list assignment)</a></h2>
<p>The list assignment operator generally copies values from its right-hand side into the container on its left-hand side. Its exact semantics are left to the left-hand side container type. See <a href="/Documentable/integration-test/type/Array">Array</a> and <a href="/Documentable/integration-test/type/Hash">Hash</a> for common cases.</p>
<p>The list assignment operator should be distinguished from the <a href="/Documentable/integration-test/language/operators#infix_=_(item assignment)">item assignment operator</a>, which uses the same operator symbol <code>=</code> but has a higher precedence. The context of the left-hand side of the <code>=</code> symbol determines whether it is parsed as item assignment or list assignment. See the section on <a href="/Documentable/integration-test/language/variables#Item_and_list_assignment">item and list assignment</a> for a comparative discussion of the two assignment types.</p>
<h2 id="infix_:="><a class="u" href="#___top" title="go to top of document">infix <code>:=</code></a></h2>
<p><a name="Documentable/integration-test/index-entry-Binding_operator"><span class="index-entry">Binding operator</span></a>. Whereas <code>$x = $y</code> puts the value in <code>$y</code> into <code>$x</code>, <code>$x := $y</code> makes <code>$x</code> and <code>$y</code> the same thing.</p>
<pre class="pod-block-code">my $a = 42;
my $b = $a;
$b++;
say $a;</pre>
<p>This will output 42, because <code>$a</code> and <code>$b</code> both contained the number <code>42</code>, but the <a href="/Documentable/integration-test/language/containers#Binding">containers</a> were different.</p>
<pre class="pod-block-code">my $a = 42;
my $b := $a;
$b++;
say $a;</pre>
<p>This will output 43, since <code>$b</code> and <code>$a</code> both represented the same object.</p>
<p>If type constrains on variables or containers are present a type check will be performed at runtime. On failure <code>X::TypeCheck::BindingType</code> will be thrown.</p>
<p>Please note that <code>:=</code> is a compile time operator. As such it can not be referred to at runtime and thus can&#39;t be used as an argument to metaoperators.</p>
<h2 id="infix_::="><a class="u" href="#___top" title="go to top of document">infix <code>::=</code></a></h2>
<p><a name="Documentable/integration-test/index-entry-Read-only_binding_operator"><span class="index-entry">Read-only binding operator</span></a>, not yet implemented in Rakudo. See <a href="/Documentable/integration-test/routine/:="><code>infix :=</code></a>.</p>
<p><a name="Documentable/integration-test/index-entry-stub_operator"></a></p>
<h2 id="listop_..."><a class="u" href="#___top" title="go to top of document">listop <code>...</code></a></h2>
<p>Called the <em>yada, yada, yada</em> operator or <em>stub</em> operator, if it&#39;s the only statement in a routine or type, it marks that routine or type as a stub (which is significant in the context of pre-declaring types and composing roles).</p>
<p>If the <code>...</code> statement is executed, it calls <a href="/Documentable/integration-test/routine/fail">fail</a>, with the default message <code>Stub code executed</code>.</p>
<p><a name="Documentable/integration-test/index-entry-Fatal_stub_operator"></a></p>
<h2 id="listop_!!!"><a class="u" href="#___top" title="go to top of document">listop <code>!!!</code></a></h2>
<p>If it&#39;s the only statement in a routine or type, it marks that routine or type as a stub (which is significant in the context of pre-declaring types and composing roles).</p>
<p>If the <code>!!!</code> statement is executed, it calls <a href="/Documentable/integration-test/routine/die">die</a>, with the default message <code>Stub code executed</code>.</p>
<p><a name="Documentable/integration-test/index-entry-Admonitory_stub_operator"></a></p>
<h2 id="listop_???"><a class="u" href="#___top" title="go to top of document">listop <code>???</code></a></h2>
<p>If it&#39;s the only statement in a routine or type, it marks that routine or type as a stub (which is significant in the context of pre-declaring types and composing roles).</p>
<p>If the <code>???</code> statement is executed, it calls <a href="/Documentable/integration-test/routine/warn">warn</a>, with the default message <code>Stub code executed</code>.</p>
<h2 id="Reduction_operators"><a class="u" href="#___top" title="go to top of document">Reduction operators</a></h2>
<p>Any infix operator (except for non-associating operators) can be surrounded by square brackets in term position to create a list operator that reduces using that operation.</p>
<pre class="pod-block-code">say [+] 1, 2, 3;      # 1 + 2 + 3 = 6
my @a = (5, 6);
say [*] @a;           # 5 * 6 = 30</pre>
<p>Reduction operators have the same associativity as the operators they are based on.</p>
<pre class="pod-block-code">say [-] 4, 3, 2;      # 4-3-2 = (4-3)-2 = -1
say [**] 4, 3, 2;     # 4**3**2 = 4**(3**2) = 262144</pre>
<p>Applying [+] to a single element will return that element</p>
<pre class="pod-block-code">say [+] 42;           # OUTPUT: «42␤»
</pre>
<h1 id="Loose_AND_precedence"><a class="u" href="#___top" title="go to top of document">Loose AND precedence</a></h1>
<h2 id="infix_and"><a class="u" href="#___top" title="go to top of document">infix <a name="Documentable/integration-test/index-entry-and"><span class="index-entry"><code>and</code></span></a></a></h2>
<p>Same as <a href="/Documentable/integration-test/language/operators#infix_%26%26">infix &amp;&amp;</a>, except with looser precedence.</p>
<p>Short-circuits so that it returns the first operand that evaluates to <code>False</code>, otherwise returns the last operand. Note that <code>and</code> is easy to misuse, see <a href="/Documentable/integration-test/language/traps#Loose_boolean_operators">traps</a>.</p>
<h2 id="infix_andthen"><a class="u" href="#___top" title="go to top of document">infix <a name="Documentable/integration-test/index-entry-andthen"><span class="index-entry"><code>andthen</code></span></a></a></h2>
<p>The <code>andthen</code> operator returns <a href="/Documentable/integration-test/type/Slip#index-entry-Empty-Empty"><code>Empty</code></a> upon encountering the first <a href="/Documentable/integration-test/routine/defined">undefined</a> argument, otherwise the last argument. Last argument is returned as-is, without being checked for definedness at all. Short-circuits. The result of the left side is bound to <code>$_</code> for the right side, or passed as arguments if the right side is a <a href="/Documentable/integration-test/type/Callable"><code>Callable</code></a>, whose <a href="/Documentable/integration-test/routine/count">count</a> must be <code>0</code> or <code>1</code>.</p>
<p>A handy use of this operator is to alias a routine&#39;s return value to <code>$_</code> and to do additional manipulation with it, such as printing or returning it to caller. Since the <code>andthen</code> operator short-circuits, statements on the right-hand side won&#39;t get executed, unless left-hand side is defined (tip: <a href="/Documentable/integration-test/type/Failure">Failures</a> are never defined, so you can handle them with this operator).</p>
<pre class="pod-block-code">sub load-data {
    rand  &gt; .5 or return; # simulated load data failure; return Nil
    (rand &gt; .3 ?? &#39;error&#39; !! &#39;good data&#39;) xx 10 # our loaded data
}
load-data.first: /good/ andthen say &quot;$_ is good&quot;;
# OUTPUT: «(good data is good)␤»

load-data() andthen .return; # return loaded data, if it&#39;s defined
die &quot;Failed to load data!!&quot;;</pre>
<p>The above example will print <code>good data is good</code> only if the subroutine returned any items that match <code>/good/</code> and will die unless loading data returned a defined value. The aliasing behavior lets us pipe the values across the operator.</p>
<p>The <code>andthen</code> operator is a close relative of <a href="/Documentable/integration-test/syntax/with orwith without"><code>with</code> statement modifier</a>, and some compilers compile <code>with</code> to <code>andthen</code>, meaning these two lines have equivalent behavior:</p>
<pre class="pod-block-code">.say with 42;
42 andthen .say;</pre>
<h2 id="infix_notandthen"><a class="u" href="#___top" title="go to top of document">infix <a name="Documentable/integration-test/index-entry-notandthen"><span class="index-entry"><code>notandthen</code></span></a></a></h2>
<p>The <code>notandthen</code> operator returns <a href="/Documentable/integration-test/type/Slip#index-entry-Empty-Empty"><code>Empty</code></a> upon encountering the first <a href="/Documentable/integration-test/routine/defined">defined</a> argument, otherwise the last argument. Last argument is returned as-is, without being checked for definedness at all. Short-circuits. The result of the left side is bound to <code>$_</code> for the right side, or passed as arguments if the right side is a <a href="/Documentable/integration-test/type/Callable"><code>Callable</code></a>, whose <a href="/Documentable/integration-test/routine/count">count</a> must be <code>0</code> or <code>1</code>.</p>
<p>At first glance, <a href="/Documentable/integration-test/routine/notandthen">notandthen</a> might appear to be the same thing as the <a href="/Documentable/integration-test/routine/orelse">orelse</a> operator. The difference is subtle: <a href="/Documentable/integration-test/routine/notandthen">notandthen</a> returns <a href="/Documentable/integration-test/type/Slip#index-entry-Empty-Empty"><code>Empty</code></a> when it encounters a <a href="/Documentable/integration-test/routine/defined">defined</a> item (that isn&#39;t the last item), whereas <a href="/Documentable/integration-test/routine/orelse">orelse</a> returns that item. In other words, <a href="/Documentable/integration-test/routine/notandthen">notandthen</a> is a means to act when items aren&#39;t defined, whereas <a href="/Documentable/integration-test/routine/orelse">orelse</a> is a means to obtain the first defined item:</p>
<pre class="pod-block-code">sub all-sensors-down     { [notandthen] |@_, True             }
sub first-working-sensor { [orelse]     |@_, &#39;default sensor&#39; }

all-sensors-down Nil, Nil, Nil
  and say &#39;OMG! All sensors are down!&#39;; # OUTPUT:«OMG! All sensors are down!␤»
say first-working-sensor Nil, Nil, Nil; # OUTPUT:«default sensor␤»

all-sensors-down Nil, 42, Nil
  and say &#39;OMG! All sensors are down!&#39;; # No output
say first-working-sensor Nil, 42, Nil;  # OUTPUT:«42␤»
</pre>
<p>The <code>notandthen</code> operator is a close relative of <a href="/Documentable/integration-test/syntax/with orwith without"><code>without</code> statement modifier</a>, and some compilers compile <code>without</code> to <code>notandthen</code>, meaning these two lines have equivalent behavior:</p>
<pre class="pod-block-code">sub good-things { fail }

&#39;boo&#39;.say without good-things;
good-things() notandthen &#39;boo&#39;.say;
</pre>
<h1 id="Loose_OR_precedence"><a class="u" href="#___top" title="go to top of document">Loose OR precedence</a></h1>
<h2 id="infix_or"><a class="u" href="#___top" title="go to top of document">infix <code>or</code></a></h2>
<p>Same as <a href="/Documentable/integration-test/routine/||">infix <code>||</code></a>, except with looser precedence.</p>
<p>Returns the first argument that evaluates to <code>True</code> in boolean context, or otherwise the last argument, it short-circuits. Please note that <code>or</code> is easy to misuse. See <a href="/Documentable/integration-test/language/traps#Loose_boolean_operators">traps</a>.</p>
<p><a name="Documentable/integration-test/index-entry-orelse"></a></p>
<h2 id="infix_orelse"><a class="u" href="#___top" title="go to top of document">infix <code>orelse</code></a></h2>
<p>The <code>orelse</code> operator is similar to <code>infix //</code>, except with looser precedence and <code>$_</code> aliasing.</p>
<p>Returns the first defined argument, or else the last argument. Last argument is returned as-is, without being checked for definedness at all. Short-circuits. The result of the left side is bound to <code>$_</code> for the right side, or passed as an argument if the right side is a <a href="/Documentable/integration-test/type/Callable"><code>Callable</code></a>, whose <a href="/Documentable/integration-test/routine/count">count</a> must be <code>0</code> or <code>1</code>.</p>
<p>This operator is useful for handling <a href="/Documentable/integration-test/type/Failure">Failures</a> returned by routines since the expected value is usually <a href="/Documentable/integration-test/routine/defined">defined</a> and <a href="/Documentable/integration-test/type/Failure">Failure</a> never is:</p>
<pre class="pod-block-code">sub meows { ++$ &lt; 4 ?? fail &#39;out of meows!&#39; !! &#39;🐱&#39; }

sub meows-processor1 { meows() orelse .return } # return handled Failure
sub meows-processor2 { meows() orelse fail $_ } # return re-armed Failure
sub meows-processor3 {
    # Use non-Failure output, or else print a message that stuff&#39;s wrong
    meows() andthen .say orelse ‘something&#39;s wrong’.say;
}

say &quot;{.^name}, {.handled}&quot;  # OUTPUT: «Failure, True␤»
    given meows-processor1;
say &quot;{.^name}, {.handled}&quot;  # OUTPUT: «Failure, False␤»
    given meows-processor2;
meows-processor3;           # OUTPUT: «something&#39;s wrong␤»
meows-processor3;           # OUTPUT: «🐱␤»</pre>
<h2 id="infix_xor"><a class="u" href="#___top" title="go to top of document">infix <code>xor</code></a></h2>
<p>Same as <a href="/Documentable/integration-test/routine/$CIRCUMFLEX_ACCENT$CIRCUMFLEX_ACCENT">infix <code>^^</code></a>, except with looser precedence.</p>
<p>Returns the operand that evaluates to <code>True</code> in boolean context, if and only if the other operand evaluates to <code>False</code> in boolean context. If both operands evaluate to <code>False</code>, returns the last argument. If both operands evaluate to <code>True</code>, returns <code>Nil</code>.</p>
<p>When chaining, returns the operand that evaluates to <code>True</code>, if and only if there is one such operand. If more than one operand is true, it short-circuits after evaluating the second and returns <code>Nil</code>. If all operands are false, returns the last one.</p>
<h1 id="Sequencer_precedence"><a class="u" href="#___top" title="go to top of document">Sequencer precedence</a></h1>
<h2 id="infix_==>"><a class="u" href="#___top" title="go to top of document">infix <code>==&gt;</code></a></h2>
<p>This <a name="Documentable/integration-test/index-entry-feed"><span class="index-entry">feed</span></a> operator takes the result from the left and passes it to the next (right) routine as the last parameter.</p>
<pre class="pod-block-code">my @array = (1, 2, 3, 4, 5);
@array ==&gt; sum() ==&gt; say();   # OUTPUT: «15␤»</pre>
<p>This simple example, above, is the equivalent of writing:</p>
<pre class="pod-block-code">my @array = (1, 2, 3, 4, 5);
say(sum(@array));             # OUTPUT: «15␤»</pre>
<p>Or if using methods:</p>
<pre class="pod-block-code">my @array = (1, 2, 3, 4, 5);
@array.sum.say;               # OUTPUT: «15␤»</pre>
<p>The precedence is very loose so you will need to use parentheses to assign the result or you can even just use another feed operator! In the case of routines/methods that take a single argument or where the first argument is a block, it&#39;s often required that you call with parentheses (though this is not required for the very last routine/method).</p>
<p>This &quot;traditional&quot; structure, read bottom-to-top, with the last two lines creating the data structure that is going to be processed</p>
<pre class="pod-block-code">my @fractions = &lt;TWO THREE FOUR FIVE SEVEN&gt; »~» &quot; &quot; X~ &lt;FIFTHS SIXTHS EIGHTHS&gt;;
my @result = map { .uniparse },                    # (3) Converts to unicode
    grep { .uniparse },                            # (2) Checks if it parses
    map( {&quot;VULGAR FRACTION &quot; ~ $^þ }, @fractions); # (1) Adds string to input

# @result is [⅖ ⅗ ⅜ ⅘ ⅚ ⅝ ⅞]</pre>
<p>Now we use the feed operator (left-to-right) with parentheses, read top-to-bottom</p>
<pre class="pod-block-code">my @result = (
    &lt;TWO THREE FOUR FIVE SEVEN&gt; »~» &quot; &quot; X~ &lt;FIFTHS SIXTHS EIGHTHS&gt; # (1) Input
    ==&gt; map( {&quot;VULGAR FRACTION &quot; ~ $^þ } )                         # (2) Converts to Unicode name
    ==&gt; grep({ .uniparse })                                        # (3) Filters only real names
    ==&gt; map( { .uniparse} );                                       # (4) Converts to unicode
);</pre>
<p>For illustration, method chaining equivalent, read top-to-bottom, using the same sequence as above</p>
<pre class="pod-block-code">my @result = ( &lt;TWO THREE FOUR FIVE SEVEN&gt; »~» &quot; &quot; X~ &lt;FIFTHS SIXTHS EIGHTHS&gt;)
    .map( {&quot;VULGAR FRACTION &quot; ~ $^þ } )
    .grep({ .uniparse })
    .map({ .uniparse });</pre>
<p>Although in this particular case the result is the same, the feed operator <code>==&gt;</code> more clearly shows intent with arrow pointing in the direction of the data flow. To assign without the need of parentheses use another feed operator</p>
<pre class="pod-block-code">my @result;
&lt;people of earth&gt;
    ==&gt; map({ .tc })
    ==&gt; grep /&lt;[PE]&gt;/
    ==&gt; sort()
    ==&gt; @result;</pre>
<p>It can be useful to capture a partial result, however, unlike the leftward feed operator, it does require parentheses or a semicolon</p>
<pre class="pod-block-code">my @result;
&lt;people of earth&gt;
    ==&gt; map({ .tc })
    ==&gt; my @caps; @caps   # also could wrap in parentheses instead
    ==&gt; grep /&lt;[PE]&gt;/
    ==&gt; sort()
    ==&gt; @result;</pre>
<p>The feed operator lets you construct method-chaining-like patterns out of routines and the results of methods on unrelated data. In method-chaining, you are restricted to the methods available on the data or the result of previous method call. With feed operators, that restriction is gone. The resulting code could also be seen to be more readable than a series of method calls broken over multiple lines.</p>
<p>Note: In the future, this operator will see some change as it gains the ability to run list operations in parallel. It will enforce that the <strong>left</strong> operand is enclosable as a closure (that can be cloned and run in a subthread).</p>
<h2 id="infix_<=="><a class="u" href="#___top" title="go to top of document">infix <code>&lt;==</code></a></h2>
<p>This <a name="Documentable/integration-test/index-entry-leftward_feed"><span class="index-entry">leftward feed</span></a> operator takes the result from the right and passes it to the previous (left) routine as the last parameter. This elucidates the right-to-left dataflow for a series of list manipulating functions.</p>
<pre class="pod-block-code"># Traditional structure, read bottom-to-top
my @result =
    sort                   # (4) Sort, result is &lt;Earth People&gt;
    grep { /&lt;[PE]&gt;/ },     # (3) Look for P or E
    map { .tc },           # (2) Capitalize the words
    &lt;people of earth&gt;;     # (1) Start with the input

# Feed (right-to-left) with parentheses, read bottom-to-top
my @result = (
    sort()                 # (4) Sort, result is &lt;Earth People&gt;
    &lt;== grep({ /&lt;[PE]&gt;/ }) # (3) Look for P or E
    &lt;== map({ .tc })       # (2) Capitalize the words
    &lt;== &lt;people of earth&gt;  # (1) Start with the input
);

# To assign without parentheses, use another feed operator
my @result
    &lt;== sort()              # (4) Sort, result is &lt;Earth People&gt;
    &lt;== grep({ /&lt;[PE]&gt;/ })  # (3) Look for P or E
    &lt;== map({ .tc })        # (2) Capitalize the words
    &lt;== &lt;people of earth&gt;;  # (1) Start with the input

# It can be useful to capture a partial result
my @result
    &lt;== sort()
    &lt;== grep({ /&lt;[PE]&gt;/ })
    &lt;== my @caps            # unlike ==&gt;, there&#39;s no need for additional statement
    &lt;== map({ .tc })
    &lt;== &lt;people of earth&gt;;</pre>
<p>Unlike the rightward feed operator, the result is not closely mappable to method-chaining. However, compared to the traditional structure above where each argument is separated by a line, the resulting code is more demonstrative than commas. The leftward feed operator also allows you to &quot;break into&quot; the statement and capture an intermediary result which can be extremely useful for debugging or to take that result and create another variation on the final result.</p>
<p>Note: In the future, this operator will see some change as it gains the ability to run list operations in parallel. It will enforce that the <strong>right</strong> operand is enclosable as a closure (that can be cloned and run in a subthread).</p>
<h1 id="Identity"><a class="u" href="#___top" title="go to top of document">Identity</a></h1>
<p>In general, infix operators can be applied to a single or no element without yielding an error, generally in the context of a <a href="/Documentable/integration-test/routine/reduce">reduce</a> operation.</p>
<pre class="pod-block-code">say [-] ()  # OUTPUT: «0␤»</pre>
<p>The design documents specify that this should return <a href="https://en.wikipedia.org/wiki/Identity_element">an identity value</a>, and that an identity value <a href="http://design.raku.org/S03.html#Reduction_operators">must be specified for every operator</a>. In general, the identity element returned should be intuitive. However, here is a table that specifies how it is defined for operator classes in Raku, which corresponds to the table in the above definition in the types and operators defined by the language:</p>
<table class="pod-table">
<thead><tr>
<th>Operator class</th> <th>Identity value</th>
</tr></thead>
<tbody>
<tr> <td>Equality</td> <td>Bool::True</td> </tr> <tr> <td>Arithmetic +</td> <td>0</td> </tr> <tr> <td>Arithmetic *</td> <td>1</td> </tr> <tr> <td>Comparison</td> <td>True</td> </tr> <tr> <td>Bitwise</td> <td>0</td> </tr> <tr> <td>Stringy</td> <td>&#39;&#39;</td> </tr> <tr> <td>Sets</td> <td>Empty set or equivalent</td> </tr> <tr> <td>Or-like Bool</td> <td>False</td> </tr> <tr> <td>And-like Bool</td> <td>True</td> </tr>
</tbody>
</table><p>For instance, union of an empty list will return an empty set:</p>
<pre class="pod-block-code">say [∪];  # OUTPUT: «set()␤»</pre>
<p>This only applies to operators where empty or 0 is always a valid operand. For instance, applying it to division will yield an exception.</p>
<pre class="pod-block-code">say [%] ();  # OUTPUT: «(exit code 1) No zero-arg meaning for infix:&lt;%&gt;␤»
</pre>

        </div>
    </div>

    

    <footer class="pretty-box yellow">
        <p>
            Generated from <a href="https://github.com/Raku/doc/tree/master/docs/Language/operators.pod6">https://github.com/Raku/doc/tree/master/docs/Language/operators.pod6</a>.
        </p>
        <p>
            This is a work in progress to document Raku (formerly known as Perl 6), and
            known to be incomplete.
        </p>
        <p>
            <a href="https://github.com/raku/doc/blob/master/CONTRIBUTING.md#reporting-bugs">
                Please report any issues
            </a>
            Your contribution is appreciated.
        </p>
        <p>
            This documentation is provided under the terms of the
            <a href="https://raw.githubusercontent.com/raku/doc/master/LICENSE">
                Artistic License 2.0
            </a>. The Camelia image is
            <a href="https://raw.githubusercontent.com/raku/mu/master/misc/camelia.txt">
                copyright © 2009 by Larry Wall.
            </a>
            <!-- CREDITS -->
            <!--External Link Image by Zapyon, CCA-SA 4.0. Derived from Wikimedia Foundation https://commons.wikimedia.org/wiki/File:External-link-04-bold-12x12.svg -->
        </p>
    </footer>

    <script type="text/javascript" src="/Documentable/integration-test/js/app.js?v=1"></script>
    <script type="text/javascript" src="/Documentable/integration-test/js/search.js?v=3"></script>
</body>
</html>


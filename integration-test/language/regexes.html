<!doctype html>
<html lang="en">
<head>
    <title>Regexes</title>
    <meta charset="UTF-8"/>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <link rel="icon" href="/Documentable/integration-test/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" type="text/css" href="/Documentable/integration-test/css/app.css" media="screen" title="default" />
    <noscript> <style> #search { visibility: hidden; } </style> </noscript>
</head>

<body class="pod">

    <div id="___top"></div>

    <div id="header" class="pretty-box green">

        <a href="/Documentable/integration-test/">
            <img src="/Documentable/integration-test/images/Camelia.svg"alt="»ö«"id="logo"width="62"height="48"/> &nbsp;Raku Documentation
        </a>

        <div id="search" class="ui-widget">
            <div class="green">
                <input placeholder="Loading..." id="query" accesskey="f" title="Enter term to search for (hit Esc to focus)"/>
            </div>
            <p id="not-found-message">
                Not in Index (<a href="" id="try-web-search">try site search</a>)
            </p>
        </div>
        
        <div class="menu">
            
            <div class="menu-items dark-green">
                <a class='menu-item darker-green' href='https://raku.org'><strong>Raku homepage</strong></a>
                    <a class="menu-item selected darker-green" href="/Documentable/integration-test/language.html"> Language </a>
                    <a class="menu-item " href="/Documentable/integration-test/type.html"> Types </a>
                    <a class="menu-item " href="/Documentable/integration-test/routine.html"> Routines </a>
                    <a class="menu-item " href="https://webchat.freenode.net/?channels=#raku"> Chat with us </a>
            </div>
            
            
            
        
        </div>
    </div>

    <div id="content" class="pretty-box yellow content_fragment">

        <div align="right" style="display:;">
            <button title="Edit this page"  class="pencil" onclick="location='https://github.com/Raku/doc/tree/master/docs/Language/regexes.pod6'">
                <svg width="14px" height="16px" viewBox="0 0 14 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                    <defs></defs>
                    <g id="Octicons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g id="pencil" fill="#000000">
                            <path d="M0,12 L0,15 L3,15 L11,7 L8,4 L0,12 L0,12 Z M3,14 L1,14 L1,12 L2,12 L2,13 L3,13 L3,14 L3,14 Z M13.3,4.7 L12,6 L9,3 L10.3,1.7 C10.69,1.31 11.32,1.31 11.71,1.7 L13.3,3.29 C13.69,3.68 13.69,4.31 13.3,4.7 L13.3,4.7 Z" id="Shape"></path>
                        </g>
                    </g>
                </svg>
            </button>
        </div>

        <h1 class="title">Regexes</h1>
        <p class="subtitle">Pattern matching against strings</p>

        <nav class="indexgroup">
<table id="TOC">
<caption><h2 id="TOC_Title">Table of Contents</h2></caption>
                      <tr class="toc-level-1"><td class="toc-number">1</td><td class="toc-text"><a href="#Lexical_conventions">Lexical conventions</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">1.1</td><td class="toc-text"><a href="#Anonymous_regex_definition_syntax">Anonymous regex definition syntax</a></td></tr>
                                                     <tr class="toc-level-2"><td class="toc-number">1.2</td><td class="toc-text"><a href="#Named_regex_definition_syntax">Named regex definition syntax</a></td></tr>
                                                            <tr class="toc-level-2"><td class="toc-number">1.3</td><td class="toc-text"><a href="#Regex_readability:_whitespace_and_comments">Regex readability: whitespace and comments</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">1.4</td><td class="toc-text"><a href="#Match_syntax">Match syntax</a></td></tr>
                                                                                     <tr class="toc-level-1"><td class="toc-number">2</td><td class="toc-text"><a href="#Literals_and_metacharacters">Literals and metacharacters</a></td></tr>
                                             <tr class="toc-level-1"><td class="toc-number">3</td><td class="toc-text"><a href="#Wildcards">Wildcards</a></td></tr>
                 <tr class="toc-level-1"><td class="toc-number">4</td><td class="toc-text"><a href="#Character_classes">Character classes</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">4.1</td><td class="toc-text"><a href="#Backslashed_character_classes">Backslashed character classes</a></td></tr>
      <tr class="toc-level-3"><td class="toc-number">4.1.1</td><td class="toc-text"><a href="#\n_and_\N"><code class="pod-code-inline">\n</code> and <code class="pod-code-inline">\N</code></a></td></tr>
                       <tr class="toc-level-3"><td class="toc-number">4.1.2</td><td class="toc-text"><a href="#\t_and_\T"><code class="pod-code-inline">\t</code> and <code class="pod-code-inline">\T</code></a></td></tr>
          <tr class="toc-level-3"><td class="toc-number">4.1.3</td><td class="toc-text"><a href="#\h_and_\H"><code class="pod-code-inline">\h</code> and <code class="pod-code-inline">\H</code></a></td></tr>
                   <tr class="toc-level-3"><td class="toc-number">4.1.4</td><td class="toc-text"><a href="#\v_and_\V"><code class="pod-code-inline">\v</code> and <code class="pod-code-inline">\V</code></a></td></tr>
                       <tr class="toc-level-3"><td class="toc-number">4.1.5</td><td class="toc-text"><a href="#\s_and_\S"><code class="pod-code-inline">\s</code> and <code class="pod-code-inline">\S</code></a></td></tr>
      <tr class="toc-level-3"><td class="toc-number">4.1.6</td><td class="toc-text"><a href="#\d_and_\D"><code class="pod-code-inline">\d</code> and <code class="pod-code-inline">\D</code></a></td></tr>
                    <tr class="toc-level-3"><td class="toc-number">4.1.7</td><td class="toc-text"><a href="#\w_and_\W"><code class="pod-code-inline">\w</code> and <code class="pod-code-inline">\W</code></a></td></tr>
                <tr class="toc-level-3"><td class="toc-number">4.1.8</td><td class="toc-text"><a href="#\c_and_\C"><code class="pod-code-inline">\c</code> and <code class="pod-code-inline">\C</code></a></td></tr>
                   <tr class="toc-level-3"><td class="toc-number">4.1.9</td><td class="toc-text"><a href="#\x_and_\X"><code class="pod-code-inline">\x</code> and <code class="pod-code-inline">\X</code></a></td></tr>
                      <tr class="toc-level-2"><td class="toc-number">4.2</td><td class="toc-text"><a href="#Predefined_character_classes">Predefined character classes</a></td></tr>
                                                                        <tr class="toc-level-2"><td class="toc-number">4.3</td><td class="toc-text"><a href="#Unicode_properties">Unicode properties</a></td></tr>
                                                                                                             <tr class="toc-level-2"><td class="toc-number">4.4</td><td class="toc-text"><a href="#Enumerated_character_classes_and_ranges">Enumerated character classes and ranges</a></td></tr>
                                       <tr class="toc-level-1"><td class="toc-number">5</td><td class="toc-text"><a href="#Quantifiers">Quantifiers</a></td></tr>
                     <tr class="toc-level-2"><td class="toc-number">5.1</td><td class="toc-text"><a href="#One_or_more:_+">One or more: <code class="pod-code-inline">+</code></a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">5.2</td><td class="toc-text"><a href="#Zero_or_more:_*">Zero or more: <code class="pod-code-inline">*</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">5.3</td><td class="toc-text"><a href="#Zero_or_one:_?">Zero or one: <code class="pod-code-inline">?</code></a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">5.4</td><td class="toc-text"><a href="#General_quantifier:_**_min..max">General quantifier: <code class="pod-code-inline">** min..max</code></a></td></tr>
                                                                                             <tr class="toc-level-2"><td class="toc-number">5.5</td><td class="toc-text"><a href="#Modified_quantifier:_%,_%%">Modified quantifier: <code class="pod-code-inline">%</code> , <code class="pod-code-inline">%%</code></a></td></tr>
                             <tr class="toc-level-2"><td class="toc-number">5.6</td><td class="toc-text"><a href="#Preventing_backtracking:_:">Preventing backtracking: <code class="pod-code-inline">:</code></a></td></tr>
                                                             <tr class="toc-level-2"><td class="toc-number">5.7</td><td class="toc-text"><a href="#Greedy_versus_frugal_quantifiers:_?">Greedy versus frugal quantifiers: <code class="pod-code-inline">?</code></a></td></tr>
              <tr class="toc-level-1"><td class="toc-number">6</td><td class="toc-text"><a href="#Alternation:_||">Alternation: <code class="pod-code-inline">||</code></a></td></tr>
                       <tr class="toc-level-1"><td class="toc-number">7</td><td class="toc-text"><a href="#Longest_alternation:_|">Longest alternation: <code class="pod-code-inline">|</code></a></td></tr>
                                           <tr class="toc-level-2"><td class="toc-number">7.1</td><td class="toc-text"><a href="#Quoted_lists_are_LTM_matches">Quoted lists are LTM matches</a></td></tr>
                         <tr class="toc-level-1"><td class="toc-number">8</td><td class="toc-text"><a href="#Conjunction:_&amp;&amp;">Conjunction: <code class="pod-code-inline">&amp;&amp;</code></a></td></tr>
                       <tr class="toc-level-1"><td class="toc-number">9</td><td class="toc-text"><a href="#Conjunction:_&amp;">Conjunction: <code class="pod-code-inline">&amp;</code></a></td></tr>
               <tr class="toc-level-1"><td class="toc-number">10</td><td class="toc-text"><a href="#Anchors">Anchors</a></td></tr>
  <tr class="toc-level-2"><td class="toc-number">10.1</td><td class="toc-text"><a href="#Start_of_string_and_end_of_string">Start of string and end of string</a></td></tr>
                          <tr class="toc-level-2"><td class="toc-number">10.2</td><td class="toc-text"><a href="#Start_of_line_and_end_of_line">Start of line and end of line</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">10.3</td><td class="toc-text"><a href="#Word_boundary">Word boundary</a></td></tr>
                       <tr class="toc-level-2"><td class="toc-number">10.4</td><td class="toc-text"><a href="#Left_and_right_word_boundary">Left and right word boundary</a></td></tr>
                     <tr class="toc-level-2"><td class="toc-number">10.5</td><td class="toc-text"><a href="#Summary_of_anchors">Summary of anchors</a></td></tr>
                                <tr class="toc-level-1"><td class="toc-number">11</td><td class="toc-text"><a href="#Zero-width_assertions">Zero-width assertions</a></td></tr>
   <tr class="toc-level-2"><td class="toc-number">11.1</td><td class="toc-text"><a href="#Lookaround_assertions">Lookaround assertions</a></td></tr>
                         <tr class="toc-level-2"><td class="toc-number">11.2</td><td class="toc-text"><a href="#Lookahead_assertions">Lookahead assertions</a></td></tr>
                                    <tr class="toc-level-2"><td class="toc-number">11.3</td><td class="toc-text"><a href="#Lookbehind_assertions">Lookbehind assertions</a></td></tr>
                                <tr class="toc-level-1"><td class="toc-number">12</td><td class="toc-text"><a href="#Grouping_and_capturing">Grouping and capturing</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">12.1</td><td class="toc-text"><a href="#Capturing">Capturing</a></td></tr>
                      <tr class="toc-level-2"><td class="toc-number">12.2</td><td class="toc-text"><a href="#Non-capturing_grouping">Non-capturing grouping</a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">12.3</td><td class="toc-text"><a href="#Capture_numbers">Capture numbers</a></td></tr>
                                                                                       <tr class="toc-level-2"><td class="toc-number">12.4</td><td class="toc-text"><a href="#Named_captures">Named captures</a></td></tr>
                       <tr class="toc-level-2"><td class="toc-number">12.5</td><td class="toc-text"><a href="#Capture_markers:_&lt;(_)&gt;">Capture markers: <code class="pod-code-inline">&lt;( )&gt;</code></a></td></tr>
                      <tr class="toc-level-1"><td class="toc-number">13</td><td class="toc-text"><a href="#Substitution">Substitution</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">13.1</td><td class="toc-text"><a href="#Lexical_conventions">Lexical conventions</a></td></tr>
                          <tr class="toc-level-2"><td class="toc-number">13.2</td><td class="toc-text"><a href="#Replacing_string_literals">Replacing string literals</a></td></tr>
                <tr class="toc-level-2"><td class="toc-number">13.3</td><td class="toc-text"><a href="#Wildcards_and_character_classes">Wildcards and character classes</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">13.4</td><td class="toc-text"><a href="#Capturing_groups">Capturing groups</a></td></tr>
                                        <tr class="toc-level-2"><td class="toc-number">13.5</td><td class="toc-text"><a href="#Common_adverbs">Common adverbs</a></td></tr>
                                  <tr class="toc-level-2"><td class="toc-number">13.6</td><td class="toc-text"><a href="#S///_non-destructive_substitution"><code class="pod-code-inline">S///</code> non-destructive substitution</a></td></tr>
                             <tr class="toc-level-1"><td class="toc-number">14</td><td class="toc-text"><a href="#Tilde_for_nesting_structures">Tilde for nesting structures</a></td></tr>
                     <tr class="toc-level-1"><td class="toc-number">15</td><td class="toc-text"><a href="#Subrules">Subrules</a></td></tr>
                        <tr class="toc-level-1"><td class="toc-number">16</td><td class="toc-text"><a href="#Regex_interpolation">Regex interpolation</a></td></tr>
                                                                                                                                                   <tr class="toc-level-2"><td class="toc-number">16.1</td><td class="toc-text"><a href="#Regex_boolean_condition_check">Regex boolean condition check</a></td></tr>
                                                                             <tr class="toc-level-1"><td class="toc-number">17</td><td class="toc-text"><a href="#Adverbs">Adverbs</a></td></tr>
                                          <tr class="toc-level-2"><td class="toc-number">17.1</td><td class="toc-text"><a href="#Regex_adverbs">Regex adverbs</a></td></tr>
                                <tr class="toc-level-3"><td class="toc-number">17.1.1</td><td class="toc-text"><a href="#Ignorecase">Ignorecase</a></td></tr>
         <tr class="toc-level-3"><td class="toc-number">17.1.2</td><td class="toc-text"><a href="#Ignoremark">Ignoremark</a></td></tr>
            <tr class="toc-level-3"><td class="toc-number">17.1.3</td><td class="toc-text"><a href="#Ratchet">Ratchet</a></td></tr>
                                                     <tr class="toc-level-3"><td class="toc-number">17.1.4</td><td class="toc-text"><a href="#Sigspace">Sigspace</a></td></tr>
                                                                                                                                                                 <tr class="toc-level-3"><td class="toc-number">17.1.5</td><td class="toc-text"><a href="#Perl_compatibility_adverb">Perl compatibility adverb</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">17.2</td><td class="toc-text"><a href="#Matching_adverbs">Matching adverbs</a></td></tr>
     <tr class="toc-level-3"><td class="toc-number">17.2.1</td><td class="toc-text"><a href="#Positional_adverbs">Positional adverbs</a></td></tr>
                  <tr class="toc-level-3"><td class="toc-number">17.2.2</td><td class="toc-text"><a href="#Continue">Continue</a></td></tr>
                      <tr class="toc-level-3"><td class="toc-number">17.2.3</td><td class="toc-text"><a href="#Exhaustive">Exhaustive</a></td></tr>
                            <tr class="toc-level-3"><td class="toc-number">17.2.4</td><td class="toc-text"><a href="#Global">Global</a></td></tr>
             <tr class="toc-level-3"><td class="toc-number">17.2.5</td><td class="toc-text"><a href="#Pos">Pos</a></td></tr>
            <tr class="toc-level-3"><td class="toc-number">17.2.6</td><td class="toc-text"><a href="#Overlap">Overlap</a></td></tr>
                <tr class="toc-level-2"><td class="toc-number">17.3</td><td class="toc-text"><a href="#Substitution_adverbs">Substitution adverbs</a></td></tr>
      <tr class="toc-level-3"><td class="toc-number">17.3.1</td><td class="toc-text"><a href="#Samecase">Samecase</a></td></tr>
                 <tr class="toc-level-3"><td class="toc-number">17.3.2</td><td class="toc-text"><a href="#Samemark">Samemark</a></td></tr>
              <tr class="toc-level-3"><td class="toc-number">17.3.3</td><td class="toc-text"><a href="#Samespace">Samespace</a></td></tr>
                   <tr class="toc-level-1"><td class="toc-number">18</td><td class="toc-text"><a href="#Backtracking">Backtracking</a></td></tr>
                                                                                                                                                                                                                                                                              <tr class="toc-level-1"><td class="toc-number">19</td><td class="toc-text"><a href="#$/_changes_each_time_a_regular_expression_is_matched"><code class="pod-code-inline">$/</code> changes each time a regular expression is matched</a></td></tr>
                                                                 <tr class="toc-level-1"><td class="toc-number">20</td><td class="toc-text"><a href="#Best_practices_and_gotchas">Best practices and gotchas</a></td></tr>
   
</table>
</nav>

        <div class="pod-body ">
            <p><a name="Documentable/integration-test/index-entry-Regular_Expressions"></a></p>
<p>A <em>regular expression</em> is a sequence of characters that defines a certain text pattern, typically one that one wishes to find in some large body of text.</p>
<p>In theoretical computer science and formal language theory, regular expressions are used to describe so-called <a href="https://en.wikipedia.org/wiki/Regular_language"><em>regular&nbsp;languages</em></a>. Since their inception in the 1950&#39;s, practical implementations of regular expressions, for instance in the text search and replace functions of text editors, have outgrown their strict scientific definition. In acknowledgement of this, and in an attempt to disambiguate, a regular expression in Raku is normally referred to as a <em>regex</em> (from: <em>reg</em>ular <em>ex</em>pression), a term that is also in common use in other programming languages.</p>
<p>In Raku, regexes are written in a <a href="https://en.wikipedia.org/wiki/Domain-specific_language"><em>domain-specific language</em></a>, i.e. a sublanguage or <em>slang</em>. This page describes this language, and explains how regexes can be used to search for text patterns in strings in a process called <em>pattern matching</em>.</p>
<h1 id="Lexical_conventions"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-testindex-entry-quote_/_/-quote_rx-quote_m-Lexical_conventions"><span class="index-entry">Lexical conventions</span></a></a></h1>
<p>Fundamentally, Raku regexes are very much like subroutines: both are code objects, and just as you can have anonymous subs and named subs, you can have anonymous and named regexes.</p>
<p>A regex, whether anonymous or named, is represented by a <a href="/Documentable/integration-test/type/Regex"><code>Regex</code></a> object. Yet, the syntax for constructing anonymous and named <code>Regex</code> objects differs. We will therefore discuss them in turn.</p>
<h2 id="Anonymous_regex_definition_syntax"><a class="u" href="#___top" title="go to top of document">Anonymous regex definition syntax</a></h2>
<p>An anonymous regex may be constructed in one of the following ways:</p>
<pre class="pod-block-code">rx/pattern/;          # an anonymous Regex object; &#39;rx&#39; stands for &#39;regex&#39;
/pattern/;            # an anonymous Regex object; shorthand for &#39;rx/.../&#39;

regex { pattern };    # keyword-declared anonymous regex; this form is
                      # intended for defining named regexes and is discussed
                      # in that context in the next section</pre>
<p>The <code>rx/ /</code> form has two advantages over the bare shorthand form <code>/ /</code>.</p>
<p>Firstly, it enables the use of delimiters other than the slash, which may be used to improve the readability of the regex definition:</p>
<pre class="pod-block-code">rx{ &#39;/tmp/&#39;.* };      # the use of curly braces as delimiters makes this first
rx/ &#39;/tmp/&#39;.* /;      # definition somewhat easier on the eyes than the second</pre>
<p>Although the choice is vast, not every character may be chosen as an alternative regex delimiter:</p>
<ul><li><p>You cannot use whitespace or alphanumeric characters as delimiters. Whitespace in regex definition syntax is generally optional, except where it is required to distinguish from function call syntax (discussed hereafter).</p>
</li>
<li><p>Parentheses can be used as alternative regex delimiters, but only with a space between <code>rx</code> and the opening delimiter. This is because identifiers that are immediately followed by parentheses are always parsed as a subroutine call. For example, in <code>rx()</code> the <a href="/Documentable/integration-test/language/operators#postcircumfix_(_)">call operator</a> <code>()</code> invokes the subroutine <code>rx</code>. The form <code>rx ( abc )</code>, however, <em>does</em> define a <code>Regex</code> object.</p>
</li>
<li><p>Use of a colon as a delimiter would clash with the use of <a href="/Documentable/integration-test/language/regexes#Adverbs">adverbs</a>, which take the form <code>:adverb</code>; accordingly, such use of the colon is forbidden.</p>
</li>
<li><p>The hash character <code>#</code> is not available as a delimiter since it is parsed as the start of a <a href="/Documentable/integration-test/language/syntax#Single-line_comments">comment</a> that runs until the end of the line.</p>
</li>
</ul>
<p>Secondly, the <code>rx</code> form enables the use of <a href="/Documentable/integration-test/language/regexes#Regex_adverbs">regex adverbs</a>, which may be placed between <code>rx</code> and the opening delimiter to modify the definition of the entire regex:</p>
<pre class="pod-block-code">rx:r:s/pattern/;            # :r (:ratchet) and :s (:sigspace) adverbs, defining
                            # a ratcheting regex in which whitespace is significant</pre>
<p>Although anonymous regexes are not, as such, <em>named</em>, they may effectively be given a name by putting them inside a named variable, after which they can be referenced, both outside of an embedding regex and from within an embedding regex by means of <a href="/Documentable/integration-test/language/regexes#Regex_interpolation">interpolation</a>:</p>
<pre class="pod-block-code">my $regex = / R \w+ /;
say &quot;Zen Buddhists like Raku too&quot; ~~ $regex; # OUTPUT: «｢Raku｣␤»

my $regex = /pottery/;
&quot;Japanese pottery rocks!&quot; ~~ / &lt;$regex&gt; /;  # Interpolation of $regex into /.../
say $/;                                     # OUTPUT: «｢pottery｣␤»</pre>
<h2 id="Named_regex_definition_syntax"><a class="u" href="#___top" title="go to top of document">Named regex definition syntax</a></h2>
<p>A named regex may be constructed using the <code>regex</code> declarator as follows:</p>
<pre class="pod-block-code">regex R { pattern };        # a named Regex object, named &#39;R&#39;</pre>
<p>Unlike with the <code>rx</code> form, you cannot chose your preferred delimiter: curly braces are mandatory. In this regard it should be noted that the definition of a named regex using the <code>regex</code> form is syntactically similar to the definition of a subroutine:</p>
<pre class="pod-block-code">my sub   S { /pattern/ };   # definition of Sub object (returning a Regex)
my regex R {  pattern  };   # definition of Regex object</pre>
<p>which emphasizes the fact that a <a href="/Documentable/integration-test/type/Regex"><code>Regex</code></a> object represents code rather than data:</p>
<pre class="pod-block-code">&amp;S ~~ Code;                 # OUTPUT: «True␤»

&amp;R ~~ Code;                 # OUTPUT: «True␤»
&amp;R ~~ Method;               # OUTPUT: «True␤»   (A Regex is really a Method!)
</pre>
<p>Also unlike with the <code>rx</code> form for defining an anonymous regex, the definition of a named regex using the <code>regex</code> keyword does not allow for adverbs to be inserted before the opening delimiter. Instead, adverbs that are to modify the entire regex pattern may be included first thing within the curly braces:</p>
<pre class="pod-block-code">regex R { :i pattern };     # :i (:ignorecase), renders pattern case insensitive</pre>
<p>Alternatively, by way of shorthand, it is also possible (and recommended) to use the <code>rule</code> and <code>token</code> variants of the <code>regex</code> declarator for defining a <code>Regex</code> when the <code>:ratchet</code> and <code>:sigspace</code> adverbs are of interest:</p>
<pre class="pod-block-code">regex R { :r pattern };     # apply :r (:ratchet) to entire pattern
</pre>
<p>and, alternatively</p>
<pre class="pod-block-code">token R { pattern };        # same thing: &#39;token&#39; implies &#39;:r&#39;
</pre>
<p>Or</p>
<pre class="pod-block-code">regex R { :r :s pattern };  # apply :r (:ratchet) and :s (:sigspace) to pattern
</pre>
<p>with this alternative:</p>
<pre class="pod-block-code">rule  R { pattern };        # same thing: &#39;rule&#39; implies &#39;:r:s&#39;
</pre>
<p>Named regexes may be used as building blocks for other regexes, as they are methods that may called from within other regexes using the <code>&lt;regex-name&gt;</code> syntax. When they are used this way, they are often referred to as <em>subrules</em>; see for more details on their use <a href="/Documentable/integration-test/language/regexes#Subrules">here</a>. <a href="/Documentable/integration-test/type/Grammar"><code>Grammars</code></a> are the natural habitat of subrules, but many common predefined character classes are also implemented as named regexes.</p>
<h2 id="Regex_readability:_whitespace_and_comments"><a class="u" href="#___top" title="go to top of document">Regex readability: whitespace and comments</a></h2>
<p>Whitespace in regexes is ignored unless the <a href="/Documentable/integration-test/language/regexes#Sigspace"><code>:sigspace</code></a> adverb is used to make whitespace syntactically significant.</p>
<p>In addition to whitespace, comments may be used inside of regexes to improve their comprehensibility just as in code in general. This is true for both <a href="/Documentable/integration-test/language/syntax#Single-line_comments">single line comments</a> and <a href="/Documentable/integration-test/language/syntax#Multi-line_/_embedded_comments">multi line/embedded comments</a>:</p>
<pre class="pod-block-code">my $regex =  rx/ \d ** 4            #`(match the year YYYY)
                 &#39;-&#39;
                 \d ** 2            # ...the month MM
                 &#39;-&#39;
                 \d ** 2 /;         # ...and the day DD

say &#39;2015-12-25&#39;.match($regex);     # OUTPUT: «｢2015-12-25｣␤»</pre>
<h2 id="Match_syntax"><a class="u" href="#___top" title="go to top of document">Match syntax</a></h2>
<p>There are a variety of ways to match a string against a regex. Irrespective of the syntax chosen, a successful match results in a <a href="/Documentable/integration-test/type/Match"><code>Match</code></a> object. In case the match is unsuccessful, the result is <a href="/Documentable/integration-test/type/Nil"><code>Nil</code></a>. In either case, the result of the match operation is available via the special match variable <a href="/Documentable/integration-test/syntax/$$SOLIDUS"><code>$/</code></a>.</p>
<p>The most common ways to match a string against an anonymous regex <code>/pattern/</code> or against a named regex <code>R</code> include the following:</p>
<ul><li><p><em>Smartmatch: &quot;string&quot; ~~ /pattern/, or &quot;string&quot; ~~ /&lt;R&gt;/</em></p>
<p><a href="/Documentable/integration-test/language/operators#index-entry-smartmatch_operator">Smartmatching</a> a string against a <code>Regex</code> performs a regex match of the string against the <code>Regex</code>:</p>
<pre class="pod-block-code">say &quot;Go ahead, make my day.&quot; ~~ / \w+ /;   # OUTPUT: «｢Go｣␤»

my regex R { me|you };
say &quot;You talkin&#39; to me?&quot; ~~ / &lt;R&gt; /;       # OUTPUT: «｢me｣␤ R =&gt; ｢me｣␤»
say &quot;May the force be with you.&quot; ~~ &amp;R ;   # OUTPUT: «｢you｣␤»</pre>
<p>The different outputs of the last two statements show that these two ways of smartmatching against a named regex are not identical. The difference arises because the method call <code>&lt;R&gt;</code> from within the anonymous regex <code>/ /</code> installs a so-called <a href="/Documentable/integration-test/language/regexes#Named_captures">&#39;named capture&#39;</a> in the <code>Match</code> object, while the smartmatch against the named <code>Regex</code> as such does not.</p>
</li>
<li><p><em>Explicit topic match: m/pattern/, or m/&lt;R&gt;/</em></p>
<p>The match operator <code>m/ /</code> immediately matches the topic variable <a href="/Documentable/integration-test/language/variables#index-entry-topic_variable"><code>$_</code></a> against the regex following the <code>m</code>.</p>
<p>As with the <code>rx/ /</code> syntax for regex definitions, the match operator may be used with adverbs in between <code>m</code> and the opening regex delimiter, and with delimiters other than the slash. However, while the <code>rx/ /</code> syntax may only be used with <a href="/Documentable/integration-test/language/regexes#Regex_adverbs"><em>regex adverbs</em></a> that affect the compilation of the regex, the <code>m/ /</code> syntax may additionally be used with <a href="/Documentable/integration-test/language/regexes#Matching_adverbs"><em>matching adverbs</em></a> that determine how the regex engine is to perform pattern matching.</p>
<p>Here&#39;s an example that illustrates the primary difference between the <code>m/ /</code> and <code>/ /</code> syntax:</p>
<pre class="pod-block-code">my $match;
$_ = &quot;abc&quot;;
$match = m/.+/; say $match; say $match.^name; # OUTPUT: «｢abc｣␤Match␤»
$match =  /.+/; say $match; say $match.^name; # OUTPUT: «/.+/␤Regex␤»</pre>
</li>
<li><p><em>Implicit topic match in sink and boolean contexts</em></p>
<p>In case a <code>Regex</code> object is used in sink context, or in a context in which it is coerced to <a href="/Documentable/integration-test/type/Bool"><code>Bool</code></a>, the topic variable <a href="/Documentable/integration-test/language/variables#index-entry-topic_variable"><code>$_</code></a> is automatically matched against it:</p>
<pre class="pod-block-code">$_ = &quot;dummy string&quot;;        # Set the topic explicitly

rx/ s.* /;                  # Regex object in sink context matches automatically
say $/;                     # OUTPUT: «｢string｣␤»

say $/ if rx/ d.* /;        # Regex object in boolean context matches automatically
                            # OUTPUT: «｢dummy string｣␤»</pre>
</li>
<li><p><em>Match method: &quot;string&quot;.match: /pattern/, or &quot;string&quot;.match: /&lt;R&gt;/</em></p>
<p>The <a href="/Documentable/integration-test/type/Str#method_match"><code>match</code></a> method is analogous to the <code>m/ /</code> operator discussed above. Invoking it on a string, with a <code>Regex</code> as an argument, matches the string against the <code>Regex</code>.</p>
</li>
<li><p><em>Parsing grammars: grammar-name.parse($string)</em></p>
<p>Although parsing a <a href="/Documentable/integration-test/language/grammars">Grammar</a> involves more than just matching a string against a regex, this powerful regex-based text destructuring tool can&#39;t be left out from this overview of common pattern matching methods.</p>
<p>If you feel that your needs exceed what simple regexes have to offer, check out this <a href="/Documentable/integration-test/language/grammar_tutorial">grammar tutorial</a> to take regexes to the next level.</p>
</li>
</ul>
<h1 id="Literals_and_metacharacters"><a class="u" href="#___top" title="go to top of document">Literals and metacharacters</a></h1>
<p>A regex describes a pattern to be matched in terms of literals and metacharacters. Alphanumeric characters and the underscore <code>_</code> constitute the literals: these characters match themselves and nothing else. Other characters act as metacharacters and may, as such, have a special meaning, either by themselves (such as the dot <code>.</code>, which serves as a wildcard) or together with other characters in larger metasyntactic constructs (such as <code>&lt;?before ...&gt;</code>, which defines a lookahead assertion).</p>
<p>In its simplest form a regex comprises only literals:</p>
<pre class="pod-block-code">/Cześć/;           # &quot;Hello&quot; in Polish
/こんばんは/;        # &quot;Good afternoon&quot; in Japanese
/Καλησπέρα/;       # &quot;Good evening&quot; in Greek</pre>
<p>If you want a regex to literally match one or more characters that normally act as metacharacters, those characters must either be escaped using a backslash, or be quoted using single or double quotes.</p>
<p>The backslash serves as a switch. It switches a single metacharacter into a literal, and vice versa:</p>
<pre class="pod-block-code">/ \# /;             # matches the hash metacharacter literally
/ \w /;             # turns literal &#39;w&#39; into a character class (see below)
/Hallelujah\!/;     # matches string &#39;Hallelujah!&#39; incl. exclamation mark</pre>
<p>Even if a metacharacter does not (yet) have a special meaning in Raku, escaping (or quoting) it is required to ensure that the regex compiles and matches the character literally. This allows the clear distinction between literals and metacharacters to be maintained. So, for instance, to match a comma this will work:</p>
<pre class="pod-block-code">/ \, /;             # matches a literal comma &#39;,&#39;</pre>
<p>while this will fail:</p>
<pre class="pod-block-code">/ ,  /;             # !! error: an as-yet meaningless/unrecognized metacharacter
                    # does not automatically match literally
</pre>
<p>While an escaping backslash exerts its effect on the next individual character, both a single metacharacter and a sequence of metacharacters may be turned into literally matching strings by quoting them in single or double quotes:</p>
<pre class="pod-block-code">/ &quot;abc&quot; /;          # quoting literals does not make them more literal
/ &quot;Hallelujah!&quot; /;  # yet, this form is generally preferred over /Hallelujah\!/

/ &quot;two words&quot; /;    # quoting a space renders it significant, so this matches
                    # the string &#39;two words&#39; including the intermediate space

/ &#39;#!:@&#39; /;         # this regex matches the string of metacharacters &#39;#!:@&#39;</pre>
<p>Quoting does not simply turn every metacharacter into a literal, however. This is because quotes allow for backslash-escapes and interpolation. Specifically: in single quotes, the backslash may be used to escape single quotes and the backslash itself; double quotes additionally enable the interpolation of variables, and of code blocks of the form <code>{...}</code>. Hence all of this works:</p>
<pre class="pod-block-code">/ &#39;\\\&#39;&#39; /;          # matches a backslash followed by a single quote: \&#39;

my $x = &#39;Hi&#39;;
/ &quot;$x there!&quot; /;     # matches the string &#39;Hi there!&#39;

/ &quot;1 + 1 = {1+1}&quot; /; # matches the string &#39;1 + 1 = 2&#39;</pre>
<p>while these examples illustrate mistakes that you will want to avoid:</p>
<pre class="pod-block-code">/ &#39;\&#39; /;             # !! error: this is NOT the way to literally match a
                     # backslash because now it escapes the second quote

/&quot;Price tag $0.50&quot;/; # !! error: &quot;$0&quot; is interpreted as the first positional
                     # capture (which is Nil), not as &#39;$0&#39;
</pre>
<p>Strings are searched left to right, so it is enough if only part of the string matches the regex:</p>
<pre class="pod-block-code">if &#39;Life, the Universe and Everything&#39; ~~ / and / {
    say ~$/;            # OUTPUT: «and␤»
    say $/.prematch;    # OUTPUT: «Life, the Universe ␤»
    say $/.postmatch;   # OUTPUT: « Everything␤»
    say $/.from;        # OUTPUT: «19␤»
    say $/.to;          # OUTPUT: «22␤»
};</pre>
<p>Match results are always stored in the <code>$/</code> variable and are also returned from the match. They are both of type <a href="/Documentable/integration-test/type/Match">Match</a> if the match was successful; otherwise both are of type <a href="/Documentable/integration-test/type/Nil">Nil</a>.</p>
<h1 id="Wildcards"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex__.-Wildcards"><span class="index-entry">Wildcards</span></a></a></h1>
<p>An unescaped dot <code>.</code> in a regex matches any single character.</p>
<p>So, these all match:</p>
<pre class="pod-block-code">&#39;perl&#39; ~~ /per./;       # matches the whole string
&#39;perl&#39; ~~ / per . /;    # the same; whitespace is ignored
&#39;perl&#39; ~~ / pe.l /;     # the . matches the r
&#39;speller&#39; ~~ / pe.l/;   # the . matches the first l</pre>
<p>while this doesn&#39;t match:</p>
<pre class="pod-block-code">&#39;perl&#39; ~~ /. per /;</pre>
<p>because there&#39;s no character to match before <code>per</code> in the target string.</p>
<p>Notably <code>.</code> also matches a logical newline <code>\n</code>:</p>
<pre class="pod-block-code">my $text = qq:to/END/
  Although I am a
  multi-line text,
  I can be matched
  with /.*/.
  END
  ;

say $text ~~ / .* /;
# OUTPUT «｢Although I am a␤multi-line text,␤I can be matched␤with /.*/.␤｣»</pre>
<h1 id="Character_classes"><a class="u" href="#___top" title="go to top of document">Character classes</a></h1>
<h2 id="Backslashed_character_classes"><a class="u" href="#___top" title="go to top of document">Backslashed character classes</a></h2>
<p>There are predefined character classes of the form <code>\w</code>. Its negation is written with an upper-case letter, <code>\W</code>.</p>
<h3 id="\n_and_\N"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_\n-regex_\N-\n_and_\N"><span class="index-entry"><code>\n</code> and <code>\N</code></span></a></a></h3>
<p><code>\n</code> matches a logical newline. <code>\N</code> matches a single character that&#39;s not a logical newline.</p>
<p>The definition of what constitutes a logical newline follows the <a href="https://unicode.org/reports/tr18/#Line_Boundaries">Unicode definition of a line boundary</a> and includes in particular all of: a line feed (LF) <code>\U+000A</code>, a vertical tab (VT) <code>\U+000B</code>, a form feed (FF) <code>\U+000C</code>, a carriage return (CR) <code>\U+000D</code>, and the Microsoft Windows style newline sequence CRLF.</p>
<p>The interpretation of <code>\n</code> in regexes is independent of the value of the variable <code>$?NL</code> controlled by the <a href="/Documentable/integration-test/language/pragmas#newline">newline pragma</a>.</p>
<h3 id="\t_and_\T"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_\t-regex_\T-\t_and_\T"><span class="index-entry"><code>\t</code> and <code>\T</code></span></a></a></h3>
<p><code>\t</code> matches a single tab/tabulation character, <code>U+0009</code>. <code>\T</code> matches a single character that is not a tab.</p>
<p>Note that exotic tabs like the <code>U+000B VERTICAL TABULATION</code> character are not included here.</p>
<h3 id="\h_and_\H"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_\h-regex_\H-\h_and_\H"><span class="index-entry"><code>\h</code> and <code>\H</code></span></a></a></h3>
<p><code>\h</code> matches a single horizontal whitespace character. <code>\H</code> matches a single character that is not a horizontal whitespace character.</p>
<p>Examples of horizontal whitespace characters are</p>
<pre class="pod-block-code">U+0020 SPACE
U+00A0 NO-BREAK SPACE
U+0009 CHARACTER TABULATION
U+2001 EM QUAD
</pre>
<p>Vertical whitespace such as newline characters are explicitly excluded; those can be matched with <code>\v</code>; <code>\s</code> matches any kind of whitespace.</p>
<h3 id="\v_and_\V"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_\v-regex_\V-\v_and_\V"><span class="index-entry"><code>\v</code> and <code>\V</code></span></a></a></h3>
<p><code>\v</code> matches a single vertical whitespace character. <code>\V</code> matches a single character that is not vertical whitespace.</p>
<p>Examples of vertical whitespace characters:</p>
<pre class="pod-block-code">U+000A LINE FEED
U+000B VERTICAL TABULATION
U+000C FORM FEED
U+000D CARRIAGE RETURN
U+0085 NEXT LINE
U+2028 LINE SEPARATOR
U+2029 PARAGRAPH SEPARATOR
</pre>
<p>Use <code>\s</code> to match any kind of whitespace, not just vertical whitespace.</p>
<h3 id="\s_and_\S"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_\s-regex_\S-\s_and_\S"><span class="index-entry"><code>\s</code> and <code>\S</code></span></a></a></h3>
<p><code>\s</code> matches a single whitespace character. <code>\S</code> matches a single character that is not whitespace.</p>
<pre class="pod-block-code">say $/.prematch if &#39;Match the first word.&#39; ~~ / \s+ /;
# OUTPUT: «Match␤»</pre>
<h3 id="\d_and_\D"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_\d-regex_\D-\d_and_\D"><span class="index-entry"><code>\d</code> and <code>\D</code></span></a></a></h3>
<p><code>\d</code> matches a single digit (Unicode property <code>N</code>) and <code>\D</code> matches a single character that is not a digit.</p>
<pre class="pod-block-code">&#39;ab42&#39; ~~ /\d/ and say ~$/;     # OUTPUT: «4␤»
&#39;ab42&#39; ~~ /\D/ and say ~$/;     # OUTPUT: «a␤»</pre>
<p>Note that not only the Arabic digits (commonly used in the Latin alphabet) match <code>\d</code>, but also digits from other scripts.</p>
<p>Examples of digits are:</p>
<pre class="pod-block-code">U+0035 5 DIGIT FIVE
U+0BEB ௫ TAMIL DIGIT FIVE
U+0E53 ๓ THAI DIGIT THREE
U+17E5 ៥ KHMER DIGIT FIVE
</pre>
<h3 id="\w_and_\W"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_\w-regex_\W-\w_and_\W"><span class="index-entry"><code>\w</code> and <code>\W</code></span></a></a></h3>
<p><code>\w</code> matches a single word character, i.e. a letter (Unicode category L), a digit or an underscore. <code>\W</code> matches a single character that is not a word character.</p>
<p>Examples of word characters:</p>
<pre class="pod-block-code">0041 A LATIN CAPITAL LETTER A
0031 1 DIGIT ONE
03B4 δ GREEK SMALL LETTER DELTA
03F3 ϳ GREEK LETTER YOT
0409 Љ CYRILLIC CAPITAL LETTER LJE
</pre>
<h3 id="\c_and_\C"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_\c-regex_\C-\c_and_\C"><span class="index-entry"><code>\c</code> and <code>\C</code></span></a></a></h3>
<p><code>\c</code> takes a parameter delimited by square-brackets which is the name of a Unicode character as it appears in the <a href="https://unicode.org/ucd/">Unicode Character Database (UCD)</a> and matches that specific character. For example:</p>
<pre class="pod-block-code">&#39;a.b&#39; ~~ /\c[FULL STOP]/ and say ~$/;    # OUTPUT: «.»</pre>
<p><code>\C</code> matches a single character that is not the named Unicode character.</p>
<p>Note that the word &quot;character&quot; is used, here, in the sense that the UCD does, but because Raku uses <a href="/Documentable/integration-test/language/glossary#NFG">NFG</a>, combining code points and the base characters to which they are attached, will generally not match individually. For example if you compose <code>&quot;ü&quot;</code> as <code>&quot;u\x[0308]&quot;</code>, that works just fine, but matching may surprise you:</p>
<pre class="pod-block-code">say &quot;u\x[0308]&quot; ~~ /\c[LATIN SMALL LETTER U]/;    # OUTPUT: «Nil»</pre>
<p>To match the unmodified character, you can use the <a href="#regex_adverb%2C%3Aignoremark"><code>:ignoremark</code></a> adverb.</p>
<h3 id="\x_and_\X"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_\x-regex_\X-\x_and_\X"><span class="index-entry"><code>\x</code> and <code>\X</code></span></a></a></h3>
<p><code>\x</code> takes a parameter delimited by square-brackets which is the hexadecimal representation of the Unicode codepoint representing the character to be matched. For example:</p>
<pre class="pod-block-code">&#39;a.b&#39; ~~ /\x[2E]/ and say ~$/;    # OUTPUT: «.»</pre>
<p><code>\X</code> matches a single character that is not the given Unicode codepoint.</p>
<p>In addition, <code>\x</code> and <code>\X</code> can be used without square brackets, in which case, any characters that follow the <code>x</code> or <code>X</code> that are valid hexadecimal digits will be consumed. This means that all of these are equivalent:</p>
<pre class="pod-block-code">/\x2e/ and /\x002e/ and /\x00002e/</pre>
<p>But this format can be ambiguous, so the use of surrounding whitespace is highly recommended in non-trivial expressions.</p>
<p>For additional provisos with respect to combining codepoints, see <a href="#regex%2C%5Cc"><code>\c</code> and <code>\C</code></a>.</p>
<h2 id="Predefined_character_classes"><a class="u" href="#___top" title="go to top of document">Predefined character classes</a></h2>
<table class="pod-table">
<thead><tr>
<th>Class</th> <th>Shorthand</th> <th>Description</th>
</tr></thead>
<tbody>
<tr> <td>&lt;alpha&gt;</td> <td></td> <td>Alphabetic characters plus underscore (_)</td> </tr> <tr> <td>&lt;digit&gt;</td> <td>\d</td> <td>Decimal digits</td> </tr> <tr> <td>&lt;xdigit&gt;</td> <td></td> <td>Hexadecimal digit [0-9A-Fa-f]</td> </tr> <tr> <td>&lt;alnum&gt;</td> <td>\w</td> <td>&lt;alpha&gt; plus &lt;digit&gt;</td> </tr> <tr> <td>&lt;punct&gt;</td> <td></td> <td>Punctuation and Symbols (only Punct beyond ASCII)</td> </tr> <tr> <td>&lt;graph&gt;</td> <td></td> <td>&lt;alnum&gt; plus &lt;punct&gt;</td> </tr> <tr> <td>&lt;space&gt;</td> <td>\s</td> <td>Whitespace</td> </tr> <tr> <td>&lt;cntrl&gt;</td> <td></td> <td>Control characters</td> </tr> <tr> <td>&lt;print&gt;</td> <td></td> <td>&lt;graph&gt; plus &lt;space&gt;, but no &lt;cntrl&gt;</td> </tr> <tr> <td>&lt;blank&gt;</td> <td>\h</td> <td>Horizontal whitespace</td> </tr> <tr> <td>&lt;lower&gt;</td> <td>&lt;:Ll&gt;</td> <td>Lowercase characters</td> </tr> <tr> <td>&lt;upper&gt;</td> <td>&lt;:Lu&gt;</td> <td>Uppercase characters</td> </tr> <tr> <td>&lt;same&gt;</td> <td></td> <td>Matches between two identical characters</td> </tr> <tr> <td>&lt;wb&gt;</td> <td></td> <td>Word boundary</td> </tr> <tr> <td>&lt;ws&gt;</td> <td></td> <td>Whitespace. This is actually a default rule.</td> </tr> <tr> <td>&lt;ww&gt;</td> <td></td> <td>Within word</td> </tr> <tr> <td>&lt;ident&gt;</td> <td></td> <td>Identifier. Also a default rule.</td> </tr>
</tbody>
</table><p>The predefined character classes in the leftmost column are all of the form <code>&lt;name&gt;</code>, a hint to the fact that they are implemented as built-in <a href="/Documentable/integration-test/language/regexes#Subrules">named regexes</a>. As such they are subject to the usual capturing semantics. This means that if a character class is called with the syntax <code>&lt;name&gt;</code> (i.e. as indicated in the leftmost column), it will not only match, but also capture, installing a correspondingly named <a href="/Documentable/integration-test/language/regexes#Named_captures">&#39;named capture&#39;</a> in the resulting <a href="/Documentable/integration-test/type/Match">Match object</a>. In case just a match and no capture is desired, the capture may be suppressed through the use of call syntax that includes a leading dot: <code>&lt;.name&gt;</code>.</p>
<p>Note that the character classes <code>&lt;same&gt;</code>, <code>&lt;wb&gt;</code> and <code>&lt;ww&gt;</code> are so-called zero-width assertions, which do not really match any character.</p>
<h2 id="Unicode_properties"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_<:property>-Unicode_properties"><span class="index-entry">Unicode properties</span></a></a></h2>
<p>The character classes mentioned so far are mostly for convenience; another approach is to use Unicode character properties. These come in the form <code>&lt;:property&gt;</code>, where <code>property</code> can be a short or long Unicode General Category name. These use pair syntax.</p>
<p>To match against a Unicode property you can use either smartmatch or <a href="/Documentable/integration-test/routine/uniprop"><code>uniprop</code></a>:</p>
<pre class="pod-block-code">&quot;a&quot;.uniprop(&#39;Script&#39;);                 # OUTPUT: «Latin␤»
&quot;a&quot; ~~ / &lt;:Script&lt;Latin&gt;&gt; /;           # OUTPUT: «｢a｣␤»
&quot;a&quot;.uniprop(&#39;Block&#39;);                  # OUTPUT: «Basic Latin␤»
&quot;a&quot; ~~ / &lt;:Block(&#39;Basic Latin&#39;)&gt; /;    # OUTPUT: «｢a｣␤»</pre>
<p>These are the Unicode general categories used for matching:</p>
<table class="pod-table">
<thead><tr>
<th>Short</th> <th>Long</th>
</tr></thead>
<tbody>
<tr> <td>L</td> <td>Letter</td> </tr> <tr> <td>LC</td> <td>Cased_Letter</td> </tr> <tr> <td>Lu</td> <td>Uppercase_Letter</td> </tr> <tr> <td>Ll</td> <td>Lowercase_Letter</td> </tr> <tr> <td>Lt</td> <td>Titlecase_Letter</td> </tr> <tr> <td>Lm</td> <td>Modifier_Letter</td> </tr> <tr> <td>Lo</td> <td>Other_Letter</td> </tr> <tr> <td>M</td> <td>Mark</td> </tr> <tr> <td>Mn</td> <td>Nonspacing_Mark</td> </tr> <tr> <td>Mc</td> <td>Spacing_Mark</td> </tr> <tr> <td>Me</td> <td>Enclosing_Mark</td> </tr> <tr> <td>N</td> <td>Number</td> </tr> <tr> <td>Nd</td> <td>Decimal_Number or digit</td> </tr> <tr> <td>Nl</td> <td>Letter_Number</td> </tr> <tr> <td>No</td> <td>Other_Number</td> </tr> <tr> <td>P</td> <td>Punctuation or punct</td> </tr> <tr> <td>Pc</td> <td>Connector_Punctuation</td> </tr> <tr> <td>Pd</td> <td>Dash_Punctuation</td> </tr> <tr> <td>Ps</td> <td>Open_Punctuation</td> </tr> <tr> <td>Pe</td> <td>Close_Punctuation</td> </tr> <tr> <td>Pi</td> <td>Initial_Punctuation</td> </tr> <tr> <td>Pf</td> <td>Final_Punctuation</td> </tr> <tr> <td>Po</td> <td>Other_Punctuation</td> </tr> <tr> <td>S</td> <td>Symbol</td> </tr> <tr> <td>Sm</td> <td>Math_Symbol</td> </tr> <tr> <td>Sc</td> <td>Currency_Symbol</td> </tr> <tr> <td>Sk</td> <td>Modifier_Symbol</td> </tr> <tr> <td>So</td> <td>Other_Symbol</td> </tr> <tr> <td>Z</td> <td>Separator</td> </tr> <tr> <td>Zs</td> <td>Space_Separator</td> </tr> <tr> <td>Zl</td> <td>Line_Separator</td> </tr> <tr> <td>Zp</td> <td>Paragraph_Separator</td> </tr> <tr> <td>C</td> <td>Other</td> </tr> <tr> <td>Cc</td> <td>Control or cntrl</td> </tr> <tr> <td>Cf</td> <td>Format</td> </tr> <tr> <td>Cs</td> <td>Surrogate</td> </tr> <tr> <td>Co</td> <td>Private_Use</td> </tr> <tr> <td>Cn</td> <td>Unassigned</td> </tr>
</tbody>
</table><p>For example, <code>&lt;:Lu&gt;</code> matches a single, upper-case letter.</p>
<p>Its negation is this: <code>&lt;:!property&gt;</code>. So, <code>&lt;:!Lu&gt;</code> matches a single character that is not an upper-case letter.</p>
<p>Categories can be used together, with an infix operator:</p>
<table class="pod-table">
<thead><tr>
<th>Operator</th> <th>Meaning</th>
</tr></thead>
<tbody>
<tr> <td>+</td> <td>set union</td> </tr> <tr> <td>-</td> <td>set difference</td> </tr>
</tbody>
</table><p>To match either a lower-case letter or a number, write <code>&lt;:Ll+:N&gt;</code> or <code>&lt;:Ll+:Number&gt;</code> or <code>&lt;+ :Lowercase_Letter + :Number&gt;</code>.</p>
<p>It&#39;s also possible to group categories and sets of categories with parentheses; for example:</p>
<pre class="pod-block-code">say $0 if &#39;perl6&#39; ~~ /\w+(&lt;:Ll+:N&gt;)/ # OUTPUT: «｢6｣␤»</pre>
<h2 id="Enumerated_character_classes_and_ranges"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_<[_]>-regex_<-[_]>-Enumerated_character_classes_and_ranges"><span class="index-entry">Enumerated character classes and ranges</span></a></a></h2>
<p>Sometimes the pre-existing wildcards and character classes are not enough. Fortunately, defining your own is fairly simple. Within <code>&lt;[ ]&gt;</code>, you can put any number of single characters and ranges of characters (expressed with two dots between the end points), with or without whitespace.</p>
<pre class="pod-block-code">&quot;abacabadabacaba&quot; ~~ / &lt;[ a .. c 1 2 3 ]&gt;* /;
# Unicode hex codepoint range
&quot;ÀÁÂÃÄÅÆ&quot; ~~ / &lt;[ \x[00C0] .. \x[00C6] ]&gt;* /;
# Unicode named codepoint range
&quot;αβγ&quot; ~~ /&lt;[\c[GREEK SMALL LETTER ALPHA]..\c[GREEK SMALL LETTER GAMMA]]&gt;*/;</pre>
<p>Within the <code>&lt; &gt;</code> you can use <code>+</code> and <code>-</code> to add or remove multiple range definitions and even mix in some of the Unicode categories above. You can also write the backslashed forms for character classes between the <code>[ ]</code>.</p>
<pre class="pod-block-code">/ &lt;[\d] - [13579]&gt; /;
# starts with \d and removes odd ASCII digits, but not quite the same as
/ &lt;[02468]&gt; /;
# because the first one also contains &quot;weird&quot; unicodey digits</pre>
<p>You can include Unicode properties in the list as well:</p>
<pre class="pod-block-code">/&lt;:Zs + [\x9] - [\xA0]&gt;/
# Any character with &quot;Zs&quot; property, or a tab, but not a &quot;no-break space&quot;</pre>
<p><a name="Documentable/integration-test/index-entry-escaping_characters"></a> You can use <code>\</code> to escape characters that would have some meaning in the regular expression:</p>
<pre class="pod-block-code">say &quot;[ hey ]&quot; ~~ /&lt;-[ \] \[ \s ]&gt;+/; # OUTPUT: «｢hey｣␤»</pre>
<p>To negate a character class, put a <code>-</code> after the opening angle bracket:</p>
<pre class="pod-block-code">say &#39;no quotes&#39; ~~ /  &lt;-[ &quot; ]&gt; + /;  # &lt;-[&quot;]&gt; matches any character except &quot;</pre>
<p>A common pattern for parsing quote-delimited strings involves negated character classes:</p>
<pre class="pod-block-code">say &#39;&quot;in quotes&quot;&#39; ~~ / &#39;&quot;&#39; &lt;-[ &quot; ]&gt; * &#39;&quot;&#39;/;</pre>
<p>This regex first matches a quote, then any characters that aren&#39;t quotes, and then a quote again. The meaning of <code>*</code> and <code>+</code> in the examples above are explained in the next section on quantifiers.</p>
<p>Just as you can use the <code>-</code> for both set difference and negation of a single value, you can also explicitly put a <code>+</code> in front:</p>
<pre class="pod-block-code">/ &lt;+[123]&gt; /  # same as &lt;[123]&gt;</pre>
<h1 id="Quantifiers"><a class="u" href="#___top" title="go to top of document">Quantifiers</a></h1>
<p>A quantifier makes the preceding atom match a variable number of times. For example, <code>a+</code> matches one or more <code>a</code> characters.</p>
<p>Quantifiers bind tighter than concatenation, so <code>ab+</code> matches one <code>a</code> followed by one or more <code>b</code>s. This is different for quotes, so <code>&#39;ab&#39;+</code> matches the strings <code>ab</code>, <code>abab</code>, <code>ababab</code> etc.</p>
<h2 id="One_or_more:_+"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_quantifier_+-One_or_more:_+"><span class="index-entry">One or more: <code>+</code></span></a></a></h2>
<p>The <code>+</code> quantifier makes the preceding atom match one or more times, with no upper limit.</p>
<p>For example, to match strings of the form <code>key=value</code>, you can write a regex like this:</p>
<pre class="pod-block-code">/ \w+ &#39;=&#39; \w+ /</pre>
<h2 id="Zero_or_more:_*"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_quantifier_*-Zero_or_more:_*"><span class="index-entry">Zero or more: <code>*</code></span></a></a></h2>
<p>The <code>*</code> quantifier makes the preceding atom match zero or more times, with no upper limit.</p>
<p>For example, to allow optional whitespace between <code>a</code> and <code>b</code> you can write:</p>
<pre class="pod-block-code">/ a \s* b /</pre>
<h2 id="Zero_or_one:_?"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_quantifier_?-Zero_or_one:_?"><span class="index-entry">Zero or one: <code>?</code></span></a></a></h2>
<p>The <code>?</code> quantifier makes the preceding atom match zero or once.</p>
<p>For example, to match <code>dog</code> or <code>dogs</code>, you can write:</p>
<pre class="pod-block-code">/ dogs? /</pre>
<h2 id="General_quantifier:_**_min..max"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_quantifier_**-General_quantifier:_**_min..max"><span class="index-entry">General quantifier: <code>** min..max</code></span></a></a></h2>
<p>To quantify an atom an arbitrary number of times, use the <code>**</code> quantifier, which takes a single <a href="/Documentable/integration-test/type/Int">Int</a> or a <a href="/Documentable/integration-test/type/Range">Range</a> on the right-hand side that specifies the number of times to match. If a <a href="/Documentable/integration-test/type/Range">Range</a> is specified, the end-points specify the minimum and maximum number of times to match.</p>
<pre class="pod-block-code">say &#39;abcdefg&#39; ~~ /\w ** 4/;      # OUTPUT: «｢abcd｣␤»
say &#39;a&#39;       ~~ /\w **  2..5/;  # OUTPUT: «Nil␤»
say &#39;abc&#39;     ~~ /\w **  2..5/;  # OUTPUT: «｢abc｣␤»
say &#39;abcdefg&#39; ~~ /\w **  2..5/;  # OUTPUT: «｢abcde｣␤»
say &#39;abcdefg&#39; ~~ /\w ** 2^..^5/; # OUTPUT: «｢abcd｣␤»
say &#39;abcdefg&#39; ~~ /\w ** ^3/;     # OUTPUT: «｢ab｣␤»
say &#39;abcdefg&#39; ~~ /\w ** 1..*/;   # OUTPUT: «｢abcdefg｣␤»
</pre>
<p>Only basic literal syntax for the right-hand side of the quantifier is supported, to avoid ambiguities with other regex constructs. If you need to use a more complex expression, for example, a <a href="/Documentable/integration-test/type/Range">Range</a> made from variables, enclose the <a href="/Documentable/integration-test/type/Range">Range</a> in curly braces:</p>
<pre class="pod-block-code">my $start = 3;
say &#39;abcdefg&#39; ~~ /\w ** {$start .. $start+2}/; # OUTPUT: «｢abcde｣␤»
say &#39;abcdefg&#39; ~~ /\w ** {π.Int}/;              # OUTPUT: «｢abc｣␤»
</pre>
<p>Negative values are treated like zero:</p>
<pre class="pod-block-code">say &#39;abcdefg&#39; ~~ /\w ** {-Inf}/;     # OUTPUT: «｢｣␤»
say &#39;abcdefg&#39; ~~ /\w ** {-42}/;      # OUTPUT: «｢｣␤»
say &#39;abcdefg&#39; ~~ /\w ** {-10..-42}/; # OUTPUT: «｢｣␤»
say &#39;abcdefg&#39; ~~ /\w ** {-42..-10}/; # OUTPUT: «｢｣␤»
</pre>
<p>If then, the resultant value is <code>Inf</code> or <code>NaN</code> or the resultant <a href="/Documentable/integration-test/type/Range">Range</a> is empty, non-Numeric, contains <code>NaN</code> end-points, or has minimum effective end-point as <code>Inf</code>, the <code>X::Syntax::Regex::QuantifierValue</code> exception will be thrown:</p>
<pre class="pod-block-code">(try say &#39;abcdefg&#39; ~~ /\w ** {42..10}/  )
    orelse say ($!.^name, $!.empty-range);
    # OUTPUT: «(X::Syntax::Regex::QuantifierValue True)␤»
(try say &#39;abcdefg&#39; ~~ /\w ** {Inf..Inf}/)
    orelse say ($!.^name, $!.inf);
    # OUTPUT: «(X::Syntax::Regex::QuantifierValue True)␤»
(try say &#39;abcdefg&#39; ~~ /\w ** {NaN..42}/ )
    orelse say ($!.^name, $!.non-numeric-range);
    # OUTPUT: «(X::Syntax::Regex::QuantifierValue True)␤»
(try say &#39;abcdefg&#39; ~~ /\w ** {&quot;a&quot;..&quot;c&quot;}/)
    orelse say ($!.^name, $!.non-numeric-range);
    # OUTPUT: «(X::Syntax::Regex::QuantifierValue True)␤»
(try say &#39;abcdefg&#39; ~~ /\w ** {Inf}/)
    orelse say ($!.^name, $!.inf);
    # OUTPUT: «(X::Syntax::Regex::QuantifierValue True)␤»
(try say &#39;abcdefg&#39; ~~ /\w ** {NaN}/)
    orelse say ($!.^name, $!.non-numeric);
    # OUTPUT: «(X::Syntax::Regex::QuantifierValue True)␤»
</pre>
<h2 id="Modified_quantifier:_%,_%%"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_$PERCENT_SIGN-regex_$PERCENT_SIGN$PERCENT_SIGN-Modified_quantifier:_$PERCENT_SIGN,_$PERCENT_SIGN$PERCENT_SIGN"><span class="index-entry">Modified quantifier: <code>%</code>, <code>%%</code></span></a></a></h2>
<p>To more easily match things like comma separated values, you can tack on a <code>%</code> modifier to any of the above quantifiers to specify a separator that must occur between each of the matches. For example, <code>a+ % &#39;,&#39;</code> will match <code>a</code> or <code>a,a</code> or <code>a,a,a</code>, etc. To also match trailing delimiters ( <code>a,</code> or <code>a,a,</code> ), you can use <code>%%</code> instead of <code>%</code>.</p>
<p>The quantifier interacts with <code>%</code> and controls the number of overall repetitions that can match successfully, so <code>a* % &#39;,&#39;</code> also matches the empty string. If you want match words delimited by commas, you might need to nest an ordinary and a modified quantifier:</p>
<pre class="pod-block-code">say so &#39;abc,def&#39; ~~ / ^ [\w+] ** 1 % &#39;,&#39; $ /;  # Output: «False»
say so &#39;abc,def&#39; ~~ / ^ [\w+] ** 2 % &#39;,&#39; $ /;  # Output: «True»
</pre>
<h2 id="Preventing_backtracking:_:"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_:-Preventing_backtracking:_:"><span class="index-entry">Preventing backtracking: <code>:</code></span></a></a></h2>
<p>One way to prevent <a href="/Documentable/integration-test/language/regexes#Preventing_backtracking">backtracking</a> is through the use of the <code>ratchet</code> adverb as described <a href="/Documentable/integration-test/language/regexes#Ratchet">below</a>. Another more fine-grained way of preventing backtracking in regexes is attaching a <code>:</code> modifier to a quantifier:</p>
<pre class="pod-block-code">my $str = &quot;ACG GCT ACT An interesting chain&quot;;
say $str ~~ /&lt;[ACGT\s]&gt;+ \s+ (&lt;[A..Z a..z \s]&gt;+)/;
# OUTPUT: «｢ACG GCT ACT An interesting chain｣␤ 0 =&gt; ｢An interesting chain｣␤»
say $str ~~ /&lt;[ACGT\s]&gt;+: \s+ (&lt;[A..Z a..z \s]&gt;+)/;
# OUTPUT: «Nil␤»
</pre>
<p>In the second case, the <code>A</code> in <code>An</code> had already been &quot;absorbed&quot; by the pattern, preventing the matching of the second part of the pattern, after <code>\s+</code>. Generally we will want the opposite: prevent backtracking to match precisely what we are looking for.</p>
<p>In most cases, you will want to prevent backtracking for efficiency reasons, for instance here:</p>
<pre class="pod-block-code">say $str ~~ m:g/[(&lt;[ACGT]&gt; **: 3) \s*]+ \s+ (&lt;[A..Z a..z \s]&gt;+)/;
# OUTPUT:
# «(｢ACG GCT ACT An interesting chain｣
# «0 =&gt; ｢ACG｣␤»
# «0 =&gt; ｢GCT｣␤»
# «0 =&gt; ｢ACT｣␤»
# «1 =&gt; ｢An interesting chain｣)␤»
</pre>
<p>Although in this case, eliminating the <code>:</code> from behind <code>**</code> would make it behave exactly in the same way. The best use is to create <em>tokens</em> that will not be backtracked:</p>
<pre class="pod-block-code">$_ = &quot;ACG GCT ACT IDAQT&quot;;
say  m:g/[(\w+:) \s*]+ (\w+) $$/;
# OUTPUT:
# «(｢ACG GCT ACT IDAQT｣␤»
# «0 =&gt; ｢ACG｣␤»
# «0 =&gt; ｢GCT｣␤»
# «0 =&gt; ｢ACT｣␤»
# «1 =&gt; ｢IDAQT｣)␤»</pre>
<p>Without the <code>:</code> following <code>\w+</code>, the <em>ID</em> part captured would have been simply <code>T</code>, since the pattern would go ahead and match everything, leaving a single letter to match the <code>\w+</code> expression at the end of the line.</p>
<h2 id="Greedy_versus_frugal_quantifiers:_?"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_?-Greedy_versus_frugal_quantifiers:_?"><span class="index-entry">Greedy versus frugal quantifiers: <code>?</code></span></a></a></h2>
<p>By default, quantifiers request a greedy match:</p>
<pre class="pod-block-code">&#39;abababa&#39; ~~ /a .* a/ &amp;&amp; say ~$/;   # OUTPUT: «abababa␤»
</pre>
<p>You can attach a <code>?</code> modifier to the quantifier to enable frugal matching:</p>
<pre class="pod-block-code">&#39;abababa&#39; ~~ /a .*? a/ &amp;&amp; say ~$/;   # OUTPUT: «aba␤»
</pre>
<p>You can also enable frugal matching for general quantifiers:</p>
<pre class="pod-block-code">say &#39;/foo/o/bar/&#39; ~~ /\/.**?{1..10}\//;  # OUTPUT: «｢/foo/｣␤»
say &#39;/foo/o/bar/&#39; ~~ /\/.**!{1..10}\//;  # OUTPUT: «｢/foo/o/bar/｣␤»</pre>
<p>Greedy matching can be explicitly requested with the <code>!</code> modifier.</p>
<h1 id="Alternation:_||"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_||-Alternation:_||"><span class="index-entry">Alternation: <code>||</code></span></a></a></h1>
<p>To match one of several possible alternatives, separate them by <code>||</code>; the first matching alternative wins.</p>
<p>For example, <code>ini</code> files have the following form:</p>
<pre class="pod-block-code">[section]
key = value
</pre>
<p>Hence, if you parse a single line of an <code>ini</code> file, it can be either a section or a key-value pair and the regex would be (to a first approximation):</p>
<pre class="pod-block-code">/ &#39;[&#39; \w+ &#39;]&#39; || \S+ \s* &#39;=&#39; \s* \S* /</pre>
<p>That is, either a word surrounded by square brackets, or a string of non-whitespace characters, followed by zero or more spaces, followed by the equals sign <code>=</code>, followed again by optional whitespace, followed by another string of non-whitespace characters.</p>
<p>An empty string as the first branch is ignored, to allow you to format branches consistently. You could have written the previous example as</p>
<pre class="pod-block-code">/
|| &#39;[&#39; \w+ &#39;]&#39;
|| \S+ \s* &#39;=&#39; \s* \S*
/</pre>
<p>Even in non-backtracking contexts, the alternation operator <code>||</code> tries all the branches in order until the first one matches.</p>
<h1 id="Longest_alternation:_|"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_|-Longest_alternation:_|"><span class="index-entry">Longest alternation: <code>|</code></span></a></a></h1>
<p>In short, in regex branches separated by <code>|</code>, the longest token match wins, independent of the textual ordering in the regex. However, what <code>|</code> really does is more than that. It does not decide which branch wins after finishing the whole match, but follows the <a href="https://design.raku.org/S05.html#Longest-token_matching">longest-token matching (LTM) strategy</a>.</p>
<p>Briefly, what <code>|</code> does is this:</p>
<ul><li><p>First, select the branch which has the longest declarative prefix.</p>
</li>
</ul>
<pre class="pod-block-code">say &quot;abc&quot; ~~ /ab | a.* /;                 # Output: «⌜abc⌟␤»
say &quot;abc&quot; ~~ /ab | a {} .* /;             # Output: «⌜ab⌟␤»
say &quot;if else&quot; ~~ / if | if &lt;.ws&gt; else /;  # Output: «｢if｣␤»
say &quot;if else&quot; ~~ / if | if \s+   else /;  # Output: «｢if else｣␤»</pre>
<p>As is shown above, <code>a.*</code> is a declarative prefix, while <code>a {} .*</code> terminates at <code>{}</code>, then its declarative prefix is <code>a</code>. Note that non-declarative atoms terminate declarative prefix. This is quite important if you want to apply <code>|</code> in a <code>rule</code>, which automatically enables <code>:s</code>, and <code>&lt;.ws&gt;</code> accidentally terminates declarative prefix.</p>
<ul><li><p>If it&#39;s a tie, select the match with the highest specificity.</p>
</li>
</ul>
<pre class="pod-block-code">say &quot;abc&quot; ~~ /a. | ab { print &quot;win&quot; } /;  # Output: «win｢ab｣␤»</pre>
<p>When two alternatives match at the same length, the tie is broken by specificity. That is, <code>ab</code>, as an exact match, counts as closer than <code>a.</code>, which uses character classes.</p>
<ul><li><p>If it&#39;s still a tie, use additional tie-breakers.</p>
</li>
</ul>
<pre class="pod-block-code">say &quot;abc&quot; ~~ /a\w| a. { print &quot;lose&quot; } /; # Output: «⌜ab⌟␤»</pre>
<p>If the tie breaker above doesn&#39;t work, then the textually earlier alternative takes precedence.</p>
<p>For more details, see <a href="https://design.raku.org/S05.html#Longest-token_matching">the LTM strategy</a>.</p>
<h2 id="Quoted_lists_are_LTM_matches"><a class="u" href="#___top" title="go to top of document">Quoted lists are LTM matches</a></h2>
<p>Using a quoted list in a regex is equivalent to specifying the longest-match alternation of the list&#39;s elements. So, the following match:</p>
<pre class="pod-block-code">say &#39;food&#39; ~~ /&lt; f fo foo food &gt;/;      # OUTPUT: «｢food｣␤»</pre>
<p>is equivalent to:</p>
<pre class="pod-block-code">say &#39;food&#39; ~~ / f | fo | foo | food /;  # OUTPUT: «｢food｣␤»</pre>
<p>Note that the space after the first <code>&lt;</code> is significant here: <code>&lt;food&gt;</code> calls the named rule <code>food</code> while <code>&lt; food &gt;</code> and <code>&lt; food&gt;</code> specify quoted lists with a single element, <code>&#39;food&#39;</code>.</p>
<p>If the first branch is an empty string, it is ignored. This allows you to format your regexes consistently:</p>
<pre class="pod-block-code">/
| f
| fo
| foo
| food
/</pre>
<p>Arrays can also be interpolated into a regex to achieve the same effect:</p>
<pre class="pod-block-code">my @increasingly-edible = &lt;f fo foo food&gt;;
say &#39;food&#39; ~~ /@increasingly-edible/;   # OUTPUT: «｢food｣␤»</pre>
<p>This is documented further under <a href="#Regex_interpolation">Regex Interpolation</a>, below.</p>
<h1 id="Conjunction:_&&"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_&&-Conjunction:_&&"><span class="index-entry">Conjunction: <code>&amp;&amp;</code></span></a></a></h1>
<p>Matches successfully if all <code>&amp;&amp;</code>-delimited segments match the same substring of the target string. The segments are evaluated left to right.</p>
<p>This can be useful for augmenting an existing regex. For example if you have a regex <code>quoted</code> that matches a quoted string, then <code>/ &lt;quoted&gt; &amp;&amp; &lt;-[x]&gt;* /</code> matches a quoted string that does not contain the character <code>x</code>.</p>
<p>Note that you cannot easily obtain the same behavior with a lookahead, that is, a regex doesn&#39;t consume characters, because a lookahead doesn&#39;t stop looking when the quoted string stops matching.</p>
<pre class="pod-block-code">say &#39;abc&#39; ~~ / &lt;?before a&gt; &amp;&amp; . /;    # OUTPUT: «Nil␤»
say &#39;abc&#39; ~~ / &lt;?before a&gt; . &amp;&amp; . /;  # OUTPUT: «｢a｣␤»
say &#39;abc&#39; ~~ / &lt;?before a&gt; . /;       # OUTPUT: «｢a｣␤»
say &#39;abc&#39; ~~ / &lt;?before a&gt; .. /;      # OUTPUT: «｢ab｣␤»
</pre>
<p>Just like with <code>||</code>, empty first branches are ignored.</p>
<h1 id="Conjunction:_&"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_&-Conjunction:_&"><span class="index-entry">Conjunction: <code>&amp;</code></span></a></a></h1>
<p>Much like <code>&amp;&amp;</code> in a regex, it matches successfully if all segments separated by <code>&amp;</code> match the same part of the target string.</p>
<p><code>&amp;</code> (unlike <code>&amp;&amp;</code>) is considered declarative, and notionally all the segments can be evaluated in parallel, or in any order the compiler chooses.</p>
<p>Just like with <code>||</code> and <code>&amp;</code>, empty first branches are ignored.</p>
<h1 id="Anchors"><a class="u" href="#___top" title="go to top of document">Anchors</a></h1>
<p>Regexes search an entire string for matches. Sometimes this is not what you want. Anchors match only at certain positions in the string, thereby anchoring the regex match to that position.</p>
<h2 id="Start_of_string_and_end_of_string"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_$CIRCUMFLEX_ACCENT-regex_$-Start_of_string_and_end_of_string"><span class="index-entry">Start of string and end of string</span></a></a></h2>
<p>The <code>^</code> anchor only matches at the start of the string:</p>
<pre class="pod-block-code">say so &#39;properly&#39; ~~ /  perl/;    # OUTPUT: «True␤»
say so &#39;properly&#39; ~~ /^ perl/;    # OUTPUT: «False␤»
say so &#39;perly&#39;    ~~ /^ perl/;    # OUTPUT: «True␤»
say so &#39;perl&#39;     ~~ /^ perl/;    # OUTPUT: «True␤»</pre>
<p>The <code>$</code> anchor only matches at the end of the string:</p>
<pre class="pod-block-code">say so &#39;use perl&#39; ~~ /  perl  /;   # OUTPUT: «True␤»
say so &#39;use perl&#39; ~~ /  perl $/;   # OUTPUT: «True␤»
say so &#39;perly&#39;    ~~ /  perl $/;   # OUTPUT: «False␤»</pre>
<p>You can combine both anchors:</p>
<pre class="pod-block-code">say so &#39;use perl&#39; ~~ /^ perl $/;   # OUTPUT: «False␤»
say so &#39;perl&#39;     ~~ /^ perl $/;   # OUTPUT: «True␤»</pre>
<p>Keep in mind that <code>^</code> matches the start of a <strong>string</strong>, not the start of a <strong>line</strong>. Likewise, <code>$</code> matches the end of a <strong>string</strong>, not the end of a <strong>line</strong>.</p>
<p>The following is a multi-line string:</p>
<pre class="pod-block-code">my $str = chomp q:to/EOS/;
   Keep it secret
   and keep it safe
   EOS

# &#39;safe&#39; is at the end of the string
say so $str ~~ /safe   $/;   # OUTPUT: «True␤»

# &#39;secret&#39; is at the end of a line, not the string
say so $str ~~ /secret $/;   # OUTPUT: «False␤»

# &#39;Keep&#39; is at the start of the string
say so $str ~~ /^Keep   /;   # OUTPUT: «True␤»

# &#39;and&#39; is at the start of a line -- not the string
say so $str ~~ /^and    /;   # OUTPUT: «False␤»</pre>
<h2 id="Start_of_line_and_end_of_line"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_$CIRCUMFLEX_ACCENT$CIRCUMFLEX_ACCENT-regex_$$-Start_of_line_and_end_of_line"><span class="index-entry">Start of line and end of line</span></a></a></h2>
<p>The <code>^^</code> anchor matches at the start of a logical line. That is, either at the start of the string, or after a newline character. However, it does not match at the end of the string, even if it ends with a newline character.</p>
<p>The <code>$$</code> anchor matches at the end of a logical line. That is, before a newline character, or at the end of the string when the last character is not a newline character.</p>
<p>To understand the following example, it&#39;s important to know that the <code>q:to/EOS/...EOS</code> <a href="/Documentable/integration-test/language/quoting#Heredocs:_:to">heredoc</a> syntax removes leading indention to the same level as the <code>EOS</code> marker, so that the first, second and last lines have no leading space and the third and fourth lines have two leading spaces each.</p>
<pre class="pod-block-code">my $str = q:to/EOS/;
    There was a young man of Japan
    Whose limericks never would scan.
      When asked why this was,
      He replied &quot;It&#39;s because I always try to fit
    as many syllables into the last line as ever I possibly can.&quot;
    EOS

# &#39;There&#39; is at the start of string
say so $str ~~ /^^ There/;        # OUTPUT: «True␤»

# &#39;limericks&#39; is not at the start of a line
say so $str ~~ /^^ limericks/;    # OUTPUT: «False␤»

# &#39;as&#39; is at start of the last line
say so $str ~~ /^^ as/;            # OUTPUT: «True␤»

# there are blanks between start of line and the &quot;When&quot;
say so $str ~~ /^^ When/;         # OUTPUT: «False␤»

# &#39;Japan&#39; is at end of first line
say so $str ~~ / Japan $$/;       # OUTPUT: «True␤»

# there&#39;s a . between &quot;scan&quot; and the end of line
say so $str ~~ / scan $$/;        # OUTPUT: «False␤»

# matched at the last line
say so $str ~~ / &#39;.&quot;&#39; $$/;        # OUTPUT: «True␤»</pre>
<h2 id="Word_boundary"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex__<|w>-regex__<!|w>-Word_boundary"><span class="index-entry">Word boundary</span></a></a></h2>
<p>To match any word boundary, use <code>&lt;|w&gt;</code> or <code>&lt;?wb&gt;</code>. This is similar to <a name="Documentable/integration-test/index-entry-regex_deprecated_\b-\b"><span class="index-entry"><code>\b</code></span></a> in other languages. To match the opposite, any character that is not bounding a word, use <code>&lt;!|w&gt;</code> or <code>&lt;!wb&gt;</code>. This is similar to <a name="Documentable/integration-test/index-entry-regex_deprecated_\B-\B"><span class="index-entry"><code>\B</code></span></a> in other languages; <code>\b</code> and <code>\B</code> will throw an <a href="/Documentable/integration-test/type/X::Obsolete"><code>X::Obsolete</code></a> exception from version 6.d of Raku.</p>
<p>These are both zero-width regex elements.</p>
<pre class="pod-block-code">say &quot;two-words&quot; ~~ / two&lt;|w&gt;\-&lt;|w&gt;words /;    # OUTPUT: «｢two-words｣␤»
say &quot;twowords&quot; ~~ / two&lt;!|w&gt;&lt;!|w&gt;words /;     # OUTPUT: «｢twowords｣»</pre>
<p><a name="Documentable/integration-test/index-entry-regex__<<-_regex__>>-_regex__«-_regex__»"></a></p>
<h2 id="Left_and_right_word_boundary"><a class="u" href="#___top" title="go to top of document">Left and right word boundary</a></h2>
<p><code>&lt;&lt;</code> matches a left word boundary. It matches positions where there is a non-word character at the left, or the start of the string, and a word character to the right.</p>
<p><code>&gt;&gt;</code> matches a right word boundary. It matches positions where there is a word character at the left and a non-word character at the right, or the end of the string.</p>
<p>These are both zero-width regex elements.</p>
<pre class="pod-block-code">my $str = &#39;The quick brown fox&#39;;
say so &#39; &#39; ~~ /\W/;               # OUTPUT: «True␤»
say so $str ~~ /br/;              # OUTPUT: «True␤»
say so $str ~~ /&lt;&lt; br/;           # OUTPUT: «True␤»
say so $str ~~ /br &gt;&gt;/;           # OUTPUT: «False␤»
say so $str ~~ /own/;             # OUTPUT: «True␤»
say so $str ~~ /&lt;&lt; own/;          # OUTPUT: «False␤»
say so $str ~~ /own &gt;&gt;/;          # OUTPUT: «True␤»
say so $str ~~ /&lt;&lt; The/;          # OUTPUT: «True␤»
say so $str ~~ /fox &gt;&gt;/;          # OUTPUT: «True␤»</pre>
<p>You can also use the variants <code>«</code> and <code>»</code> :</p>
<pre class="pod-block-code">my $str = &#39;The quick brown fox&#39;;
say so $str ~~ /« own/;          # OUTPUT: «False␤»
say so $str ~~ /own »/;          # OUTPUT: «True␤»</pre>
<p>To see the difference between <code>&lt;|w&gt;</code> and <code>«</code>, <code>»</code>:</p>
<pre class="pod-block-code">say &quot;stuff here!!!&quot;.subst(:g, /&gt;&gt;/, &#39;|&#39;);   # OUTPUT: «stuff| here|!!!␤»
say &quot;stuff here!!!&quot;.subst(:g, /&lt;&lt;/, &#39;|&#39;);   # OUTPUT: «|stuff |here!!!␤»
say &quot;stuff here!!!&quot;.subst(:g, /&lt;|w&gt;/, &#39;|&#39;); # OUTPUT: «|stuff| |here|!!!␤»</pre>
<h2 id="Summary_of_anchors"><a class="u" href="#___top" title="go to top of document">Summary of anchors</a></h2>
<p>Anchors are zero-width regex elements. Hence they do not use up a character of the input string, that is, they do not advance the current position at which the regex engine tries to match. A good mental model is that they match between two characters of an input string, or before the first, or after the last character of an input string.</p>
<table class="pod-table">
<thead><tr>
<th>Anchor</th> <th>Description</th> <th>Examples</th>
</tr></thead>
<tbody>
<tr> <td>^</td> <td>Start of string</td> <td>&quot;⏏two\nlines&quot;</td> </tr> <tr> <td>^^</td> <td>Start of line</td> <td>&quot;⏏two\n⏏lines&quot;</td> </tr> <tr> <td>$</td> <td>End of string</td> <td>&quot;two\nlines⏏&quot;</td> </tr> <tr> <td>$$</td> <td>End of line</td> <td>&quot;two⏏\nlines⏏&quot;</td> </tr> <tr> <td>&lt;&lt; or «</td> <td>Left word boundary</td> <td>&quot;⏏two ⏏words&quot;</td> </tr> <tr> <td>&gt;&gt; or »</td> <td>Right word boundary</td> <td>&quot;two⏏ words⏏&quot;</td> </tr> <tr> <td>&lt;?wb&gt;</td> <td>Any word boundary</td> <td>&quot;⏏two⏏ ⏏words⏏~!&quot;</td> </tr> <tr> <td>&lt;!wb&gt;</td> <td>Not a word boundary</td> <td>&quot;t⏏w⏏o w⏏o⏏r⏏d⏏s~⏏!&quot;</td> </tr> <tr> <td>&lt;?ww&gt;</td> <td>Within word</td> <td>&quot;t⏏w⏏o w⏏o⏏r⏏d⏏s~!&quot;</td> </tr> <tr> <td>&lt;!ww&gt;</td> <td>Not within word</td> <td>&quot;⏏two⏏ ⏏words⏏~⏏!⏏&quot;</td> </tr>
</tbody>
</table><h1 id="Zero-width_assertions"><a class="u" href="#___top" title="go to top of document">Zero-width assertions</a></h1>
<p>Zero-Width assertions can help you implement your own anchor: it turns another regex into an anchor, making them consume no characters of the input string. There are two variants: lookahead and lookbehind assertions.</p>
<p>Technically, anchors are also zero-width assertions, and they can look both ahead and behind.</p>
<h2 id="Lookaround_assertions"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_positive_lookaround_assertion__<?>-regex_negative_lookaround_assertion__<!>-_regex_?[_-Lookaround_assertions"><span class="index-entry">Lookaround assertions</span></a></a></h2>
<p>Lookaround assertions, which need a character class in its simpler form, work both ways. They match, but they don&#39;t consume a character.</p>
<pre class="pod-block-code">my regex key {^^ &lt;![#-]&gt; \d+ }
say &quot;333&quot; ~~ &amp;key;                  # OUTPUT: «｢333｣␤»
say &#39;333$&#39; ~~ m/ \d+ &lt;?[$]&gt;/;       # OUTPUT: «｢333｣␤»
say &#39;$333&#39; ~~ m/^^ &lt;?[$]&gt; . \d+ /;  # OUTPUT: «｢$333｣␤»
</pre>
<p>They can be positive or negative: <code>![]</code> is negative, while <code>?[]</code> is positive; the square brackets will contain the characters or backslashed character classes that are going to be matched.</p>
<p>You can use predefined character classes and Unicode properties directly preceded by the exclamation or interrogation mark to convert them into lookaround assertions.:</p>
<pre class="pod-block-code">say &#39;333&#39; ~~ m/^^ &lt;?alnum&gt; \d+ /;          # OUTPUT: «｢333｣␤»
say &#39;333&#39; ~~ m/^^ &lt;?:Nd&gt; \d+ /;            # OUTPUT: «｢333｣␤»
say &#39;333&#39; ~~ m/^^ &lt;!:L&gt; \d+ /;             # OUTPUT: «｢333｣␤»
say &#39;333&#39; ~~ m/^^ \d+ &lt;!:Script&lt;Tamil&gt;&gt; /; # OUTPUT: «｢33｣␤»
</pre>
<p>In the first two cases, the corresponding character class matches, but does not consume, the first digit, which is then consumed by the expression; in the third, the negative lookaround assertion behaves in the same way. In the fourth statement the last digit is matched but not consumed, thus the match includes only the first two digits.</p>
<h2 id="Lookahead_assertions"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex__before-regex__<?before>-Lookahead_assertions"><span class="index-entry">Lookahead assertions</span></a></a></h2>
<p>To check that a pattern appears before another pattern, use a lookahead assertion via the <code>before</code> assertion. This has the form:</p>
<pre class="pod-block-code">&lt;?before pattern&gt;</pre>
<p>Thus, to search for the string <code>foo</code> which is immediately followed by the string <code>bar</code>, use the following regexp:</p>
<pre class="pod-block-code">/ foo &lt;?before bar&gt; /</pre>
<p>For example:</p>
<pre class="pod-block-code">say &quot;foobar&quot; ~~ / foo &lt;?before bar&gt; /;  # OUTPUT: «foo␤»</pre>
<p>However, if you want to search for a pattern which is <strong>not</strong> immediately followed by some pattern, then you need to use a negative lookahead assertion, this has the form:</p>
<pre class="pod-block-code">&lt;!before pattern&gt;</pre>
<p>In the following example, all occurrences of <code>foo</code> which is not before <code>bar</code> would match with</p>
<pre class="pod-block-code">say &quot;foobaz&quot; ~~ / foo &lt;!before bar&gt; /;  # OUTPUT: «foo␤»</pre>
<p>Lookahead assertions can be used also with other patterns, like characters ranges, interpolated variables subscripts and so on. In such cases it does suffice to use a <code>?</code>, or a <code>!</code> for the negate form. For instance, the following lines all produce the very same result:</p>
<pre class="pod-block-code">say &#39;abcdefg&#39; ~~ rx{ abc &lt;?before def&gt; };        # OUTPUT: «｢abc｣␤»
say &#39;abcdefg&#39; ~~ rx{ abc &lt;?[ d..f ]&gt; };          # OUTPUT: «｢abc｣␤»
my @ending_letters = &lt;d e f&gt;;
say &#39;abcdefg&#39; ~~ rx{ abc &lt;?@ending_letters&gt; };   # OUTPUT: «｢abc｣␤»</pre>
<p>Metacharacters can also be used in lookahead or -behind assertions.</p>
<pre class="pod-block-code">say &quot;First. Second&quot; ~~ m:g/ &lt;?after ^^ | &quot;.&quot; \s+&gt; &lt;:Lu&gt;\S+ /
# OUTPUT: «(｢First.｣ ｢Second｣)␤»</pre>
<p>A practical use of lookahead assertions is in substitutions, where you only want to substitute regex matches that are in a certain context. For example, you might want to substitute only numbers that are followed by a unit (like <em>kg</em>), but not other numbers:</p>
<pre class="pod-block-code">my @units = &lt;kg m km mm s h&gt;;
$_ = &quot;Please buy 2 packs of sugar, 1 kg each&quot;;
s:g[\d+ &lt;?before \s* @units&gt;] = 5 * $/;
say $_;         # OUTPUT: «Please buy 2 packs of sugar, 5 kg each␤»</pre>
<p>Since the lookahead is not part of the match object, the unit is not substituted.</p>
<h2 id="Lookbehind_assertions"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex__after-_regex__<?after>-Lookbehind_assertions"><span class="index-entry">Lookbehind assertions</span></a></a></h2>
<p>To check that a pattern appears after another pattern, use a lookbehind assertion via the <code>after</code> assertion. This has the form:</p>
<pre class="pod-block-code">&lt;?after pattern&gt;</pre>
<p>Therefore, to search for the string <code>bar</code> immediately preceded by the string <code>foo</code>, use the following regexp:</p>
<pre class="pod-block-code">/ &lt;?after foo&gt; bar /</pre>
<p>For example:</p>
<pre class="pod-block-code">say &quot;foobar&quot; ~~ / &lt;?after foo&gt; bar /;   # OUTPUT: «bar␤»</pre>
<p>However, if you want to search for a pattern which is <strong>not</strong> immediately preceded by some pattern, then you need to use a negative lookbehind assertion, this has the form:</p>
<pre class="pod-block-code">&lt;!after pattern&gt;</pre>
<p>Hence all occurrences of <code>bar</code> which do not have <code>foo</code> before them would be matched by</p>
<pre class="pod-block-code">say &quot;fotbar&quot; ~~ / &lt;!after foo&gt; bar /;    # OUTPUT: «bar␤»</pre>
<p>These are, as in the case of lookahead, zero-width assertions which do not <em>consume</em> characters, like here:</p>
<pre class="pod-block-code">say &quot;atfoobar&quot; ~~ / (.**3) .**2 &lt;?after foo&gt; bar /;
# OUTPUT: «｢atfoobar｣␤ 0 =&gt; ｢atf｣␤»</pre>
<p>where we capture the first 3 of the 5 characters before bar, but only if <code>bar</code> is preceded by <code>foo</code>. The fact that the assertion is zero-width allows us to use part of the characters in the assertion for capture.</p>
<h1 id="Grouping_and_capturing"><a class="u" href="#___top" title="go to top of document">Grouping and capturing</a></h1>
<p>In regular (non-regex) Raku, you can use parentheses to group things together, usually to override operator precedence:</p>
<pre class="pod-block-code">say 1 + 4 * 2;     # OUTPUT: «9␤», parsed as 1 + (4 * 2)
say (1 + 4) * 2;   # OUTPUT: «10␤»</pre>
<p>The same grouping facility is available in regexes:</p>
<pre class="pod-block-code">/ a || b c /;      # matches &#39;a&#39; or &#39;bc&#39;
/ ( a || b ) c /;  # matches &#39;ac&#39; or &#39;bc&#39;</pre>
<p>The same grouping applies to quantifiers:</p>
<pre class="pod-block-code">/ a b+ /;          # matches an &#39;a&#39; followed by one or more &#39;b&#39;s
/ (a b)+ /;        # matches one or more sequences of &#39;ab&#39;
/ (a || b)+ /;     # matches a string of &#39;a&#39;s and &#39;b&#39;s, except empty string</pre>
<p>An unquantified capture produces a <a href="/Documentable/integration-test/type/Match">Match</a> object. When a capture is quantified (except with the <code>?</code> quantifier) the capture becomes a list of <a href="/Documentable/integration-test/type/Match">Match</a> objects instead.</p>
<h2 id="Capturing"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_(_)-Capturing"><span class="index-entry">Capturing</span></a></a></h2>
<p>The round parentheses don&#39;t just group, they also <em>capture</em>; that is, they make the string matched within the group available as a variable, and also as an element of the resulting <a href="/Documentable/integration-test/type/Match">Match</a> object:</p>
<pre class="pod-block-code">my $str =  &#39;number 42&#39;;
if $str ~~ /&#39;number &#39; (\d+) / {
    say &quot;The number is $0&quot;;         # OUTPUT: «The number is 42␤»
    # or
    say &quot;The number is $/[0]&quot;;      # OUTPUT: «The number is 42␤»
}</pre>
<p>Pairs of parentheses are numbered left to right, starting from zero.</p>
<pre class="pod-block-code">if &#39;abc&#39; ~~ /(a) b (c)/ {
    say &quot;0: $0; 1: $1&quot;;             # OUTPUT: «0: a; 1: c␤»
}</pre>
<p>The <code>$0</code> and <code>$1</code> etc. syntax is shorthand. These captures are canonically available from the match object <code>$/</code> by using it as a list, so <code>$0</code> is actually syntactic sugar for <code>$/[0]</code>.</p>
<p>Coercing the match object to a list gives an easy way to programmatically access all elements:</p>
<pre class="pod-block-code">if &#39;abc&#39; ~~ /(a) b (c)/ {
    say $/.list.join: &#39;, &#39;  # OUTPUT: «a, c␤»
}</pre>
<h2 id="Non-capturing_grouping"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_[_]-Non-capturing_grouping"><span class="index-entry">Non-capturing grouping</span></a></a></h2>
<p>The parentheses in regexes perform a double role: they group the regex elements inside and they capture what is matched by the sub-regex inside.</p>
<p>To get only the grouping behavior, you can use square brackets <code>[ ... ]</code> which, by default, don&#39;t capture.</p>
<pre class="pod-block-code">if &#39;abc&#39; ~~ / [a||b] (c) / {
    say ~$0;                # OUTPUT: «c␤»
}</pre>
<p>If you do not need the captures, using non-capturing <code>[ ... ]</code> groups provides the following benefits:</p>
<ul><li><p>they more cleanly communicate the regex intent,</p>
</li>
<li><p>they make it easier to count the capturing groups that do mean and</p>
</li>
<li><p>they make matching a bit faster.</p>
</li>
</ul>
<h2 id="Capture_numbers"><a class="u" href="#___top" title="go to top of document">Capture numbers</a></h2>
<p>It is stated above that captures are numbered from left to right. While true in principle, this is also an over simplification.</p>
<p>The following rules are listed for the sake of completeness. When you find yourself using them regularly, it&#39;s worth considering named captures (and possibly subrules) instead.</p>
<p>Alternations reset the capture count:</p>
<pre class="pod-block-code">/ (x) (y)  || (a) (.) (.) /
# $0  $1      $0  $1  $2</pre>
<p>Example:</p>
<pre class="pod-block-code">if &#39;abc&#39; ~~ /(x)(y) || (a)(.)(.)/ {
    say ~$1;        # OUTPUT: «b␤»
}</pre>
<p>If two (or more) alternations have a different number of captures, the one with the most captures determines the index of the next capture:</p>
<pre class="pod-block-code">if &#39;abcd&#39; ~~ / a [ b (.) || (x) (y) ] (.) / {
    #                 $0     $0  $1    $2
    say ~$2;            # OUTPUT: «d␤»
}</pre>
<p>Captures can be nested, in which case they are numbered per level; level 0 gets to use the capture variables, but it will become a list with the rest of the levels behaving as elements of that list</p>
<pre class="pod-block-code">if &#39;abc&#39; ~~ / ( a (.) (.) ) / {
    say &quot;Outer: $0&quot;;                # OUTPUT: «Outer: abc␤»
    say &quot;Inner: $0[0] and $0[1]&quot;;   # OUTPUT: «Inner: b and c␤»
}</pre>
<p>These capture variables are only available outside the regex.</p>
<pre class="pod-block-code"># !!WRONG!! The $0 refers to a capture *inside* the second capture
say &quot;11&quot; ~~ /(\d) ($0)/; # OUTPUT: «Nil␤»
</pre>
<p>In order to make them available inside the regex, you need to insert a code block behind the match; this code block may be empty if there&#39;s nothing meaningful to do:</p>
<pre class="pod-block-code"># CORRECT: $0 is saved into a variable outside the second capture
# before it is used inside
say &quot;11&quot; ~~ /(\d) {} :my $c = $0; ($c)/; # OUTPUT: «｢11｣␤ 0 =&gt; ｢1｣␤ 1 =&gt; ｢1｣␤»
say &quot;Matched $c&quot;; # OUTPUT: «␤Matched 1␤»
</pre>
<p>This code block <em>publishes</em> the capture inside the regex, so that it can be assigned to other variables or used for subsequent matches</p>
<pre class="pod-block-code">say &quot;11&quot; ~~ /(\d) {} $0/; # OUTPUT: «｢11｣␤ 0 =&gt; ｢1｣␤»
</pre>
<p><a name="Documentable/integration-test/index-entry-:my"></a> <code>:my</code> helps scoping the <code>$c</code> variable within the regex and beyond; in this case we can use it in the next sentence to show what has been matched inside the regex. This can be used for debugging inside regular expressions, for instance:</p>
<pre class="pod-block-code">my $paragraph=&quot;line\nline2\nline3&quot;;
$paragraph ~~ rx| :my $counter = 0; ( \V* { ++$counter } ) *%% \n |;
say &quot;Matched $counter lines&quot;; # OUTPUT: «Matched 3 lines␤»</pre>
<p>Since <code>:my</code> blocks are simply declarations, the match variable <code>$/</code> or numbered matches such as <code>$0</code> will not be available in them unless they are previously <em>published</em> by inserting the empty block (or any block):</p>
<pre class="pod-block-code">&quot;aba&quot; ~~ / (a) b {} :my $c = $/; /;
say $c; # OUTPUT: «｢ab｣␤ 0 =&gt; ｢a｣␤»
</pre>
<p>Any other code block will also reveal the variables and make them available in declarations:</p>
<pre class="pod-block-code">&quot;aba&quot; ~~ / (a) {say &quot;Check so far &quot;, ~$/} b :my $c = ~$0; /;
# OUTPUT: «Check so far a␤»
say &quot;Capture $c&quot;; # OUTPUT: «Capture a␤»
</pre>
<p><a name="Documentable/integration-test/index-entry-:our"></a> The <code>:our</code>, similarly to <a href="/Documentable/integration-test/syntax/our"><code>our</code></a> in classes, can be used in <a href="/Documentable/integration-test/type/Grammar">Grammar</a>s to declare variables that can be accessed, via its fully qualified name, from outside the grammar:</p>
<pre class="pod-block-code">grammar HasOur {
    token TOP {
        :our $our = &#39;Þor&#39;;
        $our \s+ is \s+ mighty
    }
}

say HasOur.parse(&#39;Þor is mighty&#39;); # OUTPUT: «｢Þor is mighty｣␤»
say $HasOur::our;                  # OUTPUT: «Þor␤»
</pre>
<p>Once the parsing has been done successfully, we use the FQN name of the <code>$our</code> variable to access its value, that can be none other than <code>Þor</code>.</p>
<h2 id="Named_captures"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex__Named_captures-Named_captures"><span class="index-entry">Named captures</span></a></a></h2>
<p>Instead of numbering captures, you can also give them names. The generic, and slightly verbose, way of naming captures is like this:</p>
<pre class="pod-block-code">if &#39;abc&#39; ~~ / $&lt;myname&gt; = [ \w+ ] / {
    say ~$&lt;myname&gt;      # OUTPUT: «abc␤»
}</pre>
<p>The square brackets in the above example, which don&#39;t usually capture, will now capture its grouping with the given name.</p>
<p>The access to the named capture, <code>$&lt;myname&gt;</code>, is a shorthand for indexing the match object as a hash, in other words: <code>$/{ &#39;myname&#39; }</code> or <code>$/&lt;myname&gt;</code>.</p>
<p>We can also use parentheses in the above example, but they will work exactly the same as square brackets. The captured group will only be accessible by its name as a key from the match object and not from its position in the list with <code>$/[0]</code> or <code>$0</code>.</p>
<p>Named captures can also be nested using regular capture group syntax:</p>
<pre class="pod-block-code">if &#39;abc-abc-abc&#39; ~~ / $&lt;string&gt;=( [ $&lt;part&gt;=[abc] ]* % &#39;-&#39; ) / {
    say ~$&lt;string&gt;;          # OUTPUT: «abc-abc-abc␤»
    say ~$&lt;string&gt;&lt;part&gt;;    # OUTPUT: «abc abc abc␤»
    say ~$&lt;string&gt;&lt;part&gt;[0]; # OUTPUT: «abc␤»
}</pre>
<p>Coercing the match object to a hash gives you easy programmatic access to all named captures:</p>
<pre class="pod-block-code">if &#39;count=23&#39; ~~ / $&lt;variable&gt;=\w+ &#39;=&#39; $&lt;value&gt;=\w+ / {
    my %h = $/.hash;
    say %h.keys.sort.join: &#39;, &#39;;        # OUTPUT: «value, variable␤»
    say %h.values.sort.join: &#39;, &#39;;      # OUTPUT: «23, count␤»
    for %h.kv -&gt; $k, $v {
        say &quot;Found value &#39;$v&#39; with key &#39;$k&#39;&quot;;
        # outputs two lines:
        #   Found value &#39;count&#39; with key &#39;variable&#39;
        #   Found value &#39;23&#39; with key &#39;value&#39;
    }
}</pre>
<p>A more convenient way to get named captures is by using named regex as discussed in the <a href="/Documentable/integration-test/language/regexes#Subrules">Subrules</a> section.</p>
<h2 id="Capture_markers:_<(_)>"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_<(_)>-Capture_markers:_<(_)>"><span class="index-entry">Capture markers: <code>&lt;( )&gt;</code></span></a></a></h2>
<p>A <code>&lt;(</code> token indicates the start of the match&#39;s overall capture, while the corresponding <code>)&gt;</code> token indicates its endpoint. The <code>&lt;(</code> is similar to other languages <a name="Documentable/integration-test/index-entry-regex_deprecated_\K-\K"><span class="index-entry">\K</span></a> to discard any matches found before the <code>\K</code>.</p>
<pre class="pod-block-code">say &#39;abc&#39; ~~ / a &lt;( b )&gt; c/;            # OUTPUT: «｢b｣␤»
say &#39;abc&#39; ~~ / &lt;(a &lt;( b )&gt; c)&gt;/;        # OUTPUT: «｢bc｣␤»</pre>
<p>As in the example above, you can see <code>&lt;(</code> sets the start point and <code>)&gt;</code> sets the endpoint; since they are actually independent of each other, the inner-most start point wins (the one attached to <code>b</code>) and the outer-most end wins (the one attached to <code>c</code>).</p>
<h1 id="Substitution"><a class="u" href="#___top" title="go to top of document">Substitution</a></h1>
<p>Regular expressions can also be used to substitute one piece of text for another. You can use this for anything, from correcting a spelling error (e.g., replacing &#39;Perl Jam&#39; with &#39;Pearl Jam&#39;), to reformatting an ISO8601 date from <code>yyyy-mm-ddThh:mm:ssZ</code> to <code>mm-dd-yy h:m {AM,PM}</code> and beyond.</p>
<p>Just like the search-and-replace editor&#39;s dialog box, the <code>s/ / /</code> operator has two sides, a left and right side. The left side is where your matching expression goes, and the right side is what you want to replace it with.</p>
<h2 id="Lexical_conventions"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-testindex-entry-quote_s/_/_/-Lexical_conventions"><span class="index-entry">Lexical conventions</span></a></a></h2>
<p>Substitutions are written similarly to matching, but the substitution operator has both an area for the regex to match, and the text to substitute:</p>
<pre class="pod-block-code">s/replace/with/;           # a substitution that is applied to $_
$str ~~ s/replace/with/;   # a substitution applied to a scalar
</pre>
<p>The substitution operator allows delimiters other than the slash:</p>
<pre class="pod-block-code">s|replace|with|;
s!replace!with!;
s,replace,with,;</pre>
<p>Note that neither the colon <code>:</code> nor balancing delimiters such as <code>{}</code> or <code>()</code> can be substitution delimiters. Colons clash with adverbs such as <code>s:i/Foo/bar/</code> and the other delimiters are used for other purposes.</p>
<p>If you use balancing curly braces, square brackets, or parentheses, the substitution works like this instead:</p>
<pre class="pod-block-code">s[replace] = &#39;with&#39;;</pre>
<p>The right-hand side is now a (not quoted) Raku expression, in which <code>$/</code> is available as the current match:</p>
<pre class="pod-block-code">$_ = &#39;some 11 words 21&#39;;
s:g[ \d+ ] =  2 * $/;
.say;                    # OUTPUT: «some 22 words 42␤»</pre>
<p>Like the <code>m//</code> operator, whitespace is ignored in the regex part of a substitution.</p>
<h2 id="Replacing_string_literals"><a class="u" href="#___top" title="go to top of document">Replacing string literals</a></h2>
<p>The simplest thing to replace is a string literal. The string you want to replace goes on the left-hand side of the substitution operator, and the string you want to replace it with goes on the right-hand side; for example:</p>
<pre class="pod-block-code">$_ = &#39;The Replacements&#39;;
s/Replace/Entrap/;
.say;                    # OUTPUT: «The Entrapments␤»</pre>
<p>Alphanumeric characters and the underscore are literal matches, just as in its cousin the <code>m//</code> operator. All other characters must be escaped with a backslash <code>\</code> or included in quotes:</p>
<pre class="pod-block-code">$_ = &#39;Space: 1999&#39;;
s/Space\:/Party like it&#39;s/;
.say                        # OUTPUT: «Party like it&#39;s 1999␤»</pre>
<p>Note that the matching restrictions generally only apply to the left-hand side of the substitution expression, but some special characters or combinations of them may need to be escaped in the right-hand side (RHS). For example</p>
<pre class="pod-block-code">$_ = &#39;foo&#39;;
s/foo/\%(/;
.say        # OUTPUT: «%(␤»</pre>
<p>or escape the &#39;(&#39; instead for the same result</p>
<pre class="pod-block-code">s/foo/%\(/;
.say        # OUTPUT: «%(␤»</pre>
<p>but using either character alone does not require escaping. Forward slashes will need to be escaped, but escaping alphanumeric characters will cause them to be ignored. (NOTE: This RHS limitation was only recently noticed and this is not yet an exhaustive list of all characters or character pairs that require escapes for the RHS.)</p>
<p>By default, substitutions are only done on the first match:</p>
<pre class="pod-block-code">$_ = &#39;There can be twly two&#39;;
s/tw/on/;                     # replace &#39;tw&#39; with &#39;on&#39; once
.say;                         # OUTPUT: «There can be only two␤»</pre>
<h2 id="Wildcards_and_character_classes"><a class="u" href="#___top" title="go to top of document">Wildcards and character classes</a></h2>
<p>Anything that can go into the <code>m//</code> operator can go into the left-hand side of the substitution operator, including wildcards and character classes. This is handy when the text you&#39;re matching isn&#39;t static, such as trying to match a number in the middle of a string:</p>
<pre class="pod-block-code">$_ = &quot;Blake&#39;s 9&quot;;
s/\d+/7/;         # replace any sequence of digits with &#39;7&#39;
.say;             # OUTPUT: «Blake&#39;s 7␤»</pre>
<p>Of course, you can use any of the <code>+</code>, <code>*</code> and <code>?</code> modifiers, and they&#39;ll behave just as they would in the <code>m//</code> operator&#39;s context.</p>
<h2 id="Capturing_groups"><a class="u" href="#___top" title="go to top of document">Capturing groups</a></h2>
<p>Just as in the match operator, capturing groups are allowed on the left-hand side, and the matched contents populate the <code>$0</code>..<code>$n</code> variables and the <code>$/</code> object:</p>
<pre class="pod-block-code">$_ = &#39;2016-01-23 18:09:00&#39;;
s/ (\d+)\-(\d+)\-(\d+) /today/;   # replace YYYY-MM-DD with &#39;today&#39;
.say;                             # OUTPUT: «today 18:09:00␤»
&quot;$1-$2-$0&quot;.say;                   # OUTPUT: «01-23-2016␤»
&quot;$/[1]-$/[2]-$/[0]&quot;.say;          # OUTPUT: «01-23-2016␤»</pre>
<p>Any of these variables <code>$0</code>, <code>$1</code>, <code>$/</code> can be used on the right-hand side of the operator as well, so you can manipulate what you&#39;ve just matched. This way you can separate out the <code>YYYY</code>, <code>MM</code> and <code>DD</code> parts of a date and reformat them into <code>MM-DD-YYYY</code> order:</p>
<pre class="pod-block-code">$_ = &#39;2016-01-23 18:09:00&#39;;
s/ (\d+)\-(\d+)\-(\d+) /$1-$2-$0/;    # transform YYYY-MM-DD to MM-DD-YYYY
.say;                                 # OUTPUT: «01-23-2016 18:09:00␤»</pre>
<p>Named capture can be used too:</p>
<pre class="pod-block-code">$_ = &#39;2016-01-23 18:09:00&#39;;
s/ $&lt;y&gt;=(\d+)\-$&lt;m&gt;=(\d+)\-$&lt;d&gt;=(\d+) /$&lt;m&gt;-$&lt;d&gt;-$&lt;y&gt;/;
.say;                                 # OUTPUT: «01-23-2016 18:09:00␤»</pre>
<p>Since the right-hand side is effectively a regular Raku interpolated string, you can reformat the time from <code>HH:MM</code> to <code>h:MM {AM,PM}</code> like so:</p>
<pre class="pod-block-code">$_ = &#39;18:38&#39;;
s/(\d+)\:(\d+)/{$0 % 12}\:$1 {$0 &lt; 12 ?? &#39;AM&#39; !! &#39;PM&#39;}/;
.say;                                 # OUTPUT: «6:38 PM␤»</pre>
<p>Using the modulo <code>%</code> operator above keeps the sample code under 80 characters, but is otherwise the same as <code>$0 &lt; 12 ?? $0 !! $0 - 12 </code>. When combined with the power of the Parser Expression Grammars that <strong>really</strong> underlies what you&#39;re seeing here, you can use &quot;regular expressions&quot; to parse pretty much any text out there.</p>
<h2 id="Common_adverbs"><a class="u" href="#___top" title="go to top of document">Common adverbs</a></h2>
<p>The full list of adverbs that you can apply to regular expressions can be found elsewhere in this document (<a href="#Adverbs">section Adverbs</a>), but the most common are probably <code>:g</code> and <code>:i</code>.</p>
<ul><li><p>Global adverb <code>:g</code></p>
</li>
</ul>
<p>Ordinarily, matches are only made once in a given string, but adding the <code>:g</code> modifier overrides that behavior, so that substitutions are made everywhere possible. Substitutions are non-recursive; for example:</p>
<pre class="pod-block-code">$_ = q{I can say &quot;banana&quot; but I don&#39;t know when to stop};
s:g/na/nana,/;    # substitute &#39;nana,&#39; for &#39;na&#39;
.say;             # OUTPUT: «I can say &quot;banana,nana,&quot; but I don&#39;t ...␤»</pre>
<p>Here, <code>na</code> was found twice in the original string and each time there was a substitution. The substitution only applied to the original string, though. The resulting string was not impacted.</p>
<ul><li><p>Insensitive adverb <code>:i</code></p>
</li>
</ul>
<p>Ordinarily, matches are case-sensitive. <code>s/foo/bar/</code> will only match <code>&#39;foo&#39;</code> and not <code>&#39;Foo&#39;</code>. If the adverb <code>:i</code> is used, though, matches become case-insensitive.</p>
<pre class="pod-block-code">$_ = &#39;Fruit&#39;;
s/fruit/vegetable/;
.say;                          # OUTPUT: «Fruit␤»

s:i/fruit/vegetable/;
.say;                          # OUTPUT: «vegetable␤»</pre>
<p>For more information on what these adverbs are actually doing, refer to the <a href="#Adverbs">section Adverbs</a> section of this document.</p>
<p>These are just a few of the transformations you can apply with the substitution operator. Some of the simpler uses in the real world include removing personal data from log files, editing MySQL timestamps into PostgreSQL format, changing copyright information in HTML files and sanitizing form fields in a web application.</p>
<p>As an aside, novices to regular expressions often get overwhelmed and think that their regular expression needs to match every piece of data in the line, including what they want to match. Write just enough to match the data you&#39;re looking for, no more, no less.</p>
<h2 id="S///_non-destructive_substitution"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-testindex-entry-S///_non-destructive_substitution"><span class="index-entry"><code>S///</code> non-destructive substitution</span></a></a></h2>
<pre class="pod-block-code">say S/o .+ d/new/ with &#39;old string&#39;;      # OUTPUT: «new string»
S:g/« (.)/$0.uc()/.say for &lt;foo bar ber&gt;; # OUTPUT: «Foo␤Bar␤Ber»</pre>
<p><code>S///</code> uses the same semantics as the <code>s///</code> operator, except it leaves the original string intact and <em>returns the resultant string</em> instead of <code>$/</code> (<code>$/</code> still being set to the same values as with <code>s///</code>).</p>
<p><strong>Note:</strong> since the result is obtained as a return value, using this operator with the <code>~~</code> smartmatch operator is a mistake and will issue a warning. To execute the substitution on a variable that isn&#39;t the <code>$_</code> this operator uses, alias it to <code>$_</code> with <code>given</code>, <code>with</code>, or any other way. Alternatively, use the <a href="/Documentable/integration-test/routine/subst"><code>.subst</code> method</a>.</p>
<h1 id="Tilde_for_nesting_structures"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex__tilde-_regex__~-Tilde_for_nesting_structures"><span class="index-entry">Tilde for nesting structures</span></a></a></h1>
<p>The <code>~</code> operator is a helper for matching nested subrules with a specific terminator as the goal. It is designed to be placed between an opening and closing delimiter pair, like so:</p>
<pre class="pod-block-code">/ &#39;(&#39; ~ &#39;)&#39; &lt;expression&gt; /</pre>
<p>However, it mostly ignores the left argument, and operates on the next two atoms (which may be quantified). Its operation on those next two atoms is to &quot;twiddle&quot; them so that they are actually matched in reverse order. Hence the expression above, at first blush, is merely shorthand for:</p>
<pre class="pod-block-code">/ &#39;(&#39; &lt;expression&gt; &#39;)&#39; /</pre>
<p>But beyond that, when it rewrites the atoms it also inserts the apparatus that will set up the inner expression to recognize the terminator, and to produce an appropriate error message if the inner expression does not terminate on the required closing atom. So it really does pay attention to the left delimiter as well, and it actually rewrites our example to something more like:</p>
<p><a name="Documentable/integration-test/index-entry-SETGOAL"></a></p>
<pre class="pod-block-code">$&lt;OPEN&gt; = &#39;(&#39; &lt;SETGOAL: &#39;)&#39;&gt; &lt;expression&gt; [ $GOAL || &lt;FAILGOAL&gt; ]
</pre>
<p><a name="Documentable/integration-test/index-entry-FAILGOAL"><span class="index-entry">FAILGOAL</span></a> is a special method that can be defined by the user and it will be called on parse failure:</p>
<pre class="pod-block-code">grammar A { token TOP { &#39;[&#39; ~ &#39;]&#39; \w+  };
            method FAILGOAL($goal) {
                die &quot;Cannot find $goal near position {self.pos}&quot;
            }
}

say A.parse: &#39;[good]&#39;;  # OUTPUT: «｢[good]｣␤»
A.parse: &#39;[bad&#39;;        # will throw FAILGOAL exception
CATCH { default { put .^name, &#39;: &#39;, .Str } };
# OUTPUT: «X::AdHoc: Cannot find &#39;]&#39;  near position 4␤»</pre>
<p>Note that you can use this construct to set up expectations for a closing construct even when there&#39;s no opening delimiter:</p>
<pre class="pod-block-code">&quot;3)&quot;  ~~ / &lt;?&gt; ~ &#39;)&#39; \d+ /;  # OUTPUT: «｢3)｣»
&quot;(3)&quot; ~~ / &lt;?&gt; ~ &#39;)&#39; \d+ /;  # OUTPUT: «｢3)｣»</pre>
<p>Here <code>&lt;?&gt;</code> successfully matches the null string.</p>
<p>The order of the regex capture is original:</p>
<pre class="pod-block-code">&quot;abc&quot; ~~ /a ~ (c) (b)/;
say $0; # OUTPUT: «｢c｣␤»
say $1; # OUTPUT: «｢b｣␤»</pre>
<h1 id="Subrules"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-declarator_regex-Subrules"><span class="index-entry">Subrules</span></a></a></h1>
<p>Just like you can put pieces of code into subroutines, you can also put pieces of regex into named rules.</p>
<pre class="pod-block-code">my regex line { \N*\n }
if &quot;abc\ndef&quot; ~~ /&lt;line&gt; def/ {
    say &quot;First line: &quot;, $&lt;line&gt;.chomp;      # OUTPUT: «First line: abc␤»
}</pre>
<p>A named regex can be declared with <code>my regex named-regex { body here }</code>, and called with <code>&lt;named-regex&gt;</code>. At the same time, calling a named regex installs a named capture with the same name.</p>
<p>To give the capture a different name from the regex, use the syntax <code>&lt;capture-name=named-regex&gt;</code>. If no capture is desired, a leading dot or ampersand will suppress it: <code>&lt;.named-regex&gt;</code> if it is a method declared in the same class or grammar, <code>&lt;&amp;named-regex&gt;</code> for a regex declared in the same lexical context.</p>
<p>Here&#39;s more complete code for parsing <code>ini</code> files:</p>
<pre class="pod-block-code">my regex header { \s* &#39;[&#39; (\w+) &#39;]&#39; \h* \n+ }
my regex identifier  { \w+ }
my regex kvpair { \s* &lt;key=identifier&gt; &#39;=&#39; &lt;value=identifier&gt; \n+ }
my regex section {
    &lt;header&gt;
    &lt;kvpair&gt;*
}

my $contents = q:to/EOI/;
    [passwords]
        jack=password1
        joy=muchmoresecure123
    [quotas]
        jack=123
        joy=42
EOI

my %config;
if $contents ~~ /&lt;section&gt;*/ {
    for $&lt;section&gt;.list -&gt; $section {
        my %section;
        for $section&lt;kvpair&gt;.list -&gt; $p {
            %section{ $p&lt;key&gt; } = ~$p&lt;value&gt;;
        }
        %config{ $section&lt;header&gt;[0] } = %section;
    }
}
say %config.raku;

# OUTPUT: «{:passwords(${:jack(&quot;password1&quot;), :joy(&quot;muchmoresecure123&quot;)}),
#           :quotas(${:jack(&quot;123&quot;), :joy(&quot;42&quot;)})}»</pre>
<p>Named regexes can and should be grouped in <a href="/Documentable/integration-test/language/grammars">grammars</a>. A list of predefined subrules is listed in <a href="https://design.raku.org/S05.html#Predefined_Subrules">S05-regex</a> of design documents.</p>
<h1 id="Regex_interpolation"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex__Regex_Interpolation-Regex_interpolation"><span class="index-entry">Regex interpolation</span></a></a></h1>
<p>Instead of using a literal pattern for a regex match, you can use a variable that holds that pattern. This variable can then be &#39;interpolated&#39; into a regex, such that its appearance in the regex is replaced with the pattern that it holds. The advantage of using interpolation this way, is that the pattern need not be hardcoded in the source of your Raku program, but may instead be variable and generated at runtime.</p>
<p>There are four different ways of interpolating a variable into a regex as a pattern, which may be summarized as follows:</p>
<table class="pod-table">
<thead><tr>
<th>Syntax</th> <th>Description</th>
</tr></thead>
<tbody>
<tr> <td>$variable</td> <td>Interpolates stringified contents of variable literally.</td> </tr> <tr> <td>$(code)</td> <td>Runs Raku code inside the regex, and interpolates the stringified return value literally.</td> </tr> <tr> <td>&lt;$variable&gt;</td> <td>Interpolates stringified contents of variable as a regex.</td> </tr> <tr> <td>&lt;{code}&gt;</td> <td>Runs Raku code inside the regex, and interpolates the stringified return value as a regex.</td> </tr>
</tbody>
</table><p>Instead of the <code>$</code> sigil, you may use the <code>@</code> sigil for array interpolation. See below for how this works.</p>
<p><a name="Documentable/integration-test/index-entry-regex__$variable"></a><a name="Documentable/integration-test/index-entry-regex__$(code)"></a> Let&#39;s start with the first two syntactical forms: <code>$variable</code> and <code>$(code)</code>. These forms will interpolate the stringified value of the variable or the stringified return value of the code literally, provided that the respective value isn&#39;t a <a href="/Documentable/integration-test/type/Regex"><code>Regex</code></a> object. If the value is a <code>Regex</code>, it will not be stringified, but instead be interpolated as such. &#39;Literally&#39; means <em>strictly literally</em>, that is: as if the respective stringified value is quoted with a basic <code>Q</code> string <a href="/Documentable/integration-test/language/quoting#Literal_strings:_Q"><code>Q[...]</code></a>. Consequently, the stringified value will not itself undergo any further interpolation.</p>
<p>For <code>$variable</code> this means the following:</p>
<pre class="pod-block-code">my $string   = &#39;Is this a regex or a string: 123\w+False$pattern1 ?&#39;;
my $pattern1 = &#39;string&#39;;
my $pattern2 = &#39;\w+&#39;;
my $number   = 123;
my $regex    = /\w+/;

say $string.match: / &#39;string&#39; /;                      #  [1] OUTPUT: «｢string｣␤»
say $string.match: / $pattern1 /;                     #  [2] OUTPUT: «｢string｣␤»
say $string.match: / $pattern2 /;                     #  [3] OUTPUT: «｢\w+｣␤»
say $string.match: / $regex /;                        #  [4] OUTPUT: «｢Is｣␤»
say $string.match: / $number /;                       #  [5] OUTPUT: «｢123｣␤»</pre>
<p>In this example, the statements <code>[1]</code> and <code>[2]</code> are equivalent and meant to illustrate a plain case of regex interpolation. Since unescaped/unquoted alphabetic characters in a regex match literally, the single quotes in the regex of statement <code>[1]</code> are functionally redundant; they have merely been included to emphasize the correspondence between the first two statements. Statement <code>[3]</code> unambiguously shows that the string pattern held by <code>$pattern2</code> is interpreted literally, and not as a regex. In case it would have been interpreted as a regex, it would have matched the first word of <code>$string</code>, i.e. <code>｢Is｣</code>, as can be seen in statement <code>[4]</code>. Statement <code>[5]</code> shows how the stringified number is used as a match pattern.</p>
<p>This code exemplifies the use of the <code>$(code)</code> syntax:</p>
<pre class="pod-block-code">my $string   = &#39;Is this a regex or a string: 123\w+False$pattern1 ?&#39;;
my $pattern1 = &#39;string&#39;;
my $pattern3 = &#39;gnirts&#39;;
my $pattern4 = &#39;$pattern1&#39;;
my $bool     = True;
my sub f1    { return Q[$pattern1] };

say $string.match: / $pattern3.flip /;                #  [6] OUTPUT: «Nil␤»
say $string.match: / &quot;$pattern3.flip()&quot; /;            #  [7] OUTPUT: «｢string｣␤»
say $string.match: / $($pattern3.flip) /;             #  [8] OUTPUT: «｢string｣␤»
say $string.match: / $([~] $pattern3.comb.reverse) /; #  [9] OUTPUT: «｢string｣␤»
say $string.match: / $(!$bool) /;                     # [10] OUTPUT: «｢False｣␤»

say $string.match: / $pattern4 /;                     # [11] OUTPUT: «｢$pattern1｣␤»
say $string.match: / $(f1) /;                         # [12] OUTPUT: «｢$pattern1｣␤»</pre>
<p>Statement <code>[6]</code> does not work as probably intended. To the human reader, the dot <code>.</code> may seem to represent the <a href="/Documentable/integration-test/language/operators#methodop_..html">method call operator</a>, but since a dot is not a valid character for an <a href="/Documentable/integration-test/language/syntax#Ordinary_identifiers">ordinary identifier</a>, and given the regex context, the compiler will parse it as the regex wildcard <a href="/Documentable/integration-test/language/regexes#Wildcards">.</a> that matches any character. The apparent ambiguity may be resolved in various ways, for instance through the use of straightforward <a href="/Documentable/integration-test/language/quoting#Interpolation:_qq">string interpolation</a> from the regex as in statement <code>[7]</code> (note that the inclusion of the call operator <code>()</code> is key here), or by using the second syntax form from the above table as in statement <code>[8]</code>, in which case the match pattern <code>string</code> first emerges as the return value of the <code>flip</code> method call. Since general Raku code may be run from within the parentheses of <code>$( )</code>, the same effect can also be achieved with a bit more effort, like in statement <code>[9]</code>. Statement <code>[10]</code> illustrates how the stringified version of the code&#39;s return value (the boolean value <code>False</code>) is matched literally.</p>
<p>Finally, statements <code>[11]</code> and <code>[12]</code> show how the value of <code>$pattern4</code> and the return value of <code>f1</code> are <em>not</em> subject to a further round of interpolation. Hence, in general, after possible stringification, <code>$variable</code> and <code>$(code)</code> provide for a strictly literal match of the variable or return value.</p>
<p><a name="Documentable/integration-test/index-entry-regex__<$variable>"></a><a name="Documentable/integration-test/index-entry-regex__<{code}>"></a> Now consider the second two syntactical forms from the table above: <code>&lt;$variable&gt;</code> and <code>&lt;{code}&gt;</code>. These forms will stringify the value of the variable or the return value of the code and interpolate it as a regex. If the respective value is a <code>Regex</code>, it is interpolated as such:</p>
<pre class="pod-block-code">my $string         = &#39;Is this a regex or a string: 123\w+$x ?&#39;;
my $pattern1       = &#39;\w+&#39;;
my $number         = 123;
my sub f1          { return /s\w+/ };

say $string.match: / &lt;$pattern1&gt;  /;                  # OUTPUT: «｢Is｣␤»
say $string.match: / &lt;$number&gt;    /;                  # OUTPUT: «｢123｣␤»
say $string.match: / &lt;{ f1 }&gt;     /;                  # OUTPUT: «｢string｣␤»</pre>
<p>Importantly, &#39;to interpolate as a regex&#39; means to interpolate/insert into the target regex without protective quoting. Consequently, if the value of the variable <code>$variable1</code> is itself of the form <code>$variable2</code>, evaluation of <code>&lt;$variable1&gt;</code> or <code>&lt;{ $variable1 }&gt;</code> inside a target regex <code>/.../</code> will cause the target regex to assume the form <code>/$variable2/</code>. As described above, the evaluation of this regex will then trigger further interpolation of <code>$variable2</code>:</p>
<pre class="pod-block-code">my $string    = Q[Mindless \w+ $variable1 $variable2];
my $variable1 = Q[\w+];
my $variable2 = Q[$variable1];
my sub f1     { return Q[$variable2] };

# /&lt;{ f1 }&gt;/ ==&gt; /$variable2/ ==&gt; / &#39;$variable1&#39; /
say $string.match: / &lt;{ f1 }&gt;     /; # OUTPUT: «｢$variable1｣␤»

# /&lt;$variable2&gt;/ ==&gt; /$variable1/ ==&gt; / &#39;\w+&#39; /
say $string.match: /&lt;$variable2&gt;/;   # OUTPUT: «｢\w+｣␤»

# /&lt;$variable1&gt;/ ==&gt; /\w+/
say $string.match: /&lt;$variable1&gt;/;   # OUTPUT: «｢Mindless｣␤»</pre>
<p>When an array variable is interpolated into a regex, the regex engine handles it like a <code>|</code> alternative of the regex elements (see the documentation on <a href="/Documentable/integration-test/language/regexes#Quoted_lists_are_LTM_matches">embedded lists</a>, above). The interpolation rules for individual elements are the same as for scalars, so strings and numbers match literally, and <a href="/Documentable/integration-test/type/Regex"><code>Regex</code></a> objects match as regexes. Just as with ordinary <code>|</code> interpolation, the longest match succeeds:</p>
<pre class="pod-block-code">my @a = &#39;2&#39;, 23, rx/a.+/;
say (&#39;b235&#39; ~~ /  b @a /).Str;      # OUTPUT: «b23»</pre>
<p>If you have an expression that evaluates to a list, but you do not want to assign it to an @-sigiled variable first, you can interpolate it with <code>@(code)</code>. In this example, both regexes are equivalent:</p>
<pre class="pod-block-code">my %h = a =&gt; 1, b =&gt; 2;
my @a = %h.keys;
say S:g/@(%h.keys)/%h{$/}/ given &#39;abc&#39;;    # OUTPUT: «12c&gt;
say S:g/@a/%h{$/}/ given &#39;abc&#39;;            # OUTPUT: «12c&gt;</pre>
<p>The use of hashes in regexes is reserved.</p>
<h2 id="Regex_boolean_condition_check"><a class="u" href="#___top" title="go to top of document">Regex boolean condition check</a></h2>
<p><a name="Documentable/integration-test/index-entry-regex__<?{}>-regex__<!{}>"></a> The special operator <code>&lt;?{}&gt;</code> allows the evaluation of a boolean expression that can perform a semantic evaluation of the match before the regular expression continues. In other words, it is possible to check in a boolean context a part of a regular expression and therefore invalidate the whole match (or allow it to continue) even if the match succeeds from a syntactic point of view.</p>
<p>In particular the <code>&lt;?{}&gt;</code> operator requires a <code>True</code> value in order to allow the regular expression to match, while its negated form <code>&lt;!{}&gt;</code> requires a <code>False</code> value.</p>
<p>In order to demonstrate the above operator, please consider the following example that involves a simple IPv4 address matching:</p>
<pre class="pod-block-code">my $localhost = &#39;127.0.0.1&#39;;
my regex ipv4-octet { \d ** 1..3 &lt;?{ True }&gt; }
$localhost ~~ / ^ &lt;ipv4-octet&gt; ** 4 % &quot;.&quot; $ /;
say $/&lt;ipv4-octet&gt;;   # OUTPUT: «[｢127｣ ｢0｣ ｢0｣ ｢1｣]␤»
</pre>
<p>The <code>octet</code> regular expression matches against a number made by one up to three digits. Each match is driven by the result of the <code>&lt;?{}&gt;</code>, that being the fixed value of <code>True</code> means that the regular expression match has to be always considered as good. As a counter-example, using the special constant value <code>False</code> will invalidate the match even if the regular expression matches from a syntactic point of view:</p>
<pre class="pod-block-code">my $localhost = &#39;127.0.0.1&#39;;
my regex ipv4-octet { \d ** 1..3 &lt;?{ False }&gt; }
$localhost ~~ / ^ &lt;ipv4-octet&gt; ** 4 % &quot;.&quot; $ /;
say $/&lt;ipv4-octet&gt;;   # OUTPUT: «Nil␤»
</pre>
<p>From the above examples, it should be clear that it is possible to improve the semantic check, for instance ensuring that each <em>octet</em> is really a valid IPv4 octet:</p>
<pre class="pod-block-code">my $localhost = &#39;127.0.0.1&#39;;
my regex ipv4-octet { \d ** 1..3 &lt;?{ $/.Int &lt;= 255 &amp;&amp; $/.Int &gt;= 0 }&gt; }
$localhost ~~ / ^ &lt;ipv4-octet&gt; ** 4 % &quot;.&quot; $ /;
say $/&lt;ipv4-octet&gt;;   # OUTPUT: «[｢127｣ ｢0｣ ｢0｣ ｢1｣]␤»
</pre>
<p>Please note that it is not required to evaluate the regular expression in-line, but also a regular method can be called to get the boolean value:</p>
<pre class="pod-block-code">my $localhost = &#39;127.0.0.1&#39;;
sub check-octet ( Int $o ){ $o &lt;= 255 &amp;&amp; $o &gt;= 0 }
my regex ipv4-octet { \d ** 1..3 &lt;?{ &amp;check-octet( $/.Int ) }&gt; }
$localhost ~~ / ^ &lt;ipv4-octet&gt; ** 4 % &quot;.&quot; $ /;
say $/&lt;ipv4-octet&gt;;   # OUTPUT: «[｢127｣ ｢0｣ ｢0｣ ｢1｣]␤»
</pre>
<p>Of course, being <code>&lt;!{}&gt;</code> the negation form of <code>&lt;?{}&gt;</code> the same boolean evaluation can be rewritten in a negated form:</p>
<pre class="pod-block-code">my $localhost = &#39;127.0.0.1&#39;;
sub invalid-octet( Int $o ){ $o &lt; 0 || $o &gt; 255 }
my regex ipv4-octet { \d ** 1..3 &lt;!{ &amp;invalid-octet( $/.Int ) }&gt; }
$localhost ~~ / ^ &lt;ipv4-octet&gt; ** 4 % &quot;.&quot; $ /;
say $/&lt;ipv4-octet&gt;;   # OUTPUT: «[｢127｣ ｢0｣ ｢0｣ ｢1｣]␤»
</pre>
<h1 id="Adverbs"><a class="u" href="#___top" title="go to top of document">Adverbs</a></h1>
<p>Adverbs, which modify how regexes work and provide convenient shortcuts for certain kinds of recurring tasks, are combinations of one or more letters preceded by a colon <code>:</code>.</p>
<p>The so-called <em>regex</em> adverbs apply at the point where a regex is defined; additionally, <em>matching</em> adverbs apply at the point that a regex matches against a string and <em>substitution</em> adverbs are applied exclusively in substitutions.</p>
<p>This distinction often blurs, because matching and declaration are often textually close but using the method form of matching, that is, <code>.match</code>, makes the distinction clear.</p>
<pre class="pod-block-code">say &quot;Abra abra CADABRA&quot; ~~ m:exhaustive/:i a \w+ a/;
# OUTPUT: «(｢Abra｣ ｢abra｣ ｢ADABRA｣ ｢ADA｣ ｢ABRA｣)␤»
my $regex = /:i a \w+ a /;
say &quot;Abra abra CADABRA&quot;.match($regex,:ex);
# OUTPUT: «(｢Abra｣ ｢abra｣ ｢ADABRA｣ ｢ADA｣ ｢ABRA｣)␤»</pre>
<p>In the first example, the matching adverb (<code>:exhaustive</code>) is contiguous to the regex adverb (<code>:i</code>), and as a matter of fact, the &quot;definition&quot; and the &quot;matching&quot; go together; however, by using <code>match</code> it becomes clear that <code>:i</code> is only used when defining the <code>$regex</code> variable, and <code>:ex</code> (short for <code>:exhaustive</code>) as an argument when matching. As a matter of fact, matching adverbs cannot even be used in the definition of a regex:</p>
<pre class="pod-block-code">my $regex = rx:ex/:i a \w+ a /;
# ===SORRY!=== Error while compiling (...)␤Adverb ex not allowed on rx
</pre>
<p>Regex adverbs like <code>:i</code> go into the definition line and matching adverbs like <code>:overlap</code> (which can be abbreviated to <code>:ov</code>) are appended to the match call:</p>
<pre class="pod-block-code">my $regex = /:i . a/;
for &#39;baA&#39;.match($regex, :overlap) -&gt; $m {
    say ~$m;
}
# OUTPUT: «ba␤aA␤»</pre>
<h2 id="Regex_adverbs"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex__Regex_adverbs-Regex_adverbs"><span class="index-entry">Regex adverbs</span></a></a></h2>
<p>The adverbs that appear at the time of a regex declaration are part of the actual regex and influence how the Raku compiler translates the regex into binary code.</p>
<p>For example, the <code>:ignorecase</code> (<code>:i</code>) adverb tells the compiler to ignore the distinction between upper case, lower case and title case letters.</p>
<p>So <code>&#39;a&#39; ~~ /A/</code> is false, but <code>&#39;a&#39; ~~ /:i A/</code> is a successful match.</p>
<p>Regex adverbs can come before or inside a regex declaration and only affect the part of the regex that comes afterwards, lexically. Note that regex adverbs appearing before the regex must appear after something that introduces the regex to the parser, like &#39;rx&#39; or &#39;m&#39; or a bare &#39;/&#39;. This is NOT valid:</p>
<pre class="pod-block-code">my $rx1 = :i/a/;      # adverb is before the regex is recognized =&gt; exception
</pre>
<p>but these are valid:</p>
<pre class="pod-block-code">my $rx1 = rx:i/a/;     # before
my $rx2 = m:i/a/;      # before
my $rx3 = /:i a/;      # inside</pre>
<p>These two regexes are equivalent:</p>
<pre class="pod-block-code">my $rx1 = rx:i/a/;      # before
my $rx2 = rx/:i a/;     # inside</pre>
<p>Whereas these two are not:</p>
<pre class="pod-block-code">my $rx3 = rx/a :i b/;   # matches only the b case insensitively
my $rx4 = rx/:i a b/;   # matches completely case insensitively</pre>
<p>Square brackets and parentheses limit the scope of an adverb:</p>
<pre class="pod-block-code">/ (:i a b) c /;         # matches &#39;ABc&#39; but not &#39;ABC&#39;
/ [:i a b] c /;         # matches &#39;ABc&#39; but not &#39;ABC&#39;</pre>
<p>When two adverbs are used together, they keep their colon at the front</p>
<pre class="pod-block-code">&quot;þor is Þor&quot; ~~ m:g:i/þ/;  # OUTPUT: «(｢þ｣ ｢Þ｣)␤»</pre>
<p>That implies that when there are two vowels together after a <code>:</code>, they correspond to the same adverb, as in <code>:ov</code> or <code>:P5</code>.</p>
<h3 id="Ignorecase"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_adverb_:ignorecase-regex_adverb_:i-Ignorecase"><span class="index-entry">Ignorecase</span></a></a></h3>
<p>The <code>:ignorecase</code> or <code>:i</code> adverb instructs the regex engine to ignore the distinction between upper case, lower case and title case letters.</p>
<p>See the <a href="/Documentable/integration-test/language/regexes#Regex_adverbs">section Regex adverbs</a> for examples.</p>
<h3 id="Ignoremark"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_adverb_:ignoremark-regex_adverb_:m-Ignoremark"><span class="index-entry">Ignoremark</span></a></a></h3>
<p>The <code>:ignoremark</code> or <code>:m</code> adverb instructs the regex engine to only compare base characters, and ignore additional marks such as combining accents:</p>
<pre class="pod-block-code">say so &#39;a&#39; ~~ rx/ä/;                # OUTPUT: «False»
say so &#39;a&#39; ~~ rx:ignoremark /ä/;    # OUTPUT: «True»
say so &#39;ỡ&#39; ~~ rx:ignoremark /o/;    # OUTPUT: «True&gt;
</pre>
<h3 id="Ratchet"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_adverb_:ratchet-regex_adverb_:r-Ratchet"><span class="index-entry">Ratchet</span></a></a></h3>
<p>The <code>:ratchet</code> or <code>:r</code> adverb causes the regex engine to not backtrack (see <a href="/Documentable/integration-test/language/regexes#Backtracking">backtracking</a>). Mnemonic: a <a href="https://en.wikipedia.org/wiki/Ratchet_%28device%29">ratchet</a> only moves in one direction and can&#39;t backtrack.</p>
<p>Without this adverb, parts of a regex will try different ways to match a string in order to make it possible for other parts of the regex to match. For example, in <code>&#39;abc&#39; ~~ /\w+ ./</code>, the <code>\w+</code> first eats up the whole string, <code>abc</code> but then the <code>.</code> fails. Thus <code>\w+</code> gives up a character, matching only <code>ab</code>, and the <code>.</code> can successfully match the string <code>c</code>. This process of giving up characters (or in the case of alternations, trying a different branch) is known as backtracking.</p>
<pre class="pod-block-code">say so &#39;abc&#39; ~~ / \w+ . /;        # OUTPUT: «True␤»
say so &#39;abc&#39; ~~ / :r \w+ . /;     # OUTPUT: «False␤»</pre>
<p>Ratcheting can be an optimization, because backtracking is costly. But more importantly, it closely corresponds to how humans parse a text. If you have a regex <code>my regex identifier { \w+ }</code> and <code>my regex keyword { if | else | endif }</code>, you intuitively expect the <code>identifier</code> to gobble up a whole word and not have it give up its end to the next rule, if the next rule otherwise fails.</p>
<p>For example, you don&#39;t expect the word <code>motif</code> to be parsed as the identifier <code>mot</code> followed by the keyword <code>if</code>. Instead, you expect <code>motif</code> to be parsed as one identifier; and if the parser expects an <code>if</code> afterwards, best that it should fail than have it parse the input in a way you don&#39;t expect.</p>
<p>Since ratcheting behavior is often desirable in parsers, there&#39;s a shortcut to declaring a ratcheting regex:</p>
<pre class="pod-block-code">my token thing { ... };
# short for
my regex thing { :r ... };
</pre>
<h3 id="Sigspace"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-regex_adverb_:sigspace-regex_adverb_:s-Sigspace"><span class="index-entry">Sigspace</span></a></a></h3>
<p>The <strong><code>:sigspace</code></strong> or <strong><code>:s</code></strong> adverb makes whitespace significant in a regex.</p>
<pre class="pod-block-code">say so &quot;I used Photoshop®&quot;   ~~ m:i/   photo shop /;      # OUTPUT: «True␤»
say so &quot;I used a photo shop&quot; ~~ m:i<strong>:s</strong>/ photo shop /;   # OUTPUT: «True␤»
say so &quot;I used Photoshop®&quot;   ~~ m:i<strong>:s</strong>/ photo shop /;   # OUTPUT: «False␤»
</pre>
<p><code>m:s/ photo shop /</code> acts the same as <code>m/ photo &lt;.ws&gt; shop &lt;.ws&gt; /</code>. By default, <code>&lt;.ws&gt; </code> makes sure that words are separated, so <code>a b</code> and <code>^&amp;</code> will match <code>&lt;.ws&gt; </code> in the middle, but <code>ab</code> won&#39;t:</p>
<pre class="pod-block-code">say so &quot;ab&quot; ~~ m:s/a &lt;.ws&gt; b/;     # OUTPUT: «False␤»
say so &quot;a b&quot; ~~ m:s/a &lt;.ws&gt; b/;    # OUTPUT: «True␤»
say so &quot;^&amp;&quot; ~~ m:s/&#39;^&#39; &lt;.ws&gt; &#39;&amp;&#39;/; # OUTPUT: «True␤»
</pre>
<p>The third line is matched, because <code>^&amp;</code> is not a word. For more clarification on how &lt;.ws&gt; rule works, refer to <a href="/Documentable/integration-test/language/grammars#ws">WS rule description</a>.</p>
<p>Where whitespace in a regex turns into <code>&lt;.ws&gt;</code> depends on what comes before the whitespace. In the above example, whitespace in the beginning of a regex doesn&#39;t turn into <code>&lt;.ws&gt;</code>, but whitespace after characters does. In general, the rule is that if a term might match something, whitespace after it will turn into <code>&lt;.ws&gt;</code>.</p>
<p>In addition, if whitespace comes after a term but <em>before</em> a quantifier (<code>+</code>, <code>*</code>, or <code>?</code>), <code>&lt;.ws&gt;</code> will be matched after every match of the term. So, <code>foo +</code> becomes <code>[ foo &lt;.ws&gt; ]+</code>. On the other hand, whitespace <em>after</em> a quantifier acts as normal significant whitespace; e.g., &quot;<code>foo+ </code>&quot; becomes <code>foo+ &lt;.ws&gt;</code>.</p>
<p>In all, this code:</p>
<pre class="pod-block-code">rx :s {
    ^^
    {
        say &quot;No sigspace after this&quot;;
    }
    &lt;.assertion_and_then_ws&gt;
    characters_with_ws_after+
    ws_separated_characters *
    [
    | some &quot;stuff&quot; .. .
    | $$
    ]
    :my $foo = &quot;no ws after this&quot;;
    $foo
}
</pre>
<p>Becomes:</p>
<pre class="pod-block-code">rx {
    ^^ <strong>&lt;.ws&gt;</strong>
    {
        say &quot;No space after this&quot;;
    }
    &lt;.assertion_and_then_ws&gt; <strong>&lt;.ws&gt;</strong>
    characters_with_ws_after+ <strong>&lt;.ws&gt;</strong>
    [ws_separated_characters <strong>&lt;.ws&gt;</strong>]* <strong>&lt;.ws&gt;</strong>
    [
    | some <strong>&lt;.ws&gt;</strong> &quot;stuff&quot; <strong>&lt;.ws&gt;</strong> .. <strong>&lt;.ws&gt;</strong> . <strong>&lt;.ws&gt;</strong>
    | $$ <strong>&lt;.ws&gt;</strong>
    ] <strong>&lt;.ws&gt;</strong>
    :my $foo = &quot;no ws after this&quot;;
    $foo <strong>&lt;.ws&gt;</strong>
}
</pre>
<p>If a regex is declared with the <code>rule</code> keyword, both the <code>:sigspace</code> and <code>:ratchet</code> adverbs are implied.</p>
<p>Grammars provide an easy way to override what <code>&lt;.ws&gt;</code> matches:</p>
<pre class="pod-block-code">grammar Demo {
    token ws {
        &lt;!ww&gt;       # only match when not within a word
        \h*         # only match horizontal whitespace
    }
    rule TOP {      # called by Demo.parse;
        a b &#39;.&#39;
    }
}

# doesn&#39;t parse, whitespace required between a and b
say so Demo.parse(&quot;ab.&quot;);                 # OUTPUT: «False␤»
say so Demo.parse(&quot;a b.&quot;);                # OUTPUT: «True␤»
say so Demo.parse(&quot;a\tb .&quot;);              # OUTPUT: «True␤»

# \n is vertical whitespace, so no match
say so Demo.parse(&quot;a\tb\n.&quot;);             # OUTPUT: «False␤»</pre>
<p>When parsing file formats where some whitespace (for example, vertical whitespace) is significant, it&#39;s advisable to override <code>ws</code>.</p>
<h3 id="Perl_compatibility_adverb"><a class="u" href="#___top" title="go to top of document">Perl compatibility adverb</a></h3>
<p>The <strong><code>:Perl5</code></strong> or <strong><code>:P5</code></strong> adverb switch the Regex parsing and matching to the way Perl regexes behave:</p>
<pre class="pod-block-code">so &#39;hello world&#39; ~~ m:Perl5/^hello (world)/;   # OUTPUT: «True␤»
so &#39;hello world&#39; ~~ m/^hello (world)/;         # OUTPUT: «False␤»
so &#39;hello world&#39; ~~ m/^ &#39;hello &#39; (&#39;world&#39;)/;   # OUTPUT: «True␤»</pre>
<p>The regular behavior is recommended and more idiomatic in Raku of course, but the <strong><code>:Perl5</code></strong> adverb can be useful when compatibility with Perl is required.</p>
<h2 id="Matching_adverbs"><a class="u" href="#___top" title="go to top of document">Matching adverbs</a></h2>
<p>In contrast to regex adverbs, which are tied to the declaration of a regex, matching adverbs only make sense when matching a string against a regex.</p>
<p>They can never appear inside a regex, only on the outside – either as part of an <code>m/.../</code> match or as arguments to a match method.</p>
<h3 id="Positional_adverbs"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-matching_adverb_:1st-matching_adverb_:2nd-matching_adverb_:3rd-matching_adverb_:nth-Positional_adverbs"><span class="index-entry">Positional adverbs</span></a></a></h3>
<p>Positional adverbs make the expression match only the string in the indicated position:</p>
<pre class="pod-block-code">my $data = &quot;f fo foo fooo foooo fooooo foooooo&quot;;
say $data ~~ m:nth(4)/fo+/;   # OUTPUT: «｢foooo｣␤»
say $data ~~ m:1st/fo+/;      # OUTPUT: «｢fo｣␤»
say $data ~~ m:3rd/fo+/;      # OUTPUT: «｢fooo｣␤»
say $data ~~ m:nth(1,3)/fo+/; # OUTPUT: «(｢fo｣ ｢fooo｣)␤»</pre>
<p>As you can see, the adverb argument can also be a list. There&#39;s actually no difference between the <code>:nth</code> adverb and the rest. You choose them only based on legibility. From 6.d, you can also use <code>Junction</code>s, <code>Seq</code>s and <code>Range</code>s, even infinite ones, as arguments.</p>
<pre class="pod-block-code">my $data = &quot;f fo foo fooo foooo fooooo foooooo&quot;;
say $data ~~ m:st(1|8)/fo+/;  # OUTPUT: «True␤»</pre>
<p>In this case, one of them exists (1), so it returns True. Observe that we have used <code>:st</code>. As said above, it&#39;s functionally equivalent, although obviously less legible than using <code>:nth</code>, so this last form is advised.</p>
<h3 id="Continue"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-matching_adverb_:continue-matching_adverb_:c-Continue"><span class="index-entry">Continue</span></a></a></h3>
<p>The <code>:continue</code> or short <code>:c</code> adverb takes an argument. The argument is the position where the regex should start to search. By default, it searches from the start of the string, but <code>:c</code> overrides that. If no position is specified for <code>:c</code>, it will default to <code>0</code> unless <code>$/</code> is set, in which case, it defaults to <code>$/.to</code>.</p>
<pre class="pod-block-code">given &#39;a1xa2&#39; {
    say ~m/a./;         # OUTPUT: «a1␤»
    say ~m:c(2)/a./;    # OUTPUT: «a2␤»
}</pre>
<p><em>Note:</em> unlike <code>:pos</code>, a match with :continue() will attempt to match further in the string, instead of failing:</p>
<pre class="pod-block-code">say &quot;abcdefg&quot; ~~ m:c(3)/e.+/; # OUTPUT: «｢efg｣␤»
say &quot;abcdefg&quot; ~~ m:p(3)/e.+/; # OUTPUT: «False␤»</pre>
<h3 id="Exhaustive"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-matching_adverb_:exhaustive-matching_adverb_:ex-Exhaustive"><span class="index-entry">Exhaustive</span></a></a></h3>
<p>To find all possible matches of a regex – including overlapping ones – and several ones that start at the same position, use the <code>:exhaustive</code> (short <code>:ex</code>) adverb.</p>
<pre class="pod-block-code">given &#39;abracadabra&#39; {
    for m:exhaustive/ a .* a / -&gt; $match {
        say &#39; &#39; x $match.from, ~$match;
    }
}</pre>
<p>The above code produces this output:</p>
<pre class="pod-block-code">    abracadabra
    abracada
    abraca
    abra
       acadabra
       acada
       aca
         adabra
         ada
           abra
</pre>
<h3 id="Global"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-matching_adverb_:global-matching_adverb_:g-Global"><span class="index-entry">Global</span></a></a></h3>
<p>Instead of searching for just one match and returning a <a href="/Documentable/integration-test/type/Match">Match object</a>, search for every non-overlapping match and return them in a <a href="/Documentable/integration-test/type/List">List</a>. In order to do this, use the <code>:global</code> adverb:</p>
<pre class="pod-block-code">given &#39;several words here&#39; {
    my @matches = m:global/\w+/;
    say @matches.elems;         # OUTPUT: «3␤»
    say ~@matches[2];           # OUTPUT: «here␤»
}</pre>
<p><code>:g</code> is shorthand for <code>:global</code>.</p>
<h3 id="Pos"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-matching_adverb_:pos-matching_adverb_:p-Pos"><span class="index-entry">Pos</span></a></a></h3>
<p>Anchor the match at a specific position in the string:</p>
<pre class="pod-block-code">given &#39;abcdef&#39; {
    my $match = m:pos(2)/.*/;
    say $match.from;        # OUTPUT: «2␤»
    say ~$match;            # OUTPUT: «cdef␤»
}</pre>
<p><code>:p</code> is shorthand for <code>:pos</code>.</p>
<p><em>Note:</em> unlike <code>:continue</code>, a match anchored with :pos() will fail, instead of attempting to match further down the string:</p>
<pre class="pod-block-code">say &quot;abcdefg&quot; ~~ m:c(3)/e.+/; # OUTPUT: «｢efg｣␤»
say &quot;abcdefg&quot; ~~ m:p(3)/e.+/; # OUTPUT: «False␤»</pre>
<h3 id="Overlap"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-matching_adverb_:overlap-matching_adverb_:ov-Overlap"><span class="index-entry">Overlap</span></a></a></h3>
<p>To get several matches, including overlapping matches, but only one (the longest) from each starting position, specify the <code>:overlap</code> (short <code>:ov</code>) adverb:</p>
<pre class="pod-block-code">given &#39;abracadabra&#39; {
    for m:overlap/ a .* a / -&gt; $match {
        say &#39; &#39; x $match.from, ~$match;
    }
}</pre>
<p>produces</p>
<pre class="pod-block-code">    abracadabra
       acadabra
         adabra
           abra
</pre>
<h2 id="Substitution_adverbs"><a class="u" href="#___top" title="go to top of document">Substitution adverbs</a></h2>
<p>You can apply matching adverbs (such as <code>:global</code>, <code>:pos</code> etc.) to substitutions. In addition, there are adverbs that only make sense for substitutions, because they transfer a property from the matched string to the replacement string.</p>
<h3 id="Samecase"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-substitution_adverb_:samecase-substitution_adverb_:ii-Samecase"><span class="index-entry">Samecase</span></a></a></h3>
<p>The <code>:samecase</code> or <code>:ii</code> substitution adverb implies the <code>:ignorecase</code> adverb for the regex part of the substitution, and in addition carries the case information to the replacement string:</p>
<pre class="pod-block-code">$_ = &#39;The cat chases the dog&#39;;
s:global:samecase[the] = &#39;a&#39;;
say $_;                 # OUTPUT: «A cat chases a dog»
</pre>
<p>Here you can see that the first replacement string <code>a</code> got capitalized, because the first string of the matched string was also a capital letter.</p>
<h3 id="Samemark"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-substitution_adverb_:samemark-substitution_adverb_:mm-Samemark"><span class="index-entry">Samemark</span></a></a></h3>
<p>The <code>:samemark</code> or <code>:mm</code> adverb implies <code>:ignoremark</code> for the regex, and in addition, copies the markings from the matched characters to the replacement string:</p>
<pre class="pod-block-code">given &#39;äộñ&#39; {
    say S:mm/ a .+ /uia/;           # OUTPUT: «üị̂ã»
}
</pre>
<h3 id="Samespace"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-substitution_adverb_:samespace-substitution_adverb_:ss-Samespace"><span class="index-entry">Samespace</span></a></a></h3>
<p>The <code>:samespace</code> or <code>:ss</code> substitution modifier implies the <code>:sigspace</code> modifier for the regex, and in addition, copies the whitespace from the matched string to the replacement string:</p>
<pre class="pod-block-code">say S:samespace/a ./c d/.raku given &quot;a b&quot;;      # OUTPUT: «&quot;c d&quot;»
say S:samespace/a ./c d/.raku given &quot;a\tb&quot;;     # OUTPUT: «&quot;c\td&quot;»
say S:samespace/a ./c d/.raku given &quot;a\nb&quot;;     # OUTPUT: «&quot;c\nd&quot;»
</pre>
<p>The <code>ss/.../.../</code> syntactic form is a shorthand for <code>s:samespace/.../.../</code>.</p>
<h1 id="Backtracking"><a class="u" href="#___top" title="go to top of document">Backtracking</a></h1>
<p>Raku defaults to <em>backtracking</em> when evaluating regular expressions. Backtracking is a technique that allows the engine to try different matching in order to allow every part of a regular expression to succeed. This is costly, because it requires the engine to usually eat up as much as possible in the first match and then adjust going backwards in order to ensure all regular expression parts have a chance to match.</p>
<p>In order to better understand backtracking, consider the following example:</p>
<pre class="pod-block-code">my $string = &#39;PostgreSQL is an SQL database!&#39;;
say $string ~~ /(.+)(SQL) (.+) $1/; # OUTPUT: «｢PostgreSQL is an SQL｣␤»
</pre>
<p>What happens in the above example is that the string has to be matched against the second occurrence of the word <em>SQL</em>, eating all characters before and leaving out the rest.</p>
<p>Since it is possible to execute a piece of code within a regular expression, it is also possible to inspect the <a href="/Documentable/integration-test/type/Match">Match</a> object within the regular expression itself:</p>
<pre class="pod-block-code">my $iteration = 0;
sub show-captures( Match $m ){
    my Str $result_split;
    say &quot;\n=== Iteration {++$iteration} ===&quot;;
    for $m.list.kv -&gt; $i, $capture {
        say &quot;Capture $i = $capture&quot;;
        $result_split ~= &#39;[&#39; ~ $capture ~ &#39;]&#39;;
    }

    say $result_split;
}

$string ~~ /(.+)(SQL) (.+) $1 .+ { show-captures( $/ );  }/;
</pre>
<p>The <code>show-captures</code> method will dump all the elements of <code>$/</code> producing the following output:</p>
<pre class="pod-block-code">=== Iteration 1 ===
Capture 0 = Postgre
Capture 1 = SQL
Capture 2 =  is an
[Postgre][SQL][ is an ]
</pre>
<p>showing that the string has been split around the second occurrence of <em>SQL</em>, that is the repetition of the first capture (<code>$/[1]</code>).</p>
<p>With that in place, it is now possible to see how the engine backtracks to find the above match: it does suffice to move the <code>show-captures</code> in the middle of the regular expression, in particular before the repetition of the first capture <code>$1</code> to see it in action:</p>
<pre class="pod-block-code">my $iteration = 0;
sub show-captures( Match $m ){
    my Str $result-split;
    say &quot;\n=== Iteration {++$iteration} ===&quot;;
    for $m.list.kv -&gt; $i, $capture {
        say &quot;Capture $i = $capture&quot;;
        $result-split ~= &#39;[&#39; ~ $capture ~ &#39;]&#39;;
    }

    say $result-split;
}

$string ~~ / (.+)(SQL) (.+) { show-captures( $/ );  } $1 /;
</pre>
<p>The output will be much more verbose and will show several iterations, with the last one being the <em>winning</em>. The following is an excerpt of the output:</p>
<pre class="pod-block-code">=== Iteration 1 ===
Capture 0 = PostgreSQL is an
Capture 1 = SQL
Capture 2 =  database!
[PostgreSQL is an ][SQL][ database!]

=== Iteration 2 ===
Capture 0 = PostgreSQL is an
Capture 1 = SQL
Capture 2 =  database
[PostgreSQL is an ][SQL][ database]

...

=== Iteration 24 ===
Capture 0 = Postgre
Capture 1 = SQL
Capture 2 =  is an
[Postgre][SQL][ is an ]
</pre>
<p>In the first iteration the <em>SQL</em> part of <em>PostgreSQL</em> is kept within the word: that is not what the regular expression asks for, so there&#39;s the need for another iteration. The second iteration will move back, in particular one character back (removing thus the final <em>!</em>) and try to match again, resulting in a fail since again the <em>SQL</em> is still kept within <em>PostgreSQL</em>. After several iterations, the final result is match.</p>
<p>It is worth noting that the final iteration is number <em>24</em>, and that such number is exactly the distance, in number of chars, from the end of the string to the first <em>SQL</em> occurrence:</p>
<pre class="pod-block-code">say $string.chars - $string.index: &#39;SQL&#39;; # OUTPUT: «23␤»
</pre>
<p>Since there are 23 chars from the very end of the string to the very first <em>S</em> of <em>SQL</em> the backtracking engine will need 23 &quot;useless&quot; matches to find the right one, that is, it will need 24 steps to get the final result.</p>
<p>Backtracking is a costly machinery, therefore it is possible to disable it in those cases where the matching can be found <em>forward</em> only.</p>
<p>With regards to the above example, disabling backtracking means the regular expression will not have any chance to match:</p>
<pre class="pod-block-code">say $string ~~ /(.+)(SQL) (.+) $1/;      # OUTPUT: «｢PostgreSQL is an SQL｣␤»
say $string ~~ / :r (.+)(SQL) (.+) $1/;  # OUTPUT: «Nil␤»
</pre>
<p>The fact is that, as shown in the <em>iteration 1</em> output, the first match of the regular expression engine will be <code>PostgreSQL is an </code>, <code>SQL</code>, <code>database</code> that does not leave out any room for matching another occurrence of the word <em>SQL</em> (as <code>$1</code> in the regular expression). Since the engine is not able to get backward and change the path to match, the regular expression fails.</p>
<p>It is worth noting that disabling backtracking will not prevent the engine to try several ways to match the regular expression. Consider the following slightly changed example:</p>
<pre class="pod-block-code">my $string = &#39;PostgreSQL is an SQL database!&#39;;
say $string ~~ / (SQL) (.+) $1 /; # OUTPUT: «Nil␤»
</pre>
<p>Since there is no specification for a character before the word <em>SQL</em>, the engine will match against the rightmost word <em>SQL</em> and go forward from there. Since there is no repetition of <em>SQL</em> remaining, the match fails. It is possible, again, to inspect what the engine performs introducing a dumping piece of code within the regular expression:</p>
<pre class="pod-block-code">my $iteration = 0;
sub show-captures( Match $m ){
    my Str $result-split;
    say &quot;\n=== Iteration {++$iteration} ===&quot;;
    for $m.list.kv -&gt; $i, $capture {
        say &quot;Capture $i = $capture&quot;;
        $result-split ~= &#39;[&#39; ~ $capture ~ &#39;]&#39;;
    }

    say $result-split;
}

$string ~~ / (SQL) (.+) { show-captures( $/ ); } $1 /;
</pre>
<p>that produces a rather simple output:</p>
<pre class="pod-block-code">=== Iteration 1 ===
Capture 0 = SQL
Capture 1 =  is an SQL database!
[SQL][ is an SQL database!]

=== Iteration 2 ===
Capture 0 = SQL
Capture 1 =  database!
[SQL][ database!]
</pre>
<p>Even using the <a href="/Documentable/integration-test/language/regexes#Ratchet">:r</a> adverb to prevent backtracking will not change things:</p>
<pre class="pod-block-code">my $iteration = 0;
sub show-captures( Match $m ){
    my Str $result-split;
    say &quot;\n=== Iteration {++$iteration} ===&quot;;
    for $m.list.kv -&gt; $i, $capture {
        say &quot;Capture $i = $capture&quot;;
        $result-split ~= &#39;[&#39; ~ $capture ~ &#39;]&#39;;
    }

    say $result-split;
}

$string ~~ / :r (SQL) (.+) { show-captures( $/ ); } $1 /;
</pre>
<p>and the output will remain the same:</p>
<pre class="pod-block-code">=== Iteration 1 ===
Capture 0 = SQL
Capture 1 =  is an SQL database!
[SQL][ is an SQL database!]

=== Iteration 2 ===
Capture 0 = SQL
Capture 1 =  database!
[SQL][ database!]
</pre>
<p>This demonstrates that disabling backtracking does not mean disabling possible multiple iterations of the matching engine, but rather disabling the backward matching tuning.</p>
<h1 id="$/_changes_each_time_a_regular_expression_is_matched"><a class="u" href="#___top" title="go to top of document"><code>$/</code> changes each time a regular expression is matched</a></h1>
<p>It is worth noting that each time a regular expression is used, the <a href="/Documentable/integration-test/type/Match">Match object</a> returned (i.e., <code>$/</code>) is reset. In other words, <code>$/</code> always refers to the very last regular expression matched:</p>
<pre class="pod-block-code">my $answer = &#39;a lot of Stuff&#39;;
say &#39;Hit a capital letter!&#39; if $answer ~~ / &lt;[A..Z&gt;]&gt; /;
say $/;  # OUTPUT: «｢S｣␤»
say &#39;hit an x!&#39; if $answer ~~ / x /;
say $/;  # OUTPUT: «Nil␤»
</pre>
<p>The reset of <code>$/</code> applies independently from the scope where the regular expression is matched:</p>
<pre class="pod-block-code">my $answer = &#39;a lot of Stuff&#39;;
if $answer ~~ / &lt;[A..Z&gt;]&gt; / {
   say &#39;Hit a capital letter&#39;;
   say $/;  # OUTPUT: «｢S｣␤»
}
say $/;     # OUTPUT: «｢S｣␤»

if True {
  say &#39;hit an x!&#39; if $answer ~~ / x /;
  say $/;   # OUTPUT: «Nil␤»
}

say $/;     # OUTPUT: «Nil␤»
</pre>
<p>The very same concept applies to named captures:</p>
<pre class="pod-block-code">my $answer = &#39;a lot of Stuff&#39;;
if $answer ~~ / $&lt;capital&gt;=&lt;[A..Z&gt;]&gt; / {
   say &#39;Hit a capital letter&#39;;
   say $/&lt;capital&gt;; # OUTPUT: «｢S｣␤»
}

say $/&lt;capital&gt;;    # OUTPUT: «｢S｣␤»
say &#39;hit an x!&#39; if $answer ~~ / $&lt;x&gt;=x /;
say $/&lt;x&gt;;          # OUTPUT: «Nil␤»
say $/&lt;capital&gt;;    # OUTPUT: «Nil␤»
</pre>
<h1 id="Best_practices_and_gotchas"><a class="u" href="#___top" title="go to top of document">Best practices and gotchas</a></h1>
<p>The <a href="/Documentable/integration-test/language/regexes-best-practices">Regexes: Best practices and gotchas</a> provides useful information on how to avoid common pitfalls when writing regexes and grammars.</p>

        </div>
    </div>

    

    <footer class="pretty-box yellow">
        <p>
            Generated from <a href="https://github.com/Raku/doc/tree/master/docs/Language/regexes.pod6">https://github.com/Raku/doc/tree/master/docs/Language/regexes.pod6</a>.
        </p>
        <p>
            This is a work in progress to document Raku (formerly known as Perl 6), and
            known to be incomplete.
        </p>
        <p>
            <a href="https://github.com/raku/doc/blob/master/CONTRIBUTING.md#reporting-bugs">
                Please report any issues
            </a>
            Your contribution is appreciated.
        </p>
        <p>
            This documentation is provided under the terms of the
            <a href="https://raw.githubusercontent.com/raku/doc/master/LICENSE">
                Artistic License 2.0
            </a>. The Camelia image is
            <a href="https://raw.githubusercontent.com/raku/mu/master/misc/camelia.txt">
                copyright © 2009 by Larry Wall.
            </a>
            <!-- CREDITS -->
            <!--External Link Image by Zapyon, CCA-SA 4.0. Derived from Wikimedia Foundation https://commons.wikimedia.org/wiki/File:External-link-04-bold-12x12.svg -->
        </p>
    </footer>

    <script type="text/javascript" src="/Documentable/integration-test/js/app.js?v=1"></script>
    <script type="text/javascript" src="/Documentable/integration-test/js/search.js?v=3"></script>
</body>
</html>


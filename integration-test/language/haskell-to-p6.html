<!doctype html>
<html lang="en">
<head>
    <title>Haskell to Raku - nutshell</title>
    <meta charset="UTF-8"/>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <link rel="icon" href="/Documentable/integration-test/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" type="text/css" href="/Documentable/integration-test/css/app.css" media="screen" title="default" />
    <noscript> <style> #search { visibility: hidden; } </style> </noscript>
</head>

<body class="pod">

    <div id="___top"></div>

    <div id="header" class="pretty-box green">

        <a href="/Documentable/integration-test/">
            <img src="/Documentable/integration-test/images/Camelia.svg"alt="»ö«"id="logo"width="62"height="48"/> &nbsp;Raku Documentation
        </a>

        <div id="search" class="ui-widget">
            <div class="green">
                <input placeholder="Loading..." id="query" accesskey="f" title="Enter term to search for (hit Esc to focus)"/>
            </div>
            <p id="not-found-message">
                Not in Index (<a href="" id="try-web-search">try site search</a>)
            </p>
        </div>
        
        <div class="menu">
            
            <div class="menu-items dark-green">
                <a class='menu-item darker-green' href='https://raku.org'><strong>Raku homepage</strong></a>
                    <a class="menu-item selected darker-green" href="/Documentable/integration-test/language.html"> Language </a>
                    <a class="menu-item " href="/Documentable/integration-test/type.html"> Types </a>
                    <a class="menu-item " href="/Documentable/integration-test/routine.html"> Routines </a>
                    <a class="menu-item " href="https://webchat.freenode.net/?channels=#raku"> Chat with us </a>
            </div>
            
            
            
        
        </div>
    </div>

    <div id="content" class="pretty-box yellow content_fragment">

        <div align="right" style="display:;">
            <button title="Edit this page"  class="pencil" onclick="location='https://github.com/Raku/doc/tree/master/docs/Language/haskell-to-p6.pod6'">
                <svg width="14px" height="16px" viewBox="0 0 14 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                    <defs></defs>
                    <g id="Octicons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g id="pencil" fill="#000000">
                            <path d="M0,12 L0,15 L3,15 L11,7 L8,4 L0,12 L0,12 Z M3,14 L1,14 L1,12 L2,12 L2,13 L3,13 L3,14 L3,14 Z M13.3,4.7 L12,6 L9,3 L10.3,1.7 C10.69,1.31 11.32,1.31 11.71,1.7 L13.3,3.29 C13.69,3.68 13.69,4.31 13.3,4.7 L13.3,4.7 Z" id="Shape"></path>
                        </g>
                    </g>
                </svg>
            </button>
        </div>

        <h1 class="title">Haskell to Raku - nutshell</h1>
        <p class="subtitle">Learning Raku from Haskell, in a nutshell: what do I already know?</p>

        <nav class="indexgroup">
<table id="TOC">
<caption><h2 id="TOC_Title">Table of Contents</h2></caption>
      <tr class="toc-level-1"><td class="toc-number">1</td><td class="toc-text"><a href="#Types">Types</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">1.1</td><td class="toc-text"><a href="#Types_vs_values">Types vs values</a></td></tr>
                             <tr class="toc-level-2"><td class="toc-number">1.2</td><td class="toc-text"><a href="#Maybe">Maybe</a></td></tr>
                                                                                              <tr class="toc-level-2"><td class="toc-number">1.3</td><td class="toc-text"><a href="#Data_definitions">Data definitions</a></td></tr>
                                                 <tr class="toc-level-2"><td class="toc-number">1.4</td><td class="toc-text"><a href="#Type_aliases_and_subsets">Type aliases and subsets</a></td></tr>
                              <tr class="toc-level-2"><td class="toc-number">1.5</td><td class="toc-text"><a href="#Typeclasses">Typeclasses</a></td></tr>
   <tr class="toc-level-1"><td class="toc-number">2</td><td class="toc-text"><a href="#Functions">Functions</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">2.1</td><td class="toc-text"><a href="#Definitions_and_signatures">Definitions and signatures</a></td></tr>
                                                                                          <tr class="toc-level-2"><td class="toc-number">2.2</td><td class="toc-text"><a href="#Currying">Currying</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">2.3</td><td class="toc-text"><a href="#Composing">Composing</a></td></tr>
   <tr class="toc-level-1"><td class="toc-number">3</td><td class="toc-text"><a href="#Case_/_matching">Case / matching</a></td></tr>
                                <tr class="toc-level-1"><td class="toc-number">4</td><td class="toc-text"><a href="#Lists">Lists</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.1</td><td class="toc-text"><a href="#List_comprehensions">List comprehensions</a></td></tr>
                                                     <tr class="toc-level-2"><td class="toc-number">4.2</td><td class="toc-text"><a href="#Fold">Fold</a></td></tr>
                                                      <tr class="toc-level-2"><td class="toc-number">4.3</td><td class="toc-text"><a href="#Map">Map</a></td></tr>
  <tr class="toc-level-2"><td class="toc-number">4.4</td><td class="toc-text"><a href="#Ranges">Ranges</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">4.5</td><td class="toc-text"><a href="#Laziness_vs_eagerness">Laziness vs eagerness</a></td></tr>
           <tr class="toc-level-1"><td class="toc-number">5</td><td class="toc-text"><a href="#Contexts_(let-in_/_where)">Contexts (let-in / where)</a></td></tr>
          <tr class="toc-level-1"><td class="toc-number">6</td><td class="toc-text"><a href="#Parsers">Parsers</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">6.1</td><td class="toc-text"><a href="#Parser_combinators_vs_grammars">Parser combinators vs grammars</a></td></tr>
  <tr class="toc-level-1"><td class="toc-number">7</td><td class="toc-text"><a href="#Tail_Call_Optimization_or_Tail_Call_Elimination">Tail Call Optimization or Tail Call Elimination</a></td></tr>
    
</table>
</nav>

        <div class="pod-body ">
            <p>Haskell and Raku are <em>very</em> different languages. This is obvious. However, that does not mean there are not similarities or shared ideas! This page attempts to get a Haskell user up and running with Raku. The Haskell user may find that they need not abandon all of their Haskelly thoughts while scripting in Raku.</p>
<p>Note that this should not be mistaken for a beginner tutorial or overview of Raku; it is intended as a technical reference for Raku learners with a strong Haskell background.</p>
<h1 id="Types"><a class="u" href="#___top" title="go to top of document">Types</a></h1>
<h2 id="Types_vs_values"><a class="u" href="#___top" title="go to top of document">Types vs values</a></h2>
<p>In Haskell, you have type level programming and then value level programming.</p>
<pre class="pod-block-code">plusTwo :: Integer -&gt; Integer   -- Types
plusTwo x = x + 2               -- Values
</pre>
<p>You do not mix types and values in Haskell like the below</p>
<pre class="pod-block-code">plusTwo 2          -- This is valid
plusTwo Integer    -- This is not valid
</pre>
<p>In Raku, types (AKA type objects) live on the same level as values</p>
<pre class="pod-block-code">sub plus-two(Int $x --&gt; Int) { $x + 2 }

plus-two(2);    # This is valid
plus-two(Int);  # This is valid
</pre>
<p>I will illustrate this unique aspect of Raku with one more example:</p>
<pre class="pod-block-code">multi sub is-string(Str $ --&gt; True) {}
multi sub is-string(Any $ --&gt; False) {}

is-string(&#39;hello&#39;);    #True
is-string(4);          #False
</pre>
<h2 id="Maybe"><a class="u" href="#___top" title="go to top of document">Maybe</a></h2>
<p>In Haskell, you have a Maybe type that allows you to forgo the worry of null types. Let&#39;s say you have a hypothetical function that parses a String to an Integer:</p>
<pre class="pod-block-code">parseInt :: String -&gt; Maybe Integer

case parseInt myString of
  Just x  -&gt; x
  Nothing -&gt; 0
</pre>
<p>In Raku, since type objects coexist with regular objects, we have the concept of Defined and Undefined objects. Plain type objects are undefined while instantiated objects are defined.</p>
<pre class="pod-block-code">sub parse-int(Str $s --&gt; Int) { ... }

my $string = {...};
given parse-int($string) {
  when Int:D { $_ }
  when Int:U { 0 }
}
</pre>
<p>So in Raku we have type constraints that indicate the definedness of a type. These are</p>
<pre class="pod-block-code">Int:D; # This is a defined Int.
Int:U; # This is an undefined Int, AKA a type object
Int:_; # This is either defined or undefined.
</pre>
<p>If we wanted to be explicit in the above example (probably a good idea), we could add the <code>:_</code> constraint on the return type. This would let the user know that they should account for both defined and undefined return values. We could also use other methods and constructs that specifically test for definedness.</p>
<pre class="pod-block-code">sub parse-int(Str $s --&gt; Int:_) { ... }

# One way to do it
my $string = {...};
given parse-int($string) {
  when Int:D { $_ }
  when Int:U { 0 }
}

# Another way to do it
my Int $number = parse-int($string);
if $number.defined { $number } else { 0 }


# A better way
with parse-int($string) { $_ } else { 0 }

# With the defined-or operator
parse-int($string) // 0
</pre>
<p>The <code>with</code> operator that you see above is like <code>if</code>, except it explicitly tests for definedness and then passes the result to the following block. Similarly, <code>without</code> tests that the object is undefined and also passes the result to the following block.</p>
<p>For more natural control flow with undefined and defined types, Raku introduces <code>andthen</code> and <code>orelse</code>.</p>
<pre class="pod-block-code">sub parse-int(Str $s --&gt; Int:_) { ... }

my $string = {...};
my $result = parse-int($string) orelse 0;

sub hello() { say &#39;hi&#39; }
hello() andthen say &#39;bye&#39;;
</pre>
<p>So in practice, Raku does not have the concept of a null type, but rather of defined or undefined types.</p>
<h2 id="Data_definitions"><a class="u" href="#___top" title="go to top of document">Data definitions</a></h2>
<p>Raku is fundamentally an object oriented language. However, it also gives you the freedom to write in virtually any paradigm you wish. If you only want to pure functions that take an object and return a new object, you can certainly do so.</p>
<p>Here is a Haskell code example:</p>
<pre class="pod-block-code">data Point = Point x y

moveUp :: Point -&gt; Point
moveUp (Point x y) = Point x (y + 1)
</pre>
<p>And an equivalent Raku example:</p>
<pre class="pod-block-code">class Point { has $.x; has $.y; }

sub move-up(Point $p --&gt; Point) {
  Point.new(x =&gt; $p.x, y =&gt; $p.y + 1)
}
</pre>
<p>The code I illustrated above is an example of a <a href="https://wiki.haskell.org/Algebraic_data_type">Product Type</a>. If instead you&#39;d like to write a Sum Type, there is not an exact equivalent in Raku. The closest thing would be an <a href="/Documentable/integration-test/language/typesystem#enum">Enum</a>.</p>
<pre class="pod-block-code">data Animal = Dog | Cat | Bird | Horse

testAnimal :: Animal -&gt; String
testAnimal Dog   = &quot;Woof&quot;
testAnimal Horse = &quot;Neigh&quot;
</pre>
<p>Although it does not fit the same exact use cases, it can be used in putting constraints on types.</p>
<pre class="pod-block-code">enum Animal &lt; Dog Cat Bird Horse &gt;;

proto sub test-animal( Animal        ) {*}
multi sub test-animal( Dog           ) { &#39;Woof&#39; }
multi sub test-animal( Animal::Horse ) { &#39;Neigh&#39;  }   # more explicit

say test-animal Animal::Dog;                          # more explicit
say test-animal Horse;
</pre>
<h2 id="Type_aliases_and_subsets"><a class="u" href="#___top" title="go to top of document">Type aliases and subsets</a></h2>
<p>In Haskell, you can alias an existing type to simply increase clarity of intent and re-use existing types.</p>
<pre class="pod-block-code">type Name = String

fullName :: Name -&gt; Name -&gt; Name
fullName first last = first ++ last
</pre>
<p>The equivalent in Raku is the following.</p>
<pre class="pod-block-code">my constant Name = Str;

sub full-name ( Name \first, Name \last --&gt; Name ) { first ~ last }
</pre>
<p>It should be noted that in Raku, one can also create a subset of an existing type.</p>
<pre class="pod-block-code">subset Name of Str where *.chars &lt; 20;

sub full-name(Name $first, Name $last) {
  $first ~ $last
}

full-name(&quot;12345678901234567890111&quot;, &quot;Smith&quot;) # This does not compile, as the first parameter
                                              # doesn&#39;t fit the Name type
</pre>
<h2 id="Typeclasses"><a class="u" href="#___top" title="go to top of document">Typeclasses</a></h2>
<p>TODO</p>
<h1 id="Functions"><a class="u" href="#___top" title="go to top of document">Functions</a></h1>
<h2 id="Definitions_and_signatures"><a class="u" href="#___top" title="go to top of document">Definitions and signatures</a></h2>
<section><h1>Pattern</h1>
<p>Matching</p>
</section>
<p>Haskell makes heavy use of pattern matching in function definitions.</p>
<pre class="pod-block-code">greeting :: String -&gt; String
greeting  &quot;&quot;   = &quot;Hello, World!&quot;
greeting &quot;bub&quot; = &quot;Hey bub.&quot;
greeting  name = &quot;Hello, &quot; ++ name ++ &quot;!&quot;
</pre>
<p>Raku does this as well! You just use the <code>multi</code> keyword to signify that it is a multiple dispatch function.</p>
<pre class="pod-block-code">proto greeting ( Str   --&gt; Str ) {*}
multi greeting ( &quot;&quot;    --&gt; &quot;Hello, World!&quot; ) {}
multi greeting ( &quot;bub&quot; --&gt; &quot;Hey bub.&quot; ) {}
multi greeting ( \name ) { &quot;Hello, &quot; ~ name ~ &quot;!&quot; }
</pre>
<p>The <code>proto</code> declarator is not necessary, but can sometimes aid in making sure that all multis follow your business rules. Using a variable name in the signature of the proto would provide more information in error messages, and for introspection.</p>
<pre class="pod-block-code">proto greeting ( Str \name --&gt; Str ) {*}

say &amp;greeting.signature;                  # (Str \name --&gt; Str)
</pre>
<p>An interesting thing to note in the Raku code above is that passing values like <code>&#39;bub&#39;</code> as a function parameter is just syntax sugar for a <code>where</code> guard.</p>
<section><h1>Guards</h1>
</section>
<p>Using the example from the &quot;Pattern Matching&quot; section of this page, you can see the guards that are used behind the scenes to constrain our function arguments.</p>
<pre class="pod-block-code">multi greeting ( &quot;&quot;    --&gt; &quot;Hello, World!&quot; ) {}
multi greeting ( &quot;bub&quot; --&gt; &quot;Hey bub.&quot; ) {}

# The above is the same as the below

multi greeting(Str \name where &#39;&#39;    ) {&#39;Hello, World!&#39;}
multi greeting(Str \name where &#39;bub&#39; ) {&#39;Hey bub.&#39;}

# The above is the same as the below, again.

multi greeting(Str \name where $_ ~~ &#39;&#39;   ) {&#39;Hello, World!&#39;}
multi greeting(Str \name where $_ ~~ &#39;bub&#39;) {&#39;Hey bub.&#39;}
</pre>
<p><code>$_</code> is known as the topic variable. It assumes the form of whatever is appropriate. The smartmatch operator <code>~~</code> figures out the best way to determine if the left matches the right, be it number ranges, strings, etc. Our three examples above go from most sugared (top), to least sugared (bottom).</p>
<p>The bottom examples above could be wrapped in curly braces, making it more obvious that it is a code block. Note that a where clause may also take an explicit Callable.</p>
<pre class="pod-block-code">multi greeting(Str \name where { $_ ~~ &#39;&#39; } ) {&#39;Hello, World!&#39;}

multi greeting(Str \name where -&gt; $thing { $thing ~~ &#39;&#39; } ) {&#39;Hello, World!&#39;}

multi greeting ( Str \name where { Bool.pick } --&gt; &#39;True&#39; ){}

multi greeting ( Str \name where &amp;some-subroutine ){…}
</pre>
<p>If you read the section in this page on subsets, you&#39;ll notice that &quot;where&quot; is used in the making of subsets as well as here. The usage of &quot;where&quot; in both areas is exactly the same.</p>
<p>When using <code>where</code>, note that the order of definition is important, just like in Haskell.</p>
<pre class="pod-block-code">multi greeting ( Str \name where &#39;&#39; --&gt; &#39;Hello, World!&#39; ){}
multi greeting ( Str \name where { Bool.pick } --&gt; &#39;True&#39; ){}
multi greeting ( Str \name where &#39;bub&#39; --&gt; &#39;Hey, bub.&#39; ){}

say greeting &#39;&#39;   ; # will never say True
say greeting &#39;bub&#39;; # about 50% of the time it will say True
</pre>
<section><h1>Argument</h1>
<p>Deconstruction</p>
</section>
<p>TODO</p>
<h2 id="Currying"><a class="u" href="#___top" title="go to top of document">Currying</a></h2>
<p>TODO</p>
<p>.assuming vs currying</p>
<p>method chaining vs currying</p>
<h2 id="Composing"><a class="u" href="#___top" title="go to top of document">Composing</a></h2>
<p>TODO</p>
<p>show function composition operator. Maybe explain a more native Raku way to do this though.</p>
<h1 id="Case_/_matching"><a class="u" href="#___top" title="go to top of document">Case / matching</a></h1>
<p>Haskell makes heavy use of case matching like the below:</p>
<pre class="pod-block-code">case number of
  2 -&gt; &quot;two&quot;
  4 -&gt; &quot;four&quot;
  8 -&gt; &quot;eight&quot;
  _ -&gt; &quot;don&#39;t care&quot;
</pre>
<p>In Raku you can achieve this same thing with the given/when structure:</p>
<pre class="pod-block-code">my $number = {...};
given $number {
  when 2  { &quot;two&quot; }
  when 4  { &quot;four&quot; }
  when 8  { &quot;eight&quot; }
  default { &quot;don&#39;t care&quot; }
}
</pre>
<p>Note that the order of the <code>when</code>&#39;s is also significant, just like with the <code>where</code>&#39;s in the guard section of this page.</p>
<h1 id="Lists"><a class="u" href="#___top" title="go to top of document">Lists</a></h1>
<p>TODO</p>
<p>explain differences between Raku Arrays, Sequences, and Lists. Explain data shapes in regards to the <code>@</code> sigil. Explain how you can convert an Array to a flattened list of objects with <code>|@</code></p>
<p>data shapes become quite intuitive, but it takes a bit of practice.</p>
<h2 id="List_comprehensions"><a class="u" href="#___top" title="go to top of document">List comprehensions</a></h2>
<p>There are no explicit list comprehensions in Raku. But you can achieve list comprehensions a couple of different ways.</p>
<p>Here is a trivial example in Haskell:</p>
<pre class="pod-block-code">evens = [ x | x &lt;- [0..100], even x ]
</pre>
<p>And now in Raku:</p>
<pre class="pod-block-code"># using `if` and `for`
my @evens = ($_ if $_ %% 2 for 0..100);

# using gather/take to build a Seq
my $evens = gather for 0..100 { take $_ if $_ %% 2 };

# using gather/take to build an Array
my @evens = gather for 0..100 { take $_ if $_ %% 2 };
</pre>
<p>Since <code>for</code> is always eager it is generally better to use <code>map</code> or <code>grep</code> which will inherit the laziness or eagerness of its list argument.</p>
<pre class="pod-block-code">my @evens = map { $_ if $_ %% 2 }, 0..100;

my @evens = grep { $_ %% 2 }, 0..100;

# using a Whatever lambda
my @evens = grep  * %% 2,  0..100;
</pre>
<p>Here is the creation of tuples in Haskell:</p>
<pre class="pod-block-code">tuples = [(i,j) | i &lt;- [1,2],
                  j &lt;- [1..4] ]
-- [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4)]
</pre>
<p>And in Raku:</p>
<pre class="pod-block-code">my @tuples = 1,2  X  1..4;
# [(1,1), (1,2), (1,3), (1,4), (2,1), (2,2), (2,3), (2,4)]
</pre>
<p>See this design document for more information on what kinds of list comprehensions are possible in: <a href="https://design.raku.org/S04.html#The_do-once_loop">https://design.raku.org/S04.html#The_do-once_loop</a>.</p>
<p>As you can see, when you get into some more advanced Haskell list comprehensions, Raku does not translate exactly the same, but it&#39;s possible to do the same things, nonetheless.</p>
<h2 id="Fold"><a class="u" href="#___top" title="go to top of document">Fold</a></h2>
<p>Fold in Haskell is called Reduce in Raku.</p>
<pre class="pod-block-code">mySum = foldl `+` 0 numList
</pre>
<pre class="pod-block-code">my @numbers = {...};
reduce { $^a + $^b }, 0, |@numbers;
@numbers.reduce({$^a + $^b}, with =&gt; 0)
</pre>
<p>However, in Raku, if you want to use an infix operator (+ - / % etc) there is a nice little helper called the Reduction metaoperator.</p>
<pre class="pod-block-code">my @numbers = {...};
[+] @numbers    # This is the same
[+] 0, @numbers # as this
</pre>
<p>It inserts the operator in between all values in the list and produces a result, just like Fold.</p>
<p>In Haskell you, you have foldl and foldr. In Raku, this difference is determined by the associativity attached to the operator/subroutine.</p>
<pre class="pod-block-code">sub two-elem-list ( \a, \b ) { ( a, b ) }

# you can use a subroutine as an infix operator
say &#39;a&#39; [&amp;two-elem-list] &#39;b&#39;; # (a b)

# as the reduction prefix metaoperator takes an infix operator, it will work there too;
[[&amp;two-elem-list]] 1..5;           # ((((1 2) 3) 4) 5)
say (1..5).reduce: &amp;two-elem-list; # ((((1 2) 3) 4) 5)

# right associative
sub right-two-elem-list( \a, \b ) is assoc&lt;right&gt; { ( a, b ) }
say (1..5).reduce: &amp;right-two-elem-list; # (1 (2 (3 (4 5))))

# XXX there is possibly a bug here as this currently doesn&#39;t look at
# XXX the associativity of &amp;right-two-elem-list and just always does left assoc
say [[&amp;right-two-elem-list]] 1..5;

# chaining
say [&lt;] 1..5;            # True
say (1..5).reduce: &amp;[&lt;]; # True
</pre>
<h2 id="Map"><a class="u" href="#___top" title="go to top of document">Map</a></h2>
<p>TODO</p>
<h2 id="Ranges"><a class="u" href="#___top" title="go to top of document">Ranges</a></h2>
<p>Haskell and Raku both allow you to specify ranges of values.</p>
<pre class="pod-block-code">myRange1 = 10..100
myRange2 = 1..        -- Infinite
myRange3 = &#39;a&#39;..&#39;h&#39;   -- Letters work too
</pre>
<pre class="pod-block-code">my $range1 = 10..100;
my $range2 = 1..*;      # Infinite
my $range3 = &#39;a&#39;..&#39;h&#39;;  # Letters work too
</pre>
<h2 id="Laziness_vs_eagerness"><a class="u" href="#___top" title="go to top of document">Laziness vs eagerness</a></h2>
<p>In the examples above, you have the concept of laziness displayed very plainly. Raku has laziness only where it makes the most sense. For example, in the range 10..100, this is eager because it has a definite end. If a list does not have a definite end, then the list should clearly be lazy.</p>
<pre class="pod-block-code">(1 .. 100).is-lazy; # False
(1 .. Inf).is-lazy; # True
</pre>
<p>These are the &quot;sane defaults&quot; that Raku takes pride in. But they are still defaults and can be changed into one or the other.</p>
<pre class="pod-block-code">(1 .. 100).lazy.is-lazy;       # True
(1 .. 100).lazy.eager.is-lazy; # False
</pre>
<h1 id="Contexts_(let-in_/_where)"><a class="u" href="#___top" title="go to top of document">Contexts (let-in / where)</a></h1>
<p>TODO</p>
<p>explain how <code>given/when</code> and <code>with/without</code> and <code>for loops</code> open lexical scopes with the argument as the context.</p>
<p>compare it to let/in and where constructs maybe?</p>
<h1 id="Parsers"><a class="u" href="#___top" title="go to top of document">Parsers</a></h1>
<h2 id="Parser_combinators_vs_grammars"><a class="u" href="#___top" title="go to top of document">Parser combinators vs grammars</a></h2>
<p>TODO</p>
<h1 id="Tail_Call_Optimization_or_Tail_Call_Elimination"><a class="u" href="#___top" title="go to top of document">Tail Call Optimization or Tail Call Elimination</a></h1>
<p>Haskell and many other functional programming languages use tail call optimization, also sometimes called tail tall elimination, to remove the stack overhead of some types of recursive function calls.</p>
<p>There is nothing in the Raku language specification forbidding the implementation of this class of optimization, but no current implementation has it.</p>
<p>Please note that many Haskell looping constructs use recursive function calls. Haskell programs would encounter stack overflow errors more often without tail call optimization. The standard Raku looping constructs are not built on recursive function calls, which makes the feature less important.</p>

        </div>
    </div>

    

    <footer class="pretty-box yellow">
        <p>
            Generated from <a href="https://github.com/Raku/doc/tree/master/docs/Language/haskell-to-p6.pod6">https://github.com/Raku/doc/tree/master/docs/Language/haskell-to-p6.pod6</a>.
        </p>
        <p>
            This is a work in progress to document Raku (formerly known as Perl 6), and
            known to be incomplete.
        </p>
        <p>
            <a href="https://github.com/raku/doc/blob/master/CONTRIBUTING.md#reporting-bugs">
                Please report any issues
            </a>
            Your contribution is appreciated.
        </p>
        <p>
            This documentation is provided under the terms of the
            <a href="https://raw.githubusercontent.com/raku/doc/master/LICENSE">
                Artistic License 2.0
            </a>. The Camelia image is
            <a href="https://raw.githubusercontent.com/raku/mu/master/misc/camelia.txt">
                copyright © 2009 by Larry Wall.
            </a>
            <!-- CREDITS -->
            <!--External Link Image by Zapyon, CCA-SA 4.0. Derived from Wikimedia Foundation https://commons.wikimedia.org/wiki/File:External-link-04-bold-12x12.svg -->
        </p>
    </footer>

    <script type="text/javascript" src="/Documentable/integration-test/js/app.js?v=1"></script>
    <script type="text/javascript" src="/Documentable/integration-test/js/search.js?v=3"></script>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
    <title>class Slip</title>
    <meta charset="UTF-8"/>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <link rel="icon" href="/Documentable/integration-test/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" type="text/css" href="/Documentable/integration-test/css/app.css" media="screen" title="default" />
    <noscript> <style> #search { visibility: hidden; } </style> </noscript>
</head>

<body class="pod">

    <div id="___top"></div>

    <div id="header" class="pretty-box green">

        <a href="/Documentable/integration-test/">
            <img src="/Documentable/integration-test/images/Camelia.svg"alt="»ö«"id="logo"width="62"height="48"/> &nbsp;Raku Documentation
        </a>

        <div id="search" class="ui-widget">
            <div class="green">
                <input placeholder="Loading..." id="query" accesskey="f" title="Enter term to search for (hit Esc to focus)"/>
            </div>
            <p id="not-found-message">
                Not in Index (<a href="" id="try-web-search">try site search</a>)
            </p>
        </div>
        
        <div class="menu">
            
            <div class="menu-items dark-green">
                <a class='menu-item darker-green' href='https://raku.org'><strong>Raku homepage</strong></a>
                    <a class="menu-item " href="/Documentable/integration-test/language.html"> Language </a>
                    <a class="menu-item selected darker-green" href="/Documentable/integration-test/type.html"> Types </a>
                    <a class="menu-item " href="/Documentable/integration-test/routine.html"> Routines </a>
                    <a class="menu-item " href="https://webchat.freenode.net/?channels=#raku"> Chat with us </a>
            </div>
            
            <div class="menu-items darker-green"><div class="menu-items darker-green"><div class="menu-items darker-green"><div class="menu-items darker-green">
                    <a class="menu-item" href="/Documentable/integration-test/type.html"> All </a>
                    <a class="menu-item" href="/Documentable/integration-test/type-basic.html"> Basic </a>
                    <a class="menu-item" href="/Documentable/integration-test/type-html-generation.html"> HTML Generation </a>
                    <a class="menu-item" href="/Documentable/integration-test/type-exception.html"> Exceptions </a>
            </div></div></div></div>
        
        </div>
    </div>

    <div id="content" class="pretty-box yellow content_fragment">

        <div align="right" style="display:;">
            <button title="Edit this page"  class="pencil" onclick="location='https://github.com/Raku/doc/tree/master/docs/Type/Slip.pod6'">
                <svg width="14px" height="16px" viewBox="0 0 14 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                    <defs></defs>
                    <g id="Octicons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g id="pencil" fill="#000000">
                            <path d="M0,12 L0,15 L3,15 L11,7 L8,4 L0,12 L0,12 Z M3,14 L1,14 L1,12 L2,12 L2,13 L3,13 L3,14 L3,14 Z M13.3,4.7 L12,6 L9,3 L10.3,1.7 C10.69,1.31 11.32,1.31 11.71,1.7 L13.3,3.29 C13.69,3.68 13.69,4.31 13.3,4.7 L13.3,4.7 Z" id="Shape"></path>
                        </g>
                    </g>
                </svg>
            </button>
        </div>

        <h1 class="title">class Slip</h1>
        <p class="subtitle">A kind of List that automatically flattens into an outer container</p>

        <nav class="indexgroup">
<table id="TOC">
<caption><h2 id="TOC_Title">Table of Contents</h2></caption>
                                                                        <tr class="toc-level-1"><td class="toc-number">1</td><td class="toc-text"><a href="#Methods">Methods</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">1.1</td><td class="toc-text"><a href="#method_List">method List</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">1.2</td><td class="toc-text"><a href="#sub_slip">sub slip</a></td></tr>
          <tr class="toc-level-1"><td class="toc-number">2</td><td class="toc-text"><a href="#Constants">Constants</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">2.1</td><td class="toc-text"><a href="#constant_Empty">constant Empty</a></td></tr>
        <tr class="toc-level-1"><td class="toc-number">3</td><td class="toc-text"><a href="#Type_Graph">Type Graph</a></td></tr>
  <tr class="toc-level-1"><td class="toc-number">4</td><td class="toc-text"><a href="#Routines_supplied_by_class_List">Routines supplied by class List</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">7.1</td><td class="toc-text"><a href="#(List)_method_ACCEPTS">(List) method ACCEPTS</a></td></tr>
                                                 <tr class="toc-level-2"><td class="toc-number">7.2</td><td class="toc-text"><a href="#(List)_routine_elems">(List) routine elems</a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">7.3</td><td class="toc-text"><a href="#(List)_routine_end">(List) routine end</a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">7.4</td><td class="toc-text"><a href="#(List)_routine_keys">(List) routine keys</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.5</td><td class="toc-text"><a href="#(List)_routine_values">(List) routine values</a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">7.6</td><td class="toc-text"><a href="#(List)_routine_kv">(List) routine kv</a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">7.7</td><td class="toc-text"><a href="#(List)_routine_pairs">(List) routine pairs</a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">7.8</td><td class="toc-text"><a href="#(List)_routine_antipairs">(List) routine antipairs</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.9</td><td class="toc-text"><a href="#(List)_routine_invert">(List) routine invert</a></td></tr>
                 <tr class="toc-level-2"><td class="toc-number">7.10</td><td class="toc-text"><a href="#(List)_routine_join">(List) routine join</a></td></tr>
                                 <tr class="toc-level-2"><td class="toc-number">7.11</td><td class="toc-text"><a href="#(List)_routine_map">(List) routine map</a></td></tr>
                                            <tr class="toc-level-2"><td class="toc-number">7.12</td><td class="toc-text"><a href="#(List)_method_flatmap">(List) method flatmap</a></td></tr>
                       <tr class="toc-level-2"><td class="toc-number">7.13</td><td class="toc-text"><a href="#(List)_method_gist">(List) method gist</a></td></tr>
                            <tr class="toc-level-2"><td class="toc-number">7.14</td><td class="toc-text"><a href="#(List)_routine_grep">(List) routine grep</a></td></tr>
                                                <tr class="toc-level-2"><td class="toc-number">7.15</td><td class="toc-text"><a href="#(List)_routine_first">(List) routine first</a></td></tr>
                                          <tr class="toc-level-2"><td class="toc-number">7.16</td><td class="toc-text"><a href="#(List)_method_head">(List) method head</a></td></tr>
                  <tr class="toc-level-2"><td class="toc-number">7.17</td><td class="toc-text"><a href="#(List)_method_tail">(List) method tail</a></td></tr>
                                 <tr class="toc-level-2"><td class="toc-number">7.18</td><td class="toc-text"><a href="#(List)_routine_categorize">(List) routine categorize</a></td></tr>
                    <tr class="toc-level-2"><td class="toc-number">7.19</td><td class="toc-text"><a href="#(List)_routine_classify">(List) routine classify</a></td></tr>
                         <tr class="toc-level-2"><td class="toc-number">7.20</td><td class="toc-text"><a href="#(List)_method_Bool">(List) method Bool</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.21</td><td class="toc-text"><a href="#(List)_method_Str">(List) method Str</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.22</td><td class="toc-text"><a href="#(List)_method_Int">(List) method Int</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.23</td><td class="toc-text"><a href="#(List)_method_Numeric">(List) method Numeric</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.24</td><td class="toc-text"><a href="#(List)_method_Capture">(List) method Capture</a></td></tr>
                           <tr class="toc-level-2"><td class="toc-number">7.25</td><td class="toc-text"><a href="#(List)_routine_pick">(List) routine pick</a></td></tr>
                     <tr class="toc-level-2"><td class="toc-number">7.26</td><td class="toc-text"><a href="#(List)_routine_roll">(List) routine roll</a></td></tr>
                 <tr class="toc-level-2"><td class="toc-number">7.27</td><td class="toc-text"><a href="#(List)_routine_eager">(List) routine eager</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.28</td><td class="toc-text"><a href="#(List)_routine_reverse">(List) routine reverse</a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">7.29</td><td class="toc-text"><a href="#(List)_routine_rotate">(List) routine rotate</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">7.30</td><td class="toc-text"><a href="#(List)_routine_sort">(List) routine sort</a></td></tr>
                                                   <tr class="toc-level-2"><td class="toc-number">7.31</td><td class="toc-text"><a href="#(List)_routine_reduce">(List) routine reduce</a></td></tr>
                                                                                                            <tr class="toc-level-2"><td class="toc-number">7.32</td><td class="toc-text"><a href="#(List)_routine_produce">(List) routine produce</a></td></tr>
                                           <tr class="toc-level-2"><td class="toc-number">7.33</td><td class="toc-text"><a href="#(List)_routine_combinations">(List) routine combinations</a></td></tr>
                                                       <tr class="toc-level-2"><td class="toc-number">7.34</td><td class="toc-text"><a href="#(List)_routine_permutations">(List) routine permutations</a></td></tr>
                           <tr class="toc-level-2"><td class="toc-number">7.35</td><td class="toc-text"><a href="#(List)_method_rotor">(List) method rotor</a></td></tr>
                             <tr class="toc-level-2"><td class="toc-number">7.36</td><td class="toc-text"><a href="#(List)_method_batch">(List) method batch</a></td></tr>
                <tr class="toc-level-2"><td class="toc-number">7.37</td><td class="toc-text"><a href="#(List)_routine_cross">(List) routine cross</a></td></tr>
                    <tr class="toc-level-2"><td class="toc-number">7.38</td><td class="toc-text"><a href="#(List)_routine_zip">(List) routine zip</a></td></tr>
                                      <tr class="toc-level-2"><td class="toc-number">7.39</td><td class="toc-text"><a href="#(List)_routine_roundrobin">(List) routine roundrobin</a></td></tr>
                 <tr class="toc-level-2"><td class="toc-number">7.40</td><td class="toc-text"><a href="#(List)_routine_sum">(List) routine sum</a></td></tr>
                     <tr class="toc-level-2"><td class="toc-number">7.41</td><td class="toc-text"><a href="#(List)_method_fmt">(List) method fmt</a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">7.42</td><td class="toc-text"><a href="#(List)_method_from">(List) method from</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">7.43</td><td class="toc-text"><a href="#(List)_method_to">(List) method to</a></td></tr>
                <tr class="toc-level-2"><td class="toc-number">7.44</td><td class="toc-text"><a href="#(List)_method_sink">(List) method sink</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.45</td><td class="toc-text"><a href="#(List)_method_Set">(List) method Set</a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">7.46</td><td class="toc-text"><a href="#(List)_infix_cmp">(List) infix cmp</a></td></tr>
                                   <tr class="toc-level-1"><td class="toc-number">5</td><td class="toc-text"><a href="#Routines_supplied_by_class_Cool">Routines supplied by class Cool</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">7.47</td><td class="toc-text"><a href="#(Cool)_routine_abs">(Cool) routine abs</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.48</td><td class="toc-text"><a href="#(Cool)_method_conj">(Cool) method conj</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.49</td><td class="toc-text"><a href="#(Cool)_routine_EVAL">(Cool) routine EVAL</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.50</td><td class="toc-text"><a href="#(Cool)_routine_sqrt">(Cool) routine sqrt</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.51</td><td class="toc-text"><a href="#(Cool)_method_sign">(Cool) method sign</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.52</td><td class="toc-text"><a href="#(Cool)_method_rand">(Cool) method rand</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.53</td><td class="toc-text"><a href="#(Cool)_routine_sin">(Cool) routine sin</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">7.54</td><td class="toc-text"><a href="#(Cool)_routine_asin">(Cool) routine asin</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.55</td><td class="toc-text"><a href="#(Cool)_routine_cos">(Cool) routine cos</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.56</td><td class="toc-text"><a href="#(Cool)_routine_acos">(Cool) routine acos</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.57</td><td class="toc-text"><a href="#(Cool)_routine_tan">(Cool) routine tan</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.58</td><td class="toc-text"><a href="#(Cool)_routine_atan">(Cool) routine atan</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.59</td><td class="toc-text"><a href="#(Cool)_routine_atan2">(Cool) routine atan2</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">7.60</td><td class="toc-text"><a href="#(Cool)_routine_sec">(Cool) routine sec</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.61</td><td class="toc-text"><a href="#(Cool)_routine_asec">(Cool) routine asec</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.62</td><td class="toc-text"><a href="#(Cool)_routine_cosec">(Cool) routine cosec</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.63</td><td class="toc-text"><a href="#(Cool)_routine_acosec">(Cool) routine acosec</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.64</td><td class="toc-text"><a href="#(Cool)_routine_cotan">(Cool) routine cotan</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.65</td><td class="toc-text"><a href="#(Cool)_routine_acotan">(Cool) routine acotan</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.66</td><td class="toc-text"><a href="#(Cool)_routine_sinh">(Cool) routine sinh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.67</td><td class="toc-text"><a href="#(Cool)_routine_asinh">(Cool) routine asinh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.68</td><td class="toc-text"><a href="#(Cool)_routine_cosh">(Cool) routine cosh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.69</td><td class="toc-text"><a href="#(Cool)_routine_acosh">(Cool) routine acosh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.70</td><td class="toc-text"><a href="#(Cool)_routine_tanh">(Cool) routine tanh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.71</td><td class="toc-text"><a href="#(Cool)_routine_atanh">(Cool) routine atanh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.72</td><td class="toc-text"><a href="#(Cool)_routine_sech">(Cool) routine sech</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.73</td><td class="toc-text"><a href="#(Cool)_routine_asech">(Cool) routine asech</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.74</td><td class="toc-text"><a href="#(Cool)_routine_cosech">(Cool) routine cosech</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.75</td><td class="toc-text"><a href="#(Cool)_routine_acosech">(Cool) routine acosech</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.76</td><td class="toc-text"><a href="#(Cool)_routine_cotanh">(Cool) routine cotanh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.77</td><td class="toc-text"><a href="#(Cool)_routine_acotanh">(Cool) routine acotanh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.78</td><td class="toc-text"><a href="#(Cool)_routine_cis">(Cool) routine cis</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">7.79</td><td class="toc-text"><a href="#(Cool)_routine_log">(Cool) routine log</a></td></tr>
                       <tr class="toc-level-2"><td class="toc-number">7.80</td><td class="toc-text"><a href="#(Cool)_routine_log10">(Cool) routine log10</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">7.81</td><td class="toc-text"><a href="#(Cool)_routine_log2">(Cool) routine log2</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">7.82</td><td class="toc-text"><a href="#(Cool)_routine_exp">(Cool) routine exp</a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">7.83</td><td class="toc-text"><a href="#(Cool)_method_unpolar">(Cool) method unpolar</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.84</td><td class="toc-text"><a href="#(Cool)_routine_round">(Cool) routine round</a></td></tr>
                              <tr class="toc-level-2"><td class="toc-number">7.85</td><td class="toc-text"><a href="#(Cool)_routine_floor">(Cool) routine floor</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.86</td><td class="toc-text"><a href="#(Cool)_method_fmt">(Cool) method fmt</a></td></tr>
                    <tr class="toc-level-2"><td class="toc-number">7.87</td><td class="toc-text"><a href="#(Cool)_routine_ceiling">(Cool) routine ceiling</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.88</td><td class="toc-text"><a href="#(Cool)_routine_truncate">(Cool) routine truncate</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.89</td><td class="toc-text"><a href="#(Cool)_routine_ord">(Cool) routine ord</a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">7.90</td><td class="toc-text"><a href="#(Cool)_method_path">(Cool) method path</a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">7.91</td><td class="toc-text"><a href="#(Cool)_routine_chr">(Cool) routine chr</a></td></tr>
                 <tr class="toc-level-2"><td class="toc-number">7.92</td><td class="toc-text"><a href="#(Cool)_routine_chars">(Cool) routine chars</a></td></tr>
                                <tr class="toc-level-2"><td class="toc-number">7.93</td><td class="toc-text"><a href="#(Cool)_routine_codes">(Cool) routine codes</a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">7.94</td><td class="toc-text"><a href="#(Cool)_routine_flip">(Cool) routine flip</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.95</td><td class="toc-text"><a href="#(Cool)_routine_trim">(Cool) routine trim</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.96</td><td class="toc-text"><a href="#(Cool)_routine_trim-leading">(Cool) routine trim-leading</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.97</td><td class="toc-text"><a href="#(Cool)_routine_trim-trailing">(Cool) routine trim-trailing</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.98</td><td class="toc-text"><a href="#(Cool)_routine_lc">(Cool) routine lc</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.99</td><td class="toc-text"><a href="#(Cool)_routine_uc">(Cool) routine uc</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.100</td><td class="toc-text"><a href="#(Cool)_routine_fc">(Cool) routine fc</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.101</td><td class="toc-text"><a href="#(Cool)_routine_tc">(Cool) routine tc</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.102</td><td class="toc-text"><a href="#(Cool)_routine_tclc">(Cool) routine tclc</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.103</td><td class="toc-text"><a href="#(Cool)_routine_wordcase">(Cool) routine wordcase</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">7.104</td><td class="toc-text"><a href="#(Cool)_routine_samecase">(Cool) routine samecase</a></td></tr>
                        <tr class="toc-level-2"><td class="toc-number">7.105</td><td class="toc-text"><a href="#(Cool)_routine_uniprop">(Cool) routine uniprop</a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">7.106</td><td class="toc-text"><a href="#(Cool)_sub_uniprops">(Cool) sub uniprops</a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">7.107</td><td class="toc-text"><a href="#(Cool)_routine_uniname">(Cool) routine uniname</a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">7.108</td><td class="toc-text"><a href="#(Cool)_routine_uninames">(Cool) routine uninames</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">7.109</td><td class="toc-text"><a href="#(Cool)_routine_unimatch">(Cool) routine unimatch</a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">7.110</td><td class="toc-text"><a href="#(Cool)_routine_chop">(Cool) routine chop</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.111</td><td class="toc-text"><a href="#(Cool)_routine_chomp">(Cool) routine chomp</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.112</td><td class="toc-text"><a href="#(Cool)_routine_substr">(Cool) routine substr</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">7.113</td><td class="toc-text"><a href="#(Cool)_routine_substr-rw">(Cool) routine substr-rw</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">7.114</td><td class="toc-text"><a href="#(Cool)_routine_ords">(Cool) routine ords</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">7.115</td><td class="toc-text"><a href="#(Cool)_routine_chrs">(Cool) routine chrs</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">7.116</td><td class="toc-text"><a href="#(Cool)_routine_split">(Cool) routine split</a></td></tr>
                                                           <tr class="toc-level-2"><td class="toc-number">7.117</td><td class="toc-text"><a href="#(Cool)_routine_lines">(Cool) routine lines</a></td></tr>
                                     <tr class="toc-level-2"><td class="toc-number">7.118</td><td class="toc-text"><a href="#(Cool)_method_words">(Cool) method words</a></td></tr>
                                 <tr class="toc-level-2"><td class="toc-number">7.119</td><td class="toc-text"><a href="#(Cool)_routine_comb">(Cool) routine comb</a></td></tr>
                                  <tr class="toc-level-2"><td class="toc-number">7.120</td><td class="toc-text"><a href="#(Cool)_method_contains">(Cool) method contains</a></td></tr>
                               <tr class="toc-level-2"><td class="toc-number">7.121</td><td class="toc-text"><a href="#(Cool)_routine_index">(Cool) routine index</a></td></tr>
                   <tr class="toc-level-2"><td class="toc-number">7.122</td><td class="toc-text"><a href="#(Cool)_routine_rindex">(Cool) routine rindex</a></td></tr>
                     <tr class="toc-level-2"><td class="toc-number">7.123</td><td class="toc-text"><a href="#(Cool)_method_match">(Cool) method match</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">7.124</td><td class="toc-text"><a href="#(Cool)_routine_roots">(Cool) routine roots</a></td></tr>
                                           <tr class="toc-level-2"><td class="toc-number">7.125</td><td class="toc-text"><a href="#(Cool)_method_match">(Cool) method match</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">7.126</td><td class="toc-text"><a href="#(Cool)_method_subst">(Cool) method subst</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">7.127</td><td class="toc-text"><a href="#(Cool)_method_trans">(Cool) method trans</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">7.128</td><td class="toc-text"><a href="#(Cool)_method_IO">(Cool) method IO</a></td></tr>
        <tr class="toc-level-1"><td class="toc-number">6</td><td class="toc-text"><a href="#Routines_supplied_by_role_Positional">Routines supplied by role Positional</a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">7.129</td><td class="toc-text"><a href="#(Positional)_method_of">(Positional) method of</a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">7.130</td><td class="toc-text"><a href="#(Positional)_method_elems">(Positional) method elems</a></td></tr>
   <tr class="toc-level-2"><td class="toc-number">7.131</td><td class="toc-text"><a href="#(Positional)_method_AT-POS">(Positional) method AT-POS</a></td></tr>
   <tr class="toc-level-2"><td class="toc-number">7.132</td><td class="toc-text"><a href="#(Positional)_method_EXISTS-POS">(Positional) method EXISTS-POS</a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">7.133</td><td class="toc-text"><a href="#(Positional)_method_STORE">(Positional) method STORE</a></td></tr>
           <tr class="toc-level-1"><td class="toc-number">7</td><td class="toc-text"><a href="#Routines_supplied_by_role_Iterable">Routines supplied by role Iterable</a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">7.134</td><td class="toc-text"><a href="#(Iterable)_method_iterator">(Iterable) method iterator</a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">7.135</td><td class="toc-text"><a href="#(Iterable)_method_flat">(Iterable) method flat</a></td></tr>
                               <tr class="toc-level-2"><td class="toc-number">7.136</td><td class="toc-text"><a href="#(Iterable)_method_lazy">(Iterable) method lazy</a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">7.137</td><td class="toc-text"><a href="#(Iterable)_method_hyper">(Iterable) method hyper</a></td></tr>
           <tr class="toc-level-3"><td class="toc-number">7.137.1</td><td class="toc-text"><a href="#Options_degree_and_batch">Options degree and batch</a></td></tr>
                 <tr class="toc-level-2"><td class="toc-number">7.138</td><td class="toc-text"><a href="#(Iterable)_method_race">(Iterable) method race</a></td></tr>
                    
</table>
</nav>

        <div class="pod-body ">
            <pre class="pod-block-code">class Slip is List {}</pre>
<p>A <code>Slip</code> is a <a href="/Documentable/integration-test/type/List">List</a> that automatically flattens into an outer List (or other list-like container or iterable).</p>
<p>For example it allows you to write a <a href="/Documentable/integration-test/routine/map">map</a> that produces more than one value into the result without nesting:</p>
<pre class="pod-block-code">say &lt;a b c&gt;.map({ ($_, $_.uc).Slip }).join(&#39;|&#39;);        # OUTPUT: «a|A|b|B|c|C␤»
</pre>
<p>In contrast, when returning an ordinary List, the resulting list is nested:</p>
<pre class="pod-block-code">say &lt;a b c&gt;.map({ $_, $_.uc }).join(&#39;|&#39;);               # OUTPUT: «a A|b B|c C␤»
</pre>
<p>To create a <code>Slip</code>, either coerce another list-like type to it by calling the <code>Slip</code> method, or use the <code>slip</code> subroutine:</p>
<pre class="pod-block-code"># This says &quot;1&quot; and then says &quot;2&quot;, rather than saying &quot;(1 2)&quot;
.say for gather {
    take slip(1, 2);
}</pre>
<p>A <code>Slip</code> may also be created by using the <code>prefix:&lt;|&gt;</code> operator. This differs from the <code>slip</code> subroutine in both precedence and treatment of single arguments. In fact, <code>prefix:&lt;|&gt;</code> only takes a single argument, so in that way, it behaves closer to the <code>.Slip</code> method than the <code>slip</code> subroutine.</p>
<pre class="pod-block-code">my $l = (1, 2, 3);
say (1, slip 2, 3).raku;  # says (1, 2, 3)      , slips 2, 3 into (1, …)
say (0, slip $l).raku;    # says (0, $(1, 2, 3)), $l does not break apart
say (0, $l.Slip).raku;    # says (0, 1, 2, 3)   , slips from $l into (0, …)
say (|$l).raku;           # says slip(1, 2, 3)  , breaks apart $l
say (0, (|$l, 4), 5);     # says (0 (1 2 3 4) 5), slips from $l into (…, 4)
say (0, ($l.Slip, 4), 5); # says (0 (1 2 3 4) 5), slips from $l into (…, 4)
say (0, (slip $l, 4), 5); # says (0 (1 2 3) 4 5), slips ($l, 4) into (0, …, 5)
say (0, ($l, 4).Slip, 5); # says (0 (1 2 3) 4 5), slips ($l, 4) into (0, …, 5)
</pre>
<p>Loops that do not want to produce a value for an iteration use <code>Slips</code>, rather than empty <code>List</code>s to do so, as do <code>if</code> statements that do not run their blocks.</p>
<p>Please note that <code>prefix:&lt;|&gt;</code> will also apply parameters in a slippy manner to a routine call. It does not forward a <code>Slip</code> to the called routine, that includes <code>return</code> and <code>take</code>.</p>
<pre class="pod-block-code">my \l = gather for 1..10 -&gt; $a, $b { take |($a, $b) }; say l.raku;
# OUTPUT: «((1, 2), (3, 4), (5, 6), (7, 8), (9, 10)).Seq␤»
my \m= gather for 1..10 -&gt; $a, $b { take ($a, $b).Slip }; say m.raku;
# OUTPUT: «(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).Seq␤»</pre>
<h1 id="Methods"><a class="u" href="#___top" title="go to top of document">Methods</a></h1>
<h2 id="method_List"><a class="u" href="#___top" title="go to top of document">method List</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method List(Slip:D: --&gt; List:D)</pre>
<p>Turns it into a list.</p>
<h2 id="sub_slip"><a class="u" href="#___top" title="go to top of document">sub slip</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub slip(--&gt; Empty)
multi sub slip(@args --&gt; Slip:D)
multi sub slip(+args --&gt; Slip:D)</pre>
<p>Creates a <a href="/Documentable/integration-test/type/Slip">Slip</a> from its arguments by calling <a href="/Documentable/integration-test/routine/Slip"><code>.Slip</code></a> on the object formed by them. Returns <a href="/Documentable/integration-test/type/Slip#index-entry-Empty-Empty"><code>Empty</code></a> if called with void arguments.</p>
<h1 id="Constants"><a class="u" href="#___top" title="go to top of document">Constants</a></h1>
<h2 id="constant_Empty"><a class="u" href="#___top" title="go to top of document">constant Empty</a></h2>
<p><code>Empty</code> is a <code>Slip</code> of the empty <code>List</code>.</p>
<pre class="pod-block-code">say &quot;&quot;.comb ~~ Empty;
# OUTPUT: «True␤»</pre>
<h1 id="Type_Graph"><a class="u" href="#___top" title="go to top of document">Type Graph</a></h1>
<figure>
  <figcaption>Type relations for <code>Slip</code></figcaption>
  <svg width="325pt" height="332pt"
 viewBox="0.00 0.00 324.59 332.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 328)">
<title>perl6&#45;type&#45;graph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-328 320.59,-328 320.59,4 -4,4"/>
<!-- Slip -->
<g id="node1" class="node">
<title>Slip</title>
<g id="a_node1"><a xlink:href="/type/Slip" xlink:title="Slip">
<ellipse fill="none" stroke="#000000" cx="138.55" cy="-18" rx="30.59" ry="18"/>
<text text-anchor="middle" x="138.55" y="-14.3" font-family="FreeSans" font-size="14.00" fill="#000000">Slip</text>
</a>
</g>
</g>
<!-- List -->
<g id="node7" class="node">
<title>List</title>
<g id="a_node7"><a xlink:href="/type/List" xlink:title="List">
<ellipse fill="none" stroke="#000000" cx="138.55" cy="-90" rx="30.59" ry="18"/>
<text text-anchor="middle" x="138.55" y="-86.3" font-family="FreeSans" font-size="14.00" fill="#000000">List</text>
</a>
</g>
</g>
<!-- Slip&#45;&gt;List -->
<g id="edge1" class="edge">
<title>Slip&#45;&gt;List</title>
<path fill="none" stroke="#000000" d="M138.55,-36.3C138.55,-44.02 138.55,-53.29 138.55,-61.89"/>
<polygon fill="#000000" stroke="#000000" points="135.05,-61.9 138.55,-71.9 142.05,-61.9 135.05,-61.9"/>
</g>
<!-- Mu -->
<g id="node2" class="node">
<title>Mu</title>
<g id="a_node2"><a xlink:href="/type/Mu" xlink:title="Mu">
<ellipse fill="none" stroke="#000000" cx="30.55" cy="-306" rx="27" ry="18"/>
<text text-anchor="middle" x="30.55" y="-302.3" font-family="FreeSans" font-size="14.00" fill="#000000">Mu</text>
</a>
</g>
</g>
<!-- Any -->
<g id="node3" class="node">
<title>Any</title>
<g id="a_node3"><a xlink:href="/type/Any" xlink:title="Any">
<ellipse fill="none" stroke="#000000" cx="30.55" cy="-234" rx="27" ry="18"/>
<text text-anchor="middle" x="30.55" y="-230.3" font-family="FreeSans" font-size="14.00" fill="#000000">Any</text>
</a>
</g>
</g>
<!-- Any&#45;&gt;Mu -->
<g id="edge2" class="edge">
<title>Any&#45;&gt;Mu</title>
<path fill="none" stroke="#000000" d="M30.55,-252.3C30.55,-260.02 30.55,-269.29 30.55,-277.89"/>
<polygon fill="#000000" stroke="#000000" points="27.05,-277.9 30.55,-287.9 34.05,-277.9 27.05,-277.9"/>
</g>
<!-- Cool -->
<g id="node4" class="node">
<title>Cool</title>
<g id="a_node4"><a xlink:href="/type/Cool" xlink:title="Cool">
<ellipse fill="none" stroke="#000000" cx="30.55" cy="-162" rx="30.59" ry="18"/>
<text text-anchor="middle" x="30.55" y="-158.3" font-family="FreeSans" font-size="14.00" fill="#000000">Cool</text>
</a>
</g>
</g>
<!-- Cool&#45;&gt;Any -->
<g id="edge3" class="edge">
<title>Cool&#45;&gt;Any</title>
<path fill="none" stroke="#000000" d="M30.55,-180.3C30.55,-188.02 30.55,-197.29 30.55,-205.89"/>
<polygon fill="#000000" stroke="#000000" points="27.05,-205.9 30.55,-215.9 34.05,-205.9 27.05,-205.9"/>
</g>
<!-- Positional -->
<g id="node5" class="node">
<title>Positional</title>
<g id="a_node5"><a xlink:href="/type/Positional" xlink:title="Positional">
<ellipse fill="none" stroke="#6666ff" cx="138.55" cy="-162" rx="59.59" ry="18"/>
<text text-anchor="middle" x="138.55" y="-158.3" font-family="FreeSans" font-size="14.00" fill="#6666ff">Positional</text>
</a>
</g>
</g>
<!-- Iterable -->
<g id="node6" class="node">
<title>Iterable</title>
<g id="a_node6"><a xlink:href="/type/Iterable" xlink:title="Iterable">
<ellipse fill="none" stroke="#6666ff" cx="266.55" cy="-162" rx="50.09" ry="18"/>
<text text-anchor="middle" x="266.55" y="-158.3" font-family="FreeSans" font-size="14.00" fill="#6666ff">Iterable</text>
</a>
</g>
</g>
<!-- List&#45;&gt;Cool -->
<g id="edge4" class="edge">
<title>List&#45;&gt;Cool</title>
<path fill="none" stroke="#000000" d="M118.74,-103.84C102.02,-114.67 77.88,-130.32 59.08,-142.51"/>
<polygon fill="#000000" stroke="#000000" points="57.08,-139.63 50.6,-148.01 60.89,-145.5 57.08,-139.63"/>
</g>
<!-- List&#45;&gt;Positional -->
<g id="edge5" class="edge">
<title>List&#45;&gt;Positional</title>
<path fill="none" stroke="#6666ff" d="M138.55,-108.3C138.55,-116.02 138.55,-125.29 138.55,-133.89"/>
<polygon fill="#6666ff" stroke="#6666ff" points="135.05,-133.9 138.55,-143.9 142.05,-133.9 135.05,-133.9"/>
</g>
<!-- List&#45;&gt;Iterable -->
<g id="edge6" class="edge">
<title>List&#45;&gt;Iterable</title>
<path fill="none" stroke="#6666ff" d="M160.26,-102.87C179.69,-113.5 208.54,-129.28 231.28,-141.72"/>
<polygon fill="#6666ff" stroke="#6666ff" points="229.84,-144.92 240.29,-146.64 233.2,-138.77 229.84,-144.92"/>
</g>
</g>
</svg>

  <p class="fallback">
    <a
      rel="alternate"
      href="/images/type-graph-Slip.svg"
      type="image/svg+xml"
      >Expand above chart</a
    >
  </p>
</figure>
<h1 id="Routines_supplied_by_class_List"><a class="u" href="#___top" title="go to top of document">Routines supplied by class List</a></h1>
<p>Slip inherits from class <a href="/Documentable/integration-test/type/List">List</a>, which provides the following routines:</p>
<h2 id="(List)_method_ACCEPTS"><a href="/Documentable/integration-test/type/List#method_ACCEPTS">(List) method ACCEPTS</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method ACCEPTS(List:D: $topic)</pre>
<p>If <code>$topic</code> is an <a href="/Documentable/integration-test/type/Iterable">Iterable</a>, returns <code>True</code> or <code>False</code> based on whether the contents of the two <code>Iterables</code> match. A <a href="/Documentable/integration-test/type/Whatever">Whatever</a> element in the invocant matches anything in the corresponding position of the <code>$topic</code> <code>Iterable</code>. A <a href="/Documentable/integration-test/type/HyperWhatever">HyperWhatever</a> matches any number of any elements, including no elements:</p>
<pre class="pod-block-code">say (1, 2, 3)       ~~ (1,  *, 3);  # OUTPUT: «True␤»
say (1, 2, 3)       ~~ (9,  *, 5);  # OUTPUT: «False␤»
say (1, 2, 3)       ~~ (   **, 3);  # OUTPUT: «True␤»
say (1, 2, 3)       ~~ (   **, 5);  # OUTPUT: «False␤»
say (1, 3)          ~~ (1, **, 3); # OUTPUT: «True␤»
say (1, 2, 4, 5, 3) ~~ (1, **, 3); # OUTPUT: «True␤»
say (1, 2, 4, 5, 6) ~~ (1, **, 5); # OUTPUT: «False␤»
say (1, 2, 4, 5, 6) ~~ (   **   ); # OUTPUT: «True␤»
say ()              ~~ (   **   ); # OUTPUT: «True␤»</pre>
<p>In addition, returns <code>False</code> if either the invocant or <code>$topic</code> <a href="/Documentable/integration-test/routine/is-lazy">is a lazy</a> <code>Iterable</code>, unless <code>$topic</code> is the same object as the invocant, in which case <code>True</code> is returned.</p>
<p>If <code>$topic</code> is <em>not</em> an <a href="/Documentable/integration-test/type/Iterable">Iterable</a>, returns the invocant if the invocant has no elements or its first element is a <a href="/Documentable/integration-test/type/Match">Match</a> object (this behavior powers <code>m:g//</code> smartmatch), or <code>False</code> otherwise.</p>
<h2 id="(List)_routine_elems"><a href="/Documentable/integration-test/type/List#routine_elems">(List) routine elems</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub    elems($list --&gt; Int:D)
method elems(List:D: --&gt; Int:D)</pre>
<p>Returns the number of elements in the list.</p>
<pre class="pod-block-code">say (1,2,3,4).elems; # OUTPUT: «4␤»</pre>
<h2 id="(List)_routine_end"><a href="/Documentable/integration-test/type/List#routine_end">(List) routine end</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub    end($list --&gt; Int:D)
method end(List:D: --&gt; Int:D)</pre>
<p>Returns the index of the last element.</p>
<pre class="pod-block-code">say (1,2,3,4).end; # OUTPUT: «3␤»</pre>
<h2 id="(List)_routine_keys"><a href="/Documentable/integration-test/type/List#routine_keys">(List) routine keys</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub    keys($list --&gt; Seq:D)
method keys(List:D: --&gt; Seq:D)</pre>
<p>Returns a sequence of indexes into the list (e.g., <code>0..(@list.elems-1)</code>).</p>
<pre class="pod-block-code">say (1,2,3,4).keys; # OUTPUT: «0..3␤»</pre>
<h2 id="(List)_routine_values"><a href="/Documentable/integration-test/type/List#routine_values">(List) routine values</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub    values($list --&gt; Seq:D)
method values(List:D: --&gt; Seq:D)</pre>
<p>Returns a sequence of the list elements, in order.</p>
<pre class="pod-block-code">say (1,2,3,4).^name;        # OUTPUT: «List␤»
say (1,2,3,4).values.^name; # OUTPUT: «Seq␤»</pre>
<h2 id="(List)_routine_kv"><a href="/Documentable/integration-test/type/List#routine_kv">(List) routine kv</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub    kv($list --&gt; Seq:D)
method kv(List:D: --&gt; Seq:D)</pre>
<p>Returns an interleaved sequence of indexes and values. For example</p>
<pre class="pod-block-code">&lt;a b c&gt;.kv; # (0 a 1 b 2 c)</pre>
<h2 id="(List)_routine_pairs"><a href="/Documentable/integration-test/type/List#routine_pairs">(List) routine pairs</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub    pairs($list --&gt; Seq:D)
method pairs(List:D: --&gt; Seq:D)</pre>
<p>Returns a sequence of pairs, with the indexes as keys and the list values as values.</p>
<pre class="pod-block-code">&lt;a b c&gt;.pairs   # (0 =&gt; a 1 =&gt; b 2 =&gt; c)</pre>
<h2 id="(List)_routine_antipairs"><a href="/Documentable/integration-test/type/List#routine_antipairs">(List) routine antipairs</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method antipairs(List:D: --&gt; Seq:D)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Seq">Seq</a> of pairs, with the values as keys and the indexes as values, i.e. the direct opposite to <a href="/Documentable/integration-test/type/List#routine_pairs">pairs</a>.</p>
<pre class="pod-block-code">say &lt;a b c&gt;.antipairs;  # OUTPUT: «(a =&gt; 0 b =&gt; 1 c =&gt; 2)␤»</pre>
<h2 id="(List)_routine_invert"><a href="/Documentable/integration-test/type/List#routine_invert">(List) routine invert</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method invert(List:D: --&gt; Seq:D)</pre>
<p>Assumes every element of the List is a <code>Pair</code>. Returns all elements as a <a href="/Documentable/integration-test/type/Seq">Seq</a> of <code>Pair</code>s where the keys and values have been exchanged. If the value of a <code>Pair</code> is an <code>Iterable</code>, then it will expand the values of that <code>Iterable</code> into separate pairs.</p>
<pre class="pod-block-code">my $l = List.new(&#39;a&#39; =&gt; (2, 3), &#39;b&#39; =&gt; 17);
say $l.invert;   # OUTPUT: «(2 =&gt; a 3 =&gt; a 17 =&gt; b)␤»</pre>
<h2 id="(List)_routine_join"><a href="/Documentable/integration-test/type/List#routine_join">(List) routine join</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub    join($separator, *@list)
method join(List:D: $separator = &quot;&quot;)</pre>
<p>Treats the elements of the list as strings by calling <a href="/Documentable/integration-test/type/Any#routine_Str"><code>.Str</code></a> on each of them, interleaves them with <code>$separator</code> and concatenates everything into a single string. Note that you can omit the <code>$separator</code> if you use the method syntax.</p>
<p>Example:</p>
<pre class="pod-block-code">join &#39;, &#39;, &lt;a b c&gt;;             # OUTPUT: «a, b, c»</pre>
<p>Note that the method form does not flatten sublists:</p>
<pre class="pod-block-code">say (1, &lt;a b c&gt;).join(&#39;|&#39;);     # OUTPUT: «1|a b c␤»</pre>
<p>The method form also allows you to omit the separator:</p>
<pre class="pod-block-code">say &lt;a b c&gt;.join;               # OUTPUT: «abc␤»</pre>
<p>But it behaves slurpily, flattening all arguments after the first into a single list:</p>
<pre class="pod-block-code">say join(&#39;|&#39;, 3, &#39;þ&#39;, 1+4i);    # OUTPUT: «3|þ|1+4i␤»
say join &#39;, &#39;, &lt;a b c&gt;, &#39;d&#39;, &#39;e&#39; , &#39;f&#39;; # OUTPUT: «a, b, c, d, e, f␤»</pre>
<p>In this case, the first list <code>&lt;a b c</code> is <em>slurped</em> and flattened, unlike what happens when <code>join</code> is invoked as a method.</p>
<p>If one of the elements of the list happens to be a <code>Junction</code>, then <code>join</code> will also return a <code>Junction</code> with concatenation done as much as possible:</p>
<pre class="pod-block-code">say (&quot;a&quot;|&quot;b&quot;,&quot;c&quot;,&quot;d&quot;).join;     # OUTPUT: «any(acd,bcd)␤»</pre>
<h2 id="(List)_routine_map"><a href="/Documentable/integration-test/type/List#routine_map">(List) routine map</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method map(Hash:D \hash)
multi method map(Iterable:D \iterable)
multi method map(|c)
multi method map(\SELF: &amp;block;; :$label, :$item)
multi sub map(&amp;code, +values)</pre>
<p>Examples applied to lists are included here for the purpose of illustration.</p>
<p>For a list, it invokes <code>&amp;code</code> for each element and gathers the return values in a sequence and returns it. This happens lazily, i.e. <code>&amp;code</code> is only invoked when the return values are accessed.Examples:</p>
<pre class="pod-block-code">say (&#39;hello&#39;, 1, 22/7, 42, &#39;world&#39;).map: { .^name } # OUTPUT: «(Str Int Rat Int Str)␤»
say map *.Str.chars, &#39;hello&#39;, 1, 22/7, 42, &#39;world&#39;; # OUTPUT: «(5 1 8 2 5)␤»
</pre>
<p><code>map</code> inspects the arity of the code object, and tries to pass as many arguments to it as expected:</p>
<pre class="pod-block-code">sub b($a, $b) { &quot;$a before $b&quot; };
say &lt;a b x y&gt;.map(&amp;b).join(&#39;, &#39;);   # OUTPUT: «a before b, x before y␤»</pre>
<p>iterates the list two items at a time.</p>
<p>Note that <code>map</code> does not flatten embedded lists and arrays, so</p>
<pre class="pod-block-code">((1, 2), &lt;a b&gt;).map({ .join(&#39;,&#39;)})</pre>
<p>passes <code>(1, 2)</code> and <code>&lt;a b&gt; </code> in turn to the block, leading to a total of two iterations and the result sequence <code>&quot;1,2&quot;, &quot;a,b&quot;</code>. See <a href="/Documentable/integration-test/type/List#method_flatmap">method flatmap</a> for an alternative that flattens.</p>
<p>If <code>&amp;code</code> is a <a href="/Documentable/integration-test/type/Block">Block</a> loop phasers will be executed and loop control statements will be treated as in loop control flow. Please note that <code>return</code> is executed in the context of its definition. It is not the return statement of the block but the surrounding Routine. Using a <a href="/Documentable/integration-test/type/Routine">Routine</a> will also handle loop control statements and loop phasers. Any <code>Routine</code> specific control statement or phaser will be handled in the context of that <code>Routine</code>.</p>
<pre class="pod-block-code">sub s {
    my &amp;loop-block = {
        return # return from sub s
    };
    say &#39;hi&#39;;
    (1..3).map: &amp;loop-block;
    say &#39;oi‽&#39; # dead code
};
s
# OUTPUT: «hi»</pre>
<h2 id="(List)_method_flatmap"><a href="/Documentable/integration-test/type/List#method_flatmap">(List) method flatmap</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method flatmap(List:D: &amp;code --&gt; Seq:D)</pre>
<p>Like <a href="/Documentable/integration-test/type/Any#method_map"><code>map</code></a> iterates over the elements of the invocant list, feeding each element in turn to the code reference, and assembling the return values from these invocations in a result list.</p>
<p>The use of <code>flatmap</code> <strong>is strongly discouraged</strong>. Instead of <code>.flatmap( )</code>, please use <code>.map( ).flat</code> as it is clear when the <code>.flat</code> is called and is not confusing like <code>.flatmap</code>.</p>
<p>Unlike <code>map</code> it flattens non-itemized lists and arrays, so</p>
<pre class="pod-block-code">## flatmap
my @list = (&#39;first1&#39;, (&#39;second2&#39;, (&#39;third3&#39;, &#39;third4&#39;), &#39;second5&#39;), &#39;first6&#39;);
say @list.flatmap({.reverse}).raku;
# OUTPUT «(&quot;first1&quot;, &quot;second5&quot;, &quot;third3&quot;, &quot;third4&quot;, &quot;second2&quot;, &quot;first6&quot;).Seq␤»
## map
say @list.map({&quot;$_ was a {.^name}&quot;}).raku;
# OUTPUT «(&quot;first1 was a Str&quot;, &quot;second2 third3 third4 second5 was a List&quot;, &quot;first6 was a Str&quot;).Seq␤»
## .map .flat has the same output as .flatmap
say @list.map({.reverse}).flat.raku;
# OUTPUT «(&quot;first1&quot;, &quot;second5&quot;, &quot;third3&quot;, &quot;third4&quot;, &quot;second2&quot;, &quot;first6&quot;).Seq␤»</pre>
<h2 id="(List)_method_gist"><a href="/Documentable/integration-test/type/List#method_gist">(List) method gist</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method gist(List:D: --&gt; Str:D)</pre>
<p>Returns the string containing the parenthesized &quot;gist&quot; of the List, <strong>listing up to the first 100</strong> elements, separated by space, appending an ellipsis if the List has more than 100 elements. If List <a href="/Documentable/integration-test/routine/is-lazy"><code>is-lazy</code></a>, returns string <code>&#39;(...)&#39;</code></p>
<pre class="pod-block-code">put (1, 2, 3).gist;   # OUTPUT «(1 2 3)␤»
put (1..∞).List.gist; # OUTPUT «(...)␤»

put (1..200).List.gist;
# OUTPUT:
# (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
# 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49
# 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72
# 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95
# 96 97 98 99 100 ...)
</pre>
<h2 id="(List)_routine_grep"><a href="/Documentable/integration-test/type/List#routine_grep">(List) routine grep</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub    grep(Mu $matcher, *@elems, :$k, :$kv, :$p, :$v --&gt; Seq:D)
method grep(List:D:  Mu $matcher, :$k, :$kv, :$p, :$v --&gt; Seq:D)</pre>
<p>Returns a sequence of elements against which <code>$matcher</code> smartmatches. The elements are returned in the order in which they appear in the original list.</p>
<p>Examples:</p>
<pre class="pod-block-code">say (&#39;hello&#39;, 1, 22/7, 42, &#39;world&#39;).grep: Int;              # OUTPUT: «(1 42)␤»
say grep { .Str.chars &gt; 3 }, &#39;hello&#39;, 1, 22/7, 42, &#39;world&#39;; # OUTPUT: «(hello 3.142857 world)␤»</pre>
<p>Note that if you want to grep for elements that do not match, you can use a <code>none</code>-<a href="/Documentable/integration-test/type/Junction">Junction</a>:</p>
<pre class="pod-block-code">say &lt;a b 6 d 8 0&gt;.grep(none Int);           # OUTPUT: «(a b d)␤»
say &lt;a b c d e f&gt;.grep(none /&lt;[aeiou]&gt;/);   # OUTPUT: «(b c d f)␤»</pre>
<p>Another option to grep for elements that do not match a regex is to use a block:</p>
<pre class="pod-block-code">say &lt;a b c d e f&gt;.grep({! /&lt;[aeiou]&gt;/})     # OUTPUT: «(b c d f)␤»</pre>
<p>The reason the example above works is because a regex in boolean context applies itself to <code>$_</code>. In this case, <code>!</code> boolifies the <code>/&lt;[aeiou]&gt;/</code> regex and negates the result. Smartmatching against a <a href="/Documentable/integration-test/type/Callable">Callable</a> (in this case a <a href="/Documentable/integration-test/type/Block">Block</a>) returns the value returned from that callable, so the boolified result of a regex is then used to decide whether the current value should be kept in the result of a grep.</p>
<p>The optional named parameters <code>:k</code>, <code>:kv</code>, <code>:p</code>, <code>:v</code> provide the same functionality as on slices:</p>
<li><p>k</p>
</li>
<p>Only return the index values of the matching elements in order.</p>
<li><p>kv</p>
</li>
<p>Return both the index and matched elements in order.</p>
<li><p>p</p>
</li>
<p>Return the index and the matched element as a <code>Pair</code>, in order.</p>
<li><p>v</p>
</li>
<p>Only return the matched elements (same as not specifying any named parameter at all).</p>
<p>Examples:</p>
<pre class="pod-block-code">say (&#39;hello&#39;, 1, 22/7, 42, &#39;world&#39;).grep: Int, :k;
# OUTPUT: «(1 3)␤»
say grep { .Str.chars &gt; 3 }, :kv, &#39;hello&#39;, 1, 22/7, 42, &#39;world&#39;;
# OUTPUT: «(0 hello 2 3.142857 4 world)␤»
say grep { .Str.chars &gt; 3 }, :p, &#39;hello&#39;, 1, 22/7, 42, &#39;world&#39;;
# OUTPUT: «(0 =&gt; hello 2 =&gt; 3.142857 4 =&gt; world)␤»</pre>
<h2 id="(List)_routine_first"><a href="/Documentable/integration-test/type/List#routine_first">(List) routine first</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub    first(Mu $matcher, *@elems, :$k, :$kv, :$p, :$end)
method first(List:D:  Mu $matcher?, :$k, :$kv, :$p, :$end)</pre>
<p>Returns the first item of the list which smartmatches against <code>$matcher</code>, returns <code>Nil</code> when no values match. The optional named parameter <code>:end</code> indicates that the search should be from the <strong>end</strong> of the list, rather than from the start.</p>
<p>Examples:</p>
<pre class="pod-block-code">say (1, 22/7, 42, 300).first: * &gt; 5;                  # OUTPUT: «42␤»
say (1, 22/7, 42, 300).first: * &gt; 5, :end;            # OUTPUT: «300␤»
say (&#39;hello&#39;, 1, 22/7, 42, &#39;world&#39;).first: Complex;   # OUTPUT: «Nil␤»</pre>
<p>The optional named parameters <code>:k</code>, <code>:kv</code>, <code>:p</code> provide the same functionality as on slices:</p>
<li><p>k</p>
</li>
<p>Return the index value of the matching element. Index is always counted from the beginning of the list, regardless of whether the <code>:end</code> named parameter is specified or not.</p>
<li><p>kv</p>
</li>
<p>Return both the index and matched element.</p>
<li><p>p</p>
</li>
<p>Return the index and the matched element as a <code>Pair</code>.</p>
<p>Examples:</p>
<pre class="pod-block-code">say (1, 22/7, 42, 300).first: * &gt; 5, :k;        # OUTPUT: «2␤»
say (1, 22/7, 42, 300).first: * &gt; 5, :p;        # OUTPUT: «2 =&gt; 42␤»
say (1, 22/7, 42, 300).first: * &gt; 5, :kv, :end; # OUTPUT: «(3 300)␤»</pre>
<p>In method form, the <code>$matcher</code> can be omitted, in which case the first available item (or last if <code>:end</code> is set) will be returned. See also <a href="/Documentable/integration-test/routine/head"><code>head</code></a> and <a href="/Documentable/integration-test/routine/tail"><code>tail</code></a> methods.</p>
<h2 id="(List)_method_head"><a href="/Documentable/integration-test/type/List#method_head">(List) method head</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method head(Any:D:) is raw
multi method head(Any:D: Callable:D $w)
multi method head(Any:D: $n)</pre>
<p>This method is directly inherited from <a href="/Documentable/integration-test/type/Any">Any</a>, and it returns the <strong>first</strong> <code>$n</code> items of the list, an empty list if <code>$n</code> &lt;= 0, or the first element with no argument. The version that takes a <code>Callable</code> uses a <code>WhateverCode</code> to specify all elements, starting from the first, but the last ones.</p>
<p>Examples:</p>
<pre class="pod-block-code">say &lt;a b c d e&gt;.head ;     # OUTPUT: «a␤»
say &lt;a b c d e&gt;.head(2);   # OUTPUT: «(a b)␤»
say &lt;a b c d e&gt;.head(*-3); # OUTPUT: «(a b)␤»</pre>
<h2 id="(List)_method_tail"><a href="/Documentable/integration-test/type/List#method_tail">(List) method tail</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method tail(List:D:)
multi method tail(List:D: $n --&gt; Seq:D)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Seq">Seq</a> containing the <strong>last</strong> <code>$n</code> items of the list. Returns an empty <code>Seq</code> if <code>$n</code> &lt;= 0. Defaults to the last element if no argument is specified. Throws an exception if the list is lazy.</p>
<p>Examples:</p>
<pre class="pod-block-code">say &lt;a b c d e&gt;.tail(*-3);# OUTPUT: «(d e)␤»
say &lt;a b c d e&gt;.tail(2);  # OUTPUT: «(d e)␤»
say &lt;a b c d e&gt;.tail;     # OUTPUT: «e␤»
</pre>
<p>In the first case, <code>$n</code> is taking the shape of a <code>WhateverCode</code> to indicate the number of elements from the beginning that will be excluded. <code>$n</code> can be either a Callable, in which case it will be called with the value <code>0</code>, or anything else that can be converted to a number, in which case it will use that as the number of elements in the output <code>Seq</code>.</p>
<pre class="pod-block-code">say &lt;a b c d e&gt;.tail( { $_ - 2 } ); # OUTPUT: «(c d e)␤»</pre>
<h2 id="(List)_routine_categorize"><a href="/Documentable/integration-test/type/List#routine_categorize">(List) routine categorize</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method categorize()
multi method categorize(Whatever)
multi method categorize($test, :$into!, :&amp;as)
multi method categorize($test, :&amp;as)
multi sub categorize($test, +items, :$into!, *%named )
multi sub categorize($test, +items, *%named )</pre>
<p>These methods are directly inherited from <code>Any</code>; see <a href="/Documentable/integration-test/routine/categorize#(Any)_method_categorize"><code>Any.list</code></a> for more examples.</p>
<p>This routine transforms a list of values into a hash representing the categorizations of those values according to <code>$test</code>, which is called once for every element in the list; each hash key represents one possible categorization for one or more of the incoming list values, and the corresponding hash value contains an array of those list values categorized by the <code>$test</code>, acting like a mapper, into the category of the associated key.</p>
<p>Note that, unlike <a href="/Documentable/integration-test/routine/classify">classify</a>, which assumes that the return value of the mapper is a single value, <code>categorize</code> always assumes that the return value of the mapper is a list of categories that are appropriate to the current value.</p>
<p>Example:</p>
<pre class="pod-block-code">sub mapper(Int $i) returns List {
    $i %% 2 ?? &#39;even&#39; !! &#39;odd&#39;,
    $i.is-prime ?? &#39;prime&#39; !! &#39;not prime&#39;
}
say categorize &amp;mapper, (1, 7, 6, 3, 2);  # OUTPUT: «{even =&gt; [6 2], not prime =&gt; [1 6],
                                          #          odd =&gt; [1 7 3], prime =&gt; [7 3 2]}␤»</pre>
<h2 id="(List)_routine_classify"><a href="/Documentable/integration-test/type/List#routine_classify">(List) routine classify</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method classify($test, :$into!, :&amp;as)
multi method classify($test, :&amp;as)
multi sub classify($test, +items, :$into!, *%named )
multi sub classify($test, +items, *%named )</pre>
<p>Transforms a list of values into a hash representing the classification of those values; each hash key represents the classification for one or more of the incoming list values, and the corresponding hash value contains an array of those list values classified into the category of the associated key. <code>$test</code> will be an expression that will produce the hash keys according to which the elements are going to be classified.</p>
<p>Example:</p>
<pre class="pod-block-code">say classify { $_ %% 2 ?? &#39;even&#39; !! &#39;odd&#39; }, (1, 7, 6, 3, 2);
# OUTPUT: «{even =&gt; [6 2], odd =&gt; [1 7 3]}␤»
say (&#39;hello&#39;, 1, 22/7, 42, &#39;world&#39;).classify: { .Str.chars };
# OUTPUT: «{1 =&gt; [1], 2 =&gt; [42], 5 =&gt; [hello world], 8 =&gt; [3.142857]}␤»</pre>
<p>It can also take <code>:as</code> as a named parameter, transforming the value before classifying it:</p>
<pre class="pod-block-code">say &lt;Innie Minnie Moe&gt;.classify( { $_.chars }, :as{ lc $_ });
# OUTPUT: «{3 =&gt; [moe], 5 =&gt; [innie], 6 =&gt; [minnie]}␤»</pre>
<p>This code is classifying by number of characters, which is the expression that has been passed as <code>$test</code> parameter, but the <code>:as</code> block lowercases it before doing the transformation. The named parameter <code>:into</code> can also be used to classify <em>into</em> a newly defined variable:</p>
<pre class="pod-block-code">&lt;Innie Minnie Moe&gt;.classify( { $_.chars }, :as{ lc $_ }, :into( my %words{Int} ) );
say %words; # OUTPUT: «{3 =&gt; [moe], 5 =&gt; [innie], 6 =&gt; [minnie]}␤»</pre>
<p>We are declaring the scope of <code>%words{Int}</code> on the fly, with keys that are actually integers; it gets created with the result of the classification.</p>
<h2 id="(List)_method_Bool"><a href="/Documentable/integration-test/type/List#method_Bool">(List) method Bool</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Bool(List:D: --&gt; Bool:D)</pre>
<p>Returns <code>True</code> if the list has at least one element, and <code>False</code> for the empty list.</p>
<pre class="pod-block-code">say ().Bool;  # OUTPUT: «False␤»
say (1).Bool; # OUTPUT: «True␤»</pre>
<h2 id="(List)_method_Str"><a href="/Documentable/integration-test/type/List#method_Str">(List) method Str</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Str(List:D: --&gt; Str:D)</pre>
<p>Stringifies the elements of the list and joins them with spaces (same as <code>.join(&#39; &#39;)</code>).</p>
<pre class="pod-block-code">say (1,2,3,4,5).Str; # OUTPUT: «1 2 3 4 5␤»</pre>
<h2 id="(List)_method_Int"><a href="/Documentable/integration-test/type/List#method_Int">(List) method Int</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Int(List:D: --&gt; Int:D)</pre>
<p>Returns the number of elements in the list (same as <code>.elems</code>).</p>
<pre class="pod-block-code">say (1,2,3,4,5).Int; # OUTPUT: «5␤»</pre>
<h2 id="(List)_method_Numeric"><a href="/Documentable/integration-test/type/List#method_Numeric">(List) method Numeric</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Numeric(List:D: --&gt; Int:D)</pre>
<p>Returns the number of elements in the list (same as <code>.elems</code>).</p>
<pre class="pod-block-code">say (1,2,3,4,5).Numeric; # OUTPUT: «5␤»</pre>
<h2 id="(List)_method_Capture"><a href="/Documentable/integration-test/type/List#method_Capture">(List) method Capture</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Capture(--&gt; Capture:D)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Capture">Capture</a> where each <a href="/Documentable/integration-test/type/Pair">Pair</a>, if any, in the <code>List</code> has been converted to a named argument (with the <a href="/Documentable/integration-test/type/Pair#method_key">key</a> of the <a href="/Documentable/integration-test/type/Pair">Pair</a> stringified). All other elements in the <code>List</code> are converted to positional arguments in the order they are found, i.e. the first non pair item in the list becomes the first positional argument, which gets index <code>0</code>, the second non pair item becomes the second positional argument, getting index <code>1</code> etc.</p>
<pre class="pod-block-code">my $list = (7, 5, a =&gt; 2, b =&gt; 17);
my $capture = $list.Capture;
say $capture.keys;                                # OUTPUT: «(0 1 a b)␤»
my-sub(|$capture);                                # OUTPUT: «7, 5, 2, 17»

sub my-sub($first, $second, :$a, :$b) {
    say &quot;$first, $second, $a, $b&quot;
}</pre>
<p>A more advanced example demonstrating the returned <code>Capture</code> being matched against a <a href="/Documentable/integration-test/type/Signature">Signature</a>.</p>
<pre class="pod-block-code">my $list = (7, 5, a =&gt; 2, b =&gt; 17);
say so $list.Capture ~~ :($ where * == 7,$,:$a,:$b); # OUTPUT: «True␤»

$list = (8, 5, a =&gt; 2, b =&gt; 17);
say so $list.Capture ~~ :($ where * == 7,$,:$a,:$b); # OUTPUT: «False␤»</pre>
<h2 id="(List)_routine_pick"><a href="/Documentable/integration-test/type/List#routine_pick">(List) routine pick</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub    pick($count, *@list --&gt; Seq:D)
multi method pick(List:D: $count --&gt; Seq:D)
multi method pick(List:D: --&gt; Mu)</pre>
<p>If <code>$count</code> is supplied: Returns <code>$count</code> elements chosen at random and without repetition from the invocant. If <code>*</code> is passed as <code>$count</code>, or <code>$count</code> is greater than or equal to the size of the list, then all elements from the invocant list are returned in a random sequence; i.e. they are returned shuffled.</p>
<p>In <em>method</em> form, if <code>$count</code> is omitted: Returns a single random item from the list, or Nil if the list is empty</p>
<p>Examples:</p>
<pre class="pod-block-code">say &lt;a b c d e&gt;.pick;           # OUTPUT: «b␤»
say &lt;a b c d e&gt;.pick: 3;        # OUTPUT: «(c a e)␤»
say &lt;a b c d e&gt;.pick: *;        # OUTPUT: «(e d a b c)␤»</pre>
<h2 id="(List)_routine_roll"><a href="/Documentable/integration-test/type/List#routine_roll">(List) routine roll</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub    roll($count, *@list --&gt; Seq:D)
multi method roll(List:D: $count --&gt; Seq:D)
multi method roll(List:D: --&gt; Mu)</pre>
<p>If <code>$count</code> is supplied: Returns a sequence of <code>$count</code> elements, each randomly selected from the list. Each random choice is made independently, like a separate die roll where each die face is a list element. If <code>*</code> is passed as <code>$count</code> returns a lazy, infinite sequence of randomly chosen elements from the original list.</p>
<p>If <code>$count</code> is omitted: Returns a single random item from the list, or Nil if the list is empty</p>
<p>Examples:</p>
<pre class="pod-block-code">say &lt;a b c d e&gt;.roll;       # 1 random letter
say &lt;a b c d e&gt;.roll: 3;    # 3 random letters
say roll 8, &lt;a b c d e&gt;;    # 8 random letters

my $random-digits := (^10).roll(*);
say $random-digits[^15];    # 15 random digits</pre>
<h2 id="(List)_routine_eager"><a href="/Documentable/integration-test/type/List#routine_eager">(List) routine eager</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method eager(List:D: --&gt; List:D)
multi sub eager(*@elems --&gt; List:D)</pre>
<p>Evaluates all elements in the <code>List</code> eagerly, and returns them as a <code>List</code>.</p>
<pre class="pod-block-code">my  \ll = (lazy 1..5).cache;

say ll[];     # OUTPUT: «(...)␤»
say ll.eager  # OUTPUT: «(1 2 3 4 5)␤»</pre>
<h2 id="(List)_routine_reverse"><a href="/Documentable/integration-test/type/List#routine_reverse">(List) routine reverse</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub    reverse(*@list  --&gt; Seq:D)
multi method reverse(List:D: --&gt; Seq:D)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Seq"><code>Seq</code></a> with the same elements in reverse order.</p>
<p>Note that <code>reverse</code> always refers to reversing elements of a list; to reverse the characters in a string, use <a href="/Documentable/integration-test/routine/flip">flip</a>.</p>
<p>Examples:</p>
<pre class="pod-block-code">say &lt;hello world!&gt;.reverse;     # OUTPUT: «(world! hello)␤»
say reverse ^10;                # OUTPUT: «(9 8 7 6 5 4 3 2 1 0)␤»</pre>
<h2 id="(List)_routine_rotate"><a href="/Documentable/integration-test/type/List#routine_rotate">(List) routine rotate</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub    rotate(@list,  Int:D $n = 1 --&gt; List:D)
multi method rotate(List:D: Int:D $n = 1 --&gt; List:D)</pre>
<p>Returns the list rotated by <code>$n</code> elements.</p>
<p>Examples:</p>
<pre class="pod-block-code">&lt;a b c d e&gt;.rotate(2);   # &lt;c d e a b&gt;
&lt;a b c d e&gt;.rotate(-1);  # &lt;e a b c d&gt;</pre>
<h2 id="(List)_routine_sort"><a href="/Documentable/integration-test/type/List#routine_sort">(List) routine sort</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub    sort(*@elems      --&gt; Seq:D)
multi sub    sort(&amp;custom-routine-to-use, *@elems --&gt; Seq:D)
multi method sort(List:D:      --&gt; Seq:D)
multi method sort(List:D: &amp;custom-routine-to-use  --&gt; Seq:D)</pre>
<p>Sorts the list, smallest element first. By default <a href="/Documentable/integration-test/routine/cmp"><code>infix:&lt;cmp&gt; </code></a> is used for comparing list elements.</p>
<p>If <code>&amp;custom-routine-to-use</code> is provided, and it accepts two arguments, it is invoked for pairs of list elements, and should return <code>Order::Less</code>, <code>Order::Same</code> or <code>Order::More</code>.</p>
<p>If <code>&amp;custom-routine-to-use</code> accepts only one argument, the list elements are sorted according to <code>custom-routine-to-use($a) cmp custom-routine-to-use($b) </code>. The return values of <code>&amp;custom-routine-to-use</code> are cached, so that <code>&amp;custom-routine-to-use</code> is only called once per list element.</p>
<p>Examples:</p>
<pre class="pod-block-code">say (3, -4, 7, -1, 2, 0).sort;                  # OUTPUT: «(-4 -1 0 2 3 7)␤»
say (3, -4, 7, -1, 2, 0).sort: *.abs;           # OUTPUT: «(0 -1 2 3 -4 7)␤»
say (3, -4, 7, -1, 2, 0).sort: { $^b leg $^a }; # OUTPUT: «(7 3 2 0 -4 -1)␤»</pre>
<p>Additionally, if <code>&amp;custom-routine-to-use</code> returns a <code>List</code>, elements will be sorted based upon multiple values with subsequent values in the <code>List</code> being used to break the tie if the comparison between the prior elements evaluate to <code>Order::Same</code>.</p>
<pre class="pod-block-code">my @resistance = (
    %( first-name =&gt; &#39;Kyle&#39;,  last-name =&gt; &#39;Reese&#39;  ),
    %( first-name =&gt; &#39;Sarah&#39;, last-name =&gt; &#39;Connor&#39; ),
    %( first-name =&gt; &#39;John&#39;,  last-name =&gt; &#39;Connor&#39; ),
);
.say for @resistance.sort: { .&lt;last-name&gt;, .&lt;first-name&gt; };

#`(
OUTPUT:
  {first-name =&gt; John, last-name =&gt; Connor}
  {first-name =&gt; Sarah, last-name =&gt; Connor}
  {first-name =&gt; Kyle, last-name =&gt; Reese}
)</pre>
<p>This sorting can be based on characteristics of a single element:</p>
<pre class="pod-block-code">say &lt;ddd aaa bbb bb ccc c&gt;.sort( {.chars, .Str} );
# OUTPUT: «(c bb aaa bbb ccc ddd)␤»
</pre>
<p>In this case, elements of the array are sorted in ascending order according first to the string length (<code>.chars</code>) and second to the actual alphabetical order <code>.Str</code>) if the length is exactly the same.</p>
<p>Any number of criteria can be used in this:</p>
<pre class="pod-block-code">say &lt;01 11 111 2 20 02&gt;.sort( { .Int, .comb.sum, .Str } );
# OUTPUT: «(01 02 2 11 20 111)␤»
</pre>
<h2 id="(List)_routine_reduce"><a href="/Documentable/integration-test/type/List#routine_reduce">(List) routine reduce</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method reduce(Any:D: &amp;with)
multi sub reduce (&amp;with, +list)</pre>
<p>Returns a single &quot;combined&quot; value from a list of arbitrarily many values, by iteratively applying a routine which knows how to combine <em>two</em> values. In addition to the subroutine and the list, an initial value can be provided to initialize the reduction, which ends up being the return value if the list is empty. Thus <code>reduce f, init, list</code> combines the elements of the list from left to right, as is shown in the following pseudocode:</p>
<pre class="pod-block-code">result0 = init
result1 = f(result0, list[0])
result2 = f(result1, list[1])
...
resultn = f(resultn-1, list[n-1])
</pre>
<p><code>resultn</code> is the final result for an n-element list.</p>
<pre class="pod-block-code">say reduce &amp;infix:&lt;+&gt;, (1, 2, 3); # OUTPUT: «6␤»
say (1, 2, 3).reduce: &amp;infix:&lt;+&gt;; # OUTPUT: «6␤»
say reduce &amp;max, (5, 9, 12, 1);   # OUTPUT: «12␤»</pre>
<p>If <code>list</code> contains just a single element, the operator is applied to that single element if possible; if not, it returns the element itself.</p>
<pre class="pod-block-code">say reduce &amp;infix:&lt;-&gt;, (10,);     # OUTPUT: «10␤»</pre>
<p>When the list contains no elements, an exception is thrown, unless <code>&amp;with</code> is an <em>operator</em> with a known identity value (e.g., the identity value of <code>infix:&lt;+&gt;</code> is 0). For this reason, you&#39;re advised to prefix the input list with an initial value (or explicit identity value):</p>
<pre class="pod-block-code">my \strings = &quot;One good string!&quot;, &quot;And one another good string!&quot;;
say reduce { $^a ~ $^b }, &#39;&#39;, |strings;               # like strings.join

my \numbers = 1, 2, 3, 4, 5;
say reduce { $^a &gt; $^b ?? $^a !! $^b }, 0, |numbers; # like numbers.max

sub count-and-sum-evens( (Int \count, Int \sum), Int \x ) {
    x %% 2 ?? (count+1, sum+x) !! (count, sum)
}

say reduce &amp;count-and-sum-evens, (0, 0), |numbers;    # OUTPUT: «(2 6)␤»</pre>
<p>In the last example, since <code>reduce</code> only supports one initial value we use a <code>List</code> with two values, which is by itself a single value. The <code>count-and-sum-evens</code> subroutine takes two positional values: a <code>List</code> of two <code>Int</code>s and an <code>Int</code>, and return a <code>List</code> storing the count and sum of the even integers accumulated.</p>
<p>If <code>&amp;with</code> is the code object of an <em>operator</em>, its inherent identity value and associativity is respected - in other words, <code>(VAL1, VAL2, VAL3).reduce(&amp;infix:&lt;OP&gt;)</code> is the same as <code>VAL1 OP VAL2 OP VAL3</code> even for operators which aren&#39;t left-associative:</p>
<pre class="pod-block-code"># Raise 2 to the 81st power, because 3 to the 4th power is 81
(2,3,4).reduce(&amp;infix:&lt;**&gt;).lsb.say;  # OUTPUT: «81␤»
(2**(3**4)).lsb.say;                  # OUTPUT: «81␤»
(2**3**4).lsb.say;                    # OUTPUT: «81␤»

# Subtract 4 from -1, because 2 minus 3 is -1
(2,3,4).reduce(&amp;infix:&lt;-&gt;).say;       # OUTPUT: «-5␤»
((2-3)-4).say;                        # OUTPUT: «-5␤»
(2-3-4).say;                          # OUTPUT: «-5␤»</pre>
<p>Since reducing with an infix operator is a common thing to do, the <a href="/Documentable/integration-test/language/operators#Reduction_metaoperators">reduction metaoperator</a> <code>[ ]</code> provides a syntactic shortcut. Thus, instead of passing the operator&#39;s code object to <code>reduce</code>, just pass the operator directly to <code>[ ]</code>. To use a user-defined subroutine instead, provide an additional layer of square brackets around the subroutine&#39;s code object:</p>
<pre class="pod-block-code">say [*] (1, 2, 3, 4);       # OUTPUT: «24␤»
say [min] (4, 2, 1, 3);     # OUTPUT: «1␤»

sub mult { $^a * $^b };
say [[&amp;mult]] (1, 2, 3, 4); # OUTPUT: «24␤»</pre>
<p>Semantically, all the following do the same thing:</p>
<pre class="pod-block-code">my \numbers = 1, 2, 3, 4, 5;
say reduce { $^a + $^b }, 0, |numbers;
say reduce * + *, 0, |numbers;
say reduce &amp;[+], numbers; # operator does not need explicit identity value
say [+] numbers;</pre>
<p>Since <code>reduce</code> is an implicit loop that iterates over with its <em>reducing</em> subroutine, it responds to <code>next</code>, <code>last</code> and <code>redo</code> statements inside <code>&amp;with</code>:</p>
<pre class="pod-block-code">sub last-after-seven { last if $^a &gt; 7; $^a + $^b };
say (2, 3, 4, 5).reduce: &amp;last-after-seven; # OUTPUT: «9␤»</pre>
<p>Whether <code>reduce</code> accumulates the elements starting from the left or from the right depends on the operator. In the functional programming world, this operation is generally called a <a href="https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29#Folds_on_lists">fold</a>. With a right-associative operator it is a <em>right fold</em>, otherwise (and usually) it is a <em>left fold</em>. In Raku, you can specify the associativity of an operator with the <a href="/Documentable/integration-test/language/functions#index-entry-is_assoc_(trait)"><code>is assoc</code></a>.</p>
<pre class="pod-block-code">sub infix:&lt;foo&gt;($a, $b) is assoc&lt;right&gt; { &quot;($a, $b)&quot; }
say [foo] 1, 2, 3, 4; # OUTPUT: «(1, (2, (3, 4)))␤»

sub infix:&lt;bar&gt;($a, $b) is assoc&lt;left&gt; { &quot;($a, $b)&quot; }
say [bar] 1, 2, 3, 4; # OUTPUT: «(((1, 2), 3), 4)␤»</pre>
<p><strong>Practical example 1:</strong> In this example, we generate a random-ish math formula (e.g., &quot;(4 + ((3 * x) + 11) / 6))&quot;) using <code>reduce</code>.</p>
<pre class="pod-block-code">my @ops = [Z] (&lt;+ - * /&gt;, 1..20)».roll(4);

say (&#39;x&#39;, |@ops).reduce: -&gt; $formula, [$op, $number] {
    Bool.pick ?? &quot;($formula $op $number)&quot;
              !! &quot;($number $op $formula)&quot;
}</pre>
<p><strong>Practical example 2:</strong> Suppose we have a polynomial represented as a list of integer coefficients, c[n-1], c[n-2], ..., c[0], where c[i] is the coefficient of xi. We can evaluate it using <code>map</code> and <code>reduce</code> as follows:</p>
<pre class="pod-block-code">sub evaluate(List:D \c where c.all ~~ Int, Rat:D \x --&gt; Rat:D) {
    my \xi = (c.elems ^... 0).map: -&gt; \i { x ** i }; # [x^(n-1), ..., x^0]
    my \axi = [+] c Z* xi;                           # [c[n-1]*x^(n-1), ..., c[*]x^0]
    [+] axi;                                         # sum of axi
}

my \c = 2, 3, 1;       # 2x² + 3x + 1
say evaluate c, 3.0;   # OUTPUT: «28␤»
say evaluate c, 10.0;  # OUTPUT: «231␤»</pre>
<h2 id="(List)_routine_produce"><a href="/Documentable/integration-test/type/List#routine_produce">(List) routine produce</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub    produce(&amp;with, *@values)
multi method produce(List:D: &amp;with)</pre>
<p>Generates a list of all intermediate &quot;combined&quot; values along with the final result by iteratively applying a function which knows how to combine <em>two</em> values.</p>
<p>If <code>@values</code> contains just a single element, a list containing that element is returned immediately. If it contains no elements, an exception is thrown, unless <code>&amp;with</code> is an <em>operator</em> with a known identity value.</p>
<p>If <code>&amp;with</code> is the function object of an <em>operator</em>, its inherent identity value and associativity is respected - in other words, <code>(VAL1, VAL2, VAL3).produce(&amp;[OP])</code> is the same as <code>VAL1 OP VAL2 OP VAL3</code> even for operators which aren&#39;t left-associative:</p>
<pre class="pod-block-code"># Raise 2 to the 81st power, because 3 to the 4th power is 81
[2,3,4].produce(&amp;[**]).say;        # OUTPUT: «(4 81 2417851639229258349412352)␤»
say produce &amp;[**], (2,3,4);        # OUTPUT: «(4 81 2417851639229258349412352)␤»
say [\**] (2,3,4);                 # OUTPUT: «(4 81 2417851639229258349412352)␤»

# Subtract 4 from -1, because 2 minus 3 is -1
[2,3,4].produce(&amp;[-]).say;         # OUTPUT: «(2 -1 -5)␤»
say produce &amp;[-], (2,3,4);         # OUTPUT: «(2 -1 -5)␤»
say [\-] (2,3,4);                  # OUTPUT: «(2 -1 -5)␤»</pre>
<p>A triangle metaoperator <code>[\ ]</code> provides a syntactic shortcut for producing with an infix operator:</p>
<pre class="pod-block-code"># The following all do the same thing...
my @numbers = (1,2,3,4,5);
say produce { $^a + $^b }, @numbers;
say produce * + *, @numbers;
say produce &amp;[+], @numbers; # operator does not need explicit identity
say [\+] @numbers;          # most people write it this way</pre>
<p>The visual picture of a triangle <code>[\</code> is not accidental. To produce a triangular list of lists, you can use a &quot;triangular comma&quot;:</p>
<pre class="pod-block-code">[\,] 1..5;
# (
# (1)
# (1 2)
# (1 2 3)
# (1 2 3 4)
# (1 2 3 4 5)
# )</pre>
<p>Since <code>produce</code> is an implicit loop, it responds to <code>next</code>, <code>last</code> and <code>redo</code> statements inside <code>&amp;with</code>:</p>
<pre class="pod-block-code">say (2,3,4,5).produce: { last if $^a &gt; 7; $^a + $^b }; # OUTPUT: «(2 5 9)␤»</pre>
<h2 id="(List)_routine_combinations"><a href="/Documentable/integration-test/type/List#routine_combinations">(List) routine combinations</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub    combinations($from, $of = 0..*             --&gt; Seq:D)
multi method combinations(List:D: Int() $of             --&gt; Seq:D)
multi method combinations(List:D: Iterable:D $of = 0..* --&gt; Seq:D)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Seq">Seq</a> with all <code>$of</code>-combinations of the invocant list. <code>$of</code> can be a numeric <a href="/Documentable/integration-test/type/Range">Range</a>, in which case combinations of the range of item numbers it represents will be returned (i.e. <code>2.6 .. 4</code> will return 2-, 3-, and 4-item combinations&gt;). Otherwise, <code>$of</code> is coerced to an <a href="/Documentable/integration-test/type/Int">Int</a>.</p>
<pre class="pod-block-code">.say for &lt;a b c&gt;.combinations: 2;
# OUTPUT:
# (a b)
# (a c)
# (b c)</pre>
<p>Above, there are three possible ways to combine the 2-items lists from the original list, which is what we receive in the output. See <a href="/Documentable/integration-test/routine/permutations">permutations</a> if you want permutations instead of combinations.</p>
<p>With <a href="/Documentable/integration-test/type/Range">Range</a> argument, we get both three 2-item combinations and one 3-item combination:</p>
<pre class="pod-block-code">.say for &lt;a b c&gt;.combinations: 2..3;
# OUTPUT:
# (a b)
# (a c)
# (b c)
# (a b c)</pre>
<p>If <code>$of</code> is negative or is larger than there are items in the given list, an empty list will be returned. If <code>$of</code> is zero, a 1-item list containing an empty list will be returned (there&#39;s exactly 1 way to pick no items).</p>
<p>The subroutine form is equivalent to the method form called on the first argument (<code>$from</code>), with the exception that if <code>$from</code> is not an <a href="/Documentable/integration-test/type/Iterable">Iterable</a>, it gets coerced to an <code>Int</code> and combinations are made from a <a href="/Documentable/integration-test/type/Range">Range</a> constructed with <code>0..^$from</code> instead:</p>
<pre class="pod-block-code">.say for combinations 3, 2
# OUTPUT:
# (0 1)
# (0 2)
# (1 2)</pre>
<p><strong>Note:</strong> some implementations may limit the maximum value of non-<a href="/Documentable/integration-test/type/Iterable">Iterable</a> <code>$from</code>. On Rakudo, 64-bit systems have a limit of <code>2³¹-1</code> and 32-bit systems have a limit of <code>2²⁸-1</code>.</p>
<h2 id="(List)_routine_permutations"><a href="/Documentable/integration-test/type/List#routine_permutations">(List) routine permutations</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub    permutations(Int()    $from --&gt; Seq:D)
multi sub    permutations(Iterable $from --&gt; Seq:D)
multi method permutations(List:D:        --&gt; Seq:D)</pre>
<p>Returns all possible permutations of a list as a <a href="/Documentable/integration-test/type/Seq">Seq</a> of lists:</p>
<pre class="pod-block-code">.say for &lt;a b c&gt;.permutations;
# OUTPUT:
# (a b c)
# (a c b)
# (b a c)
# (b c a)
# (c a b)
# (c b a)</pre>
<p><code>permutations</code> treats all elements as unique, thus <code>(1, 1, 2).permutations</code> returns a list of 6 elements, even though there are only three distinct permutations, due to first two elements being the same.</p>
<p>The subroutine form behaves the same as the method form, computing permutations from its first argument <code>$from</code>. If <code>$from</code> is not an <a href="/Documentable/integration-test/type/Iterable">Iterable</a>, coerces <code>$from</code> to an <code>Int</code> and picks from a <a href="/Documentable/integration-test/type/Range">Range</a> constructed with <code>0..^$from</code>:</p>
<pre class="pod-block-code">.say for permutations 3;
# OUTPUT:
# (0 1 2)
# (0 2 1)
# (1 0 2)
# (1 2 0)
# (2 0 1)
# (2 1 0)</pre>
<h2 id="(List)_method_rotor"><a href="/Documentable/integration-test/type/List#method_rotor">(List) method rotor</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method rotor(*@cycle, Bool() :$partial --&gt; Seq:D)</pre>
<p>Returns a sequence of lists, where each sublist is made up of elements of the invocant.</p>
<p>In the simplest case, <code>@cycle</code> contains just one integer, in which case the invocant list is split into sublists with as many elements as the integer specifies. If <code>:$partial</code> is True, the final chunk is included even if it doesn&#39;t satisfy the length requirement:</p>
<pre class="pod-block-code">say (&#39;a&#39;..&#39;h&#39;).rotor(3).join(&#39;|&#39;);              # OUTPUT: «a b c|d e f␤»
say (&#39;a&#39;..&#39;h&#39;).rotor(3, :partial).join(&#39;|&#39;);    # OUTPUT: «a b c|d e f|g h␤»</pre>
<p>If the element of <code>@cycle</code> is a <a href="/Documentable/integration-test/type/Pair">Pair</a> instead, the key of the pair specifies the length of the return sublist, and the value the gap between sublists; negative gaps produce overlap:</p>
<pre class="pod-block-code">say (&#39;a&#39;..&#39;h&#39;).rotor(2 =&gt; 1).join(&#39;|&#39;);         # OUTPUT: «a b|d e|g h␤»
say (&#39;a&#39;..&#39;h&#39;).rotor(3 =&gt; -1).join(&#39;|&#39;);        # OUTPUT: «a b c|c d e|e f g␤»</pre>
<p>If <code>@cycle</code> contains more than element, <code>rotor</code> cycles through it to find the number of elements for each sublist:</p>
<pre class="pod-block-code">say (&#39;a&#39;..&#39;h&#39;).rotor(2, 3).join(&#39;|&#39;);           # OUTPUT: «a b|c d e|f g␤»
say (&#39;a&#39;..&#39;h&#39;).rotor(1 =&gt; 1, 3).join(&#39;|&#39;);      # OUTPUT: «a|c d e|f␤»</pre>
<p>Combining multiple cycles and <code>:partial</code> also works:</p>
<pre class="pod-block-code">say (&#39;a&#39;..&#39;h&#39;).rotor(1 =&gt; 1, 3 =&gt; -1, :partial).join(&#39;|&#39;);
# OUTPUT: «a|c d e|e|g h␤»</pre>
<p>See <a href="http://blogs.perl.org/users/zoffix_znet/2016/01/perl-6-rotor-the-king-of-list-manipulation.html">this blog post for more elaboration on rotor</a>.</p>
<h2 id="(List)_method_batch"><a href="/Documentable/integration-test/type/List#method_batch">(List) method batch</a></h2>
<p>Defined As:</p>
<pre class="pod-block-code">multi method batch(Int:D $batch --&gt; Seq)
multi method batch(Int:D :$elems --&gt; Seq)</pre>
<p>Returns a sequence of lists, wherein each list with the exception of the last one is guaranteed to comprise a number of elements equal to the batch size specified by <code>$batch</code> or <code>$elems</code>, respectively. If the invocant has a number of elements that is not an integer multiple of the batch size, the last list in the returned sequence will contain any remaining elements and thus have less than <code>$batch</code> or <code>$elems</code> elements. Accordingly, <code>.batch($batch)</code> is shorthand for <code>.rotor($batch, :partial)</code>.</p>
<h2 id="(List)_routine_cross"><a href="/Documentable/integration-test/type/List#routine_cross">(List) routine cross</a></h2>
<pre class="pod-block-code">sub cross(+@e, :&amp;with --&gt; Seq:D)</pre>
<p>Computes the cross-product of two or more lists or <a href="/Documentable/integration-test/type/Iterable">iterables</a>. This returns a sequence of lists where the first item in each list is an item from the first iterable, the second is from the second given iterable, etc. Every item will be paired with every other item in all the other lists.</p>
<pre class="pod-block-code">say cross(&lt;a b c&gt;, &lt;d e f&gt;).map(*.join).join(&quot;,&quot;)
# OUTPUT: «ad,ae,af,bd,be,bf,cd,ce,cf␤»</pre>
<p>The <code>cross</code> routine has an infix synonym as well, named <code>X</code>.</p>
<pre class="pod-block-code">say (&lt;a b c&gt; X &lt;d e f&gt;).map(*.join).join(&quot;,&quot;)
# output is the same as the previous example</pre>
<p>If the optional <code>with</code> parameter is passed, it is used as a reduction operation to apply to each of the cross product items.</p>
<pre class="pod-block-code">say cross([1, 2, 3], [4, 5, 6], :with(&amp;infix:&lt;*&gt;)).join(&quot;,&quot;);
# OUTPUT: «4,5,6,8,10,12,12,15,18␤»</pre>
<p>The <code>X</code> operator can be combined with another operator as a metaoperator to perform a reduction as well:</p>
<pre class="pod-block-code">say ([1, 2, 3] X* [4, 5, 6]).join(&quot;,&quot;)
# same output as the previous example</pre>
<h2 id="(List)_routine_zip"><a href="/Documentable/integration-test/type/List#routine_zip">(List) routine zip</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub zip(+@e, :&amp;with --&gt; Seq:D)</pre>
<p>Builds a &#39;list of lists&#39;, returned as a sequence, from multiple input lists or other <a href="/Documentable/integration-test/type/Iterable">iterables</a>.</p>
<p><code>zip</code> iterates through each of the input lists synchronously, &#39;Zipping&#39; them together, so that elements are grouped according to their input list index, in the order that the lists are provided.</p>
<pre class="pod-block-code">say zip(&lt;a b c&gt;, &lt;d e f&gt;, &lt;g h i&gt;);
# OUTPUT: «((a d g) (b e h) (c f i))␤»</pre>
<p><code>zip</code> has an infix synonym, the <code>Z</code> operator.</p>
<pre class="pod-block-code">say &lt;a b c&gt; Z &lt;d e f&gt; Z &lt;g h i&gt;;                   # same output</pre>
<p><code>zip</code> can provide input to a for loop :</p>
<pre class="pod-block-code">for &lt;a b c&gt; Z &lt;d e f&gt; Z &lt;g h i&gt; -&gt; [$x,$y,$z] {say ($x,$y,$z).join(&quot;,&quot;)}
# OUTPUT: «a,d,g␤
# b,e,h␤
# c,f,i␤»</pre>
<p>, or more succinctly:</p>
<pre class="pod-block-code">say .join(&quot;,&quot;) for zip &lt;a b c&gt;, &lt;d e f&gt;, &lt;g h i&gt;;  # same output</pre>
<p>Note, that if the input lists have an unequal number of elements, then <code>zip</code> terminates once the shortest input list is exhausted, and trailing elements from longer input lists are discarded.</p>
<pre class="pod-block-code">say &lt;a b c&gt; Z &lt;d e f m n o p&gt; Z &lt;g h i&gt;;
# ((a d g) (b e h) (c f i))</pre>
<p>In cases where data clipping is possible, but undesired, then consider using <a href="/Documentable/integration-test/routine/roundrobin">roundrobin</a> instead of <code>zip</code>.</p>
<p>The optional <code>with</code> parameter will additionally reduce the zipped lists. For example, the following multiplies corresponding elements together to return a single list of products.</p>
<pre class="pod-block-code">.say for zip &lt;1 2 3&gt;, [1, 2, 3], (1, 2, 3), :with(&amp;infix:&lt;*&gt;);
# OUTPUT: «1␤
# 8␤
# 27␤»</pre>
<p>The <code>Z</code> form can also be used to perform reduction by implicitly setting the <code>with</code> parameter with a metaoperator :</p>
<pre class="pod-block-code">.say for &lt;1 2 3&gt; Z* [1, 2, 3] Z* (1, 2, 3);        # same output</pre>
<h2 id="(List)_routine_roundrobin"><a href="/Documentable/integration-test/type/List#routine_roundrobin">(List) routine roundrobin</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub roundrobin(+list-of-lists --&gt; Seq)</pre>
<p>Builds a &#39;list of lists&#39;, returned as a sequence, from multiple input lists or other <a href="/Documentable/integration-test/type/Iterable">iterables</a>. <code>roundrobin</code> returns an identical result to that of <a href="/Documentable/integration-test/type/List#routine_zip">zip</a>, except when the input lists are allowed to have an unequal number of elements.</p>
<pre class="pod-block-code">say roundrobin &lt;a b c&gt;, &lt;d e f&gt;, &lt;g h i&gt;;
# OUTPUT: «((a d g) (b e h) (c f i))␤»

say .join(&quot;,&quot;) for roundrobin([1, 2], [2, 3], [3, 4]);
# OUTPUT: «1,2,3␤
# 2,3,4␤»</pre>
<p><code>roundrobin</code> does not terminate once one or more of the input lists become exhausted, but proceeds until all elements from all lists have been processed.</p>
<pre class="pod-block-code">say roundrobin &lt;a b c&gt;, &lt;d e f m n o p&gt;, &lt;g h i j&gt;;
# OUTPUT: «((a d g) (b e h) (c f i) (m j) (n) (o) (p))␤»

say .join(&quot;,&quot;) for roundrobin([1, 2], [2, 3, 57, 77], [3, 4, 102]);
# OUTPUT: «1,2,3␤
# 2,3,4␤
# 57,102␤
# 77␤»</pre>
<p>Therefore no data values are lost due in the &#39;zipping&#39; operation. A record of which input list provided which element cannot be gleaned from the resulting sequence, however.</p>
<p><code>roundrobin</code> can be useful in combining messy data to the point where a manual post-processing step can then be undertaken.</p>
<h2 id="(List)_routine_sum"><a href="/Documentable/integration-test/type/List#routine_sum">(List) routine sum</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub    sum($list  )
method sum(List:D:)</pre>
<p>Returns the sum of all elements in the list or 0 if the list is empty. Throws an exception if an element can not be coerced into Numeric.</p>
<pre class="pod-block-code">say (1, 3, pi).sum;       # OUTPUT: «7.14159265358979␤»
say (1, &quot;0xff&quot;).sum;      # OUTPUT: «256␤»
say sum(0b1111, 5);       # OUTPUT: «20␤»</pre>
<p>If the list includes a <code>Junction</code>, the result will accordingly be a <code>Junction</code>:</p>
<pre class="pod-block-code">say ( 1|2, 3).sum;            # OUTPUT: «any(4, 5)␤»
</pre>
<p>When called on native integer arrays, it is also possible to specify a <code>:wrap</code> named parameter. This will add the values as native integers, wrapping around if they exceed the size of a native integer. If you are sure you will not exceed that value, or if you don&#39;t mind, using <code>:wrap</code> will make the calculation about 20x as fast.</p>
<pre class="pod-block-code">my int @values = ^1_000_000;
say @a.sum(:wrap);        # OUTPUT: «499999500000␤»
</pre>
<h2 id="(List)_method_fmt"><a href="/Documentable/integration-test/type/List#method_fmt">(List) method fmt</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method fmt($format = &#39;%s&#39;, $separator = &#39; &#39; --&gt; Str:D)</pre>
<p>Returns a string where each element in the list has been formatted according to <code>$format</code> and where each element is separated by <code>$separator</code>.</p>
<p>For more information about formats strings, see <a href="/Documentable/integration-test/routine/sprintf">sprintf</a>.</p>
<pre class="pod-block-code">my @a = 8..11;
say @a.fmt(&#39;%03d&#39;, &#39;,&#39;);  # OUTPUT: «008,009,010,011␤»</pre>
<h2 id="(List)_method_from"><a href="/Documentable/integration-test/type/List#method_from">(List) method from</a></h2>
<p>Assumes the list contains <a href="/Documentable/integration-test/type/Match"><code>Match</code> objects</a> and returns the value of <code>.from</code> called on the first element of the list.</p>
<pre class="pod-block-code">&#39;abcdefg&#39; ~~ /(c)(d)/;
say $/.list.from;         # OUTPUT: «2␤»

&quot;abc123def&quot; ~~ m:g/\d/;
say $/.list.from;         # OUTPUT: «3␤»</pre>
<h2 id="(List)_method_to"><a href="/Documentable/integration-test/type/List#method_to">(List) method to</a></h2>
<pre class="pod-block-code">&quot;abc123def&quot; ~~ m:g/\d/;
say $/.to; # OUTPUT: «6␤»</pre>
<p>Assumes the <code>List</code> contains <a href="/Documentable/integration-test/type/Match"><code>Match</code> objects</a>, such as the <code>$/</code> variable being a <code>List</code>, when using <code>:g</code> modifier in regexes. Returns the value of <code>.to</code> called on the last element of the list.</p>
<h2 id="(List)_method_sink"><a href="/Documentable/integration-test/type/List#method_sink">(List) method sink</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method sink(--&gt; Nil) { }</pre>
<p>It does nothing, and returns <code>Nil</code>, as the definition clearly shows.</p>
<pre class="pod-block-code">sink [1,2,Failure.new(&quot;boo!&quot;),&quot;still here&quot;]; # OUTPUT: «»</pre>
<h2 id="(List)_method_Set"><a href="/Documentable/integration-test/type/List#method_Set">(List) method Set</a></h2>
<p>In general, creates a set which has as members elements of the list.</p>
<pre class="pod-block-code">say &lt;æ ß þ €&gt;.Set;  # OUTPUT: «set(ß æ þ €)␤»</pre>
<p>However, there might be some unexpected changes in case the list includes non-scalar data structures. For instance, with <a href="/Documentable/integration-test/type/Pair">Pair</a>s:</p>
<pre class="pod-block-code">my @a = (:42a, :33b);
say @a;                # OUTPUT: «[a =&gt; 42 b =&gt; 33]␤»
say @a.Set;            # OUTPUT: «set(a b)␤»</pre>
<p>The set will be composed of the <code>key</code>s of the Pair whose corresponding value is not 0, eliminating all the values. Please check the <a href="/Documentable/integration-test/type/Set#Creating_Set_objects"><code>Set</code> documentation</a> for more examples and a more thorough explanation.</p>
<h2 id="(List)_infix_cmp"><a href="/Documentable/integration-test/type/List#infix_cmp">(List) infix cmp</a></h2>
<pre class="pod-block-code">multi sub infix:&lt;cmp&gt;(List @a, List @b)</pre>
<p>Evaluates <code>Lists</code> by comparing element <code>@a[$i]</code> with <code>@b[$i]</code> (for some <code>Int $i</code>, beginning at 0) and returning <code>Order::Less</code>, <code>Order::Same</code>, or <code>Order::More</code> depending on if and how the values differ. If the operation evaluates to <code>Order::Same</code>, <code>@a[$i + 1]</code> is compared with <code>@b[$i + 1]</code>. This is repeated until one is greater than the other or all elements are exhausted.</p>
<p>If the <code>Lists</code> are of different lengths, at most only <code>$n</code> comparisons will be made (where <code>$n = @a.elems min @b.elems</code>). If all of those comparisons evaluate to <code>Order::Same</code>, the final value is selected based upon which <code>List</code> is longer.</p>
<pre class="pod-block-code">say (1, 2, 3) cmp (1, 2, 3);   # OUTPUT: «Same␤»
say (4, 5, 6) cmp (4, 5, 7);   # OUTPUT: «Less␤»
say (7, 8, 9) cmp (7, 8, 8);   # OUTPUT: «More␤»

say (1, 2)    cmp (1, 2, 3);   # OUTPUT: «Less␤»
say (1, 2, 3) cmp (1, 2);      # OUTPUT: «More␤»
say (9).List  cmp (^10).List;  # OUTPUT: «More␤»</pre>
<h1 id="Routines_supplied_by_class_Cool"><a class="u" href="#___top" title="go to top of document">Routines supplied by class Cool</a></h1>
<p>Slip inherits from class <a href="/Documentable/integration-test/type/Cool">Cool</a>, which provides the following routines:</p>
<h2 id="(Cool)_routine_abs"><a href="/Documentable/integration-test/type/Cool#routine_abs">(Cool) routine abs</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub abs(Numeric() $x)
method abs()</pre>
<p>Coerces the invocant (or in the sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> and returns the absolute value (that is, a non-negative number).</p>
<pre class="pod-block-code">say (-2).abs;       # OUTPUT: «2␤»
say abs &quot;6+8i&quot;;     # OUTPUT: «10␤»</pre>
<h2 id="(Cool)_method_conj"><a href="/Documentable/integration-test/type/Cool#method_conj">(Cool) method conj</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method conj()</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> and returns the <a href="/Documentable/integration-test/type/Complex">complex</a> conjugate (that is, the number with the sign of the imaginary part negated).</p>
<pre class="pod-block-code">say (1+2i).conj;        # OUTPUT: «1-2i␤»</pre>
<h2 id="(Cool)_routine_EVAL"><a href="/Documentable/integration-test/type/Cool#routine_EVAL">(Cool) routine EVAL</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method EVAL(*%_)
</pre>
<p>It calls the <a href="/Documentable/integration-test/language/independent-routines#routine_EVAL">subroutine form</a> with the invocant as the first argument, <code>$code</code>, passing along named args, if any.</p>
<h2 id="(Cool)_routine_sqrt"><a href="/Documentable/integration-test/type/Cool#routine_sqrt">(Cool) routine sqrt</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub sqrt(Numeric(Cool) $x)
method sqrt()</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> (or in the sub form, the argument) and returns the square root, that is, a non-negative number that, when multiplied with itself, produces the original number.</p>
<pre class="pod-block-code">say 4.sqrt;             # OUTPUT: «2␤»
say sqrt(2);            # OUTPUT: «1.4142135623731␤»</pre>
<h2 id="(Cool)_method_sign"><a href="/Documentable/integration-test/type/Cool#method_sign">(Cool) method sign</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method sign()</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Real">Numeric</a> and returns its sign, that is, 0 if the number is 0, 1 for positive and -1 for negative values.</p>
<pre class="pod-block-code">say 6.sign;             # OUTPUT: «1␤»
say (-6).sign;          # OUTPUT: «-1␤»
say &quot;0&quot;.sign;           # OUTPUT: «0␤»</pre>
<h2 id="(Cool)_method_rand"><a href="/Documentable/integration-test/type/Cool#method_rand">(Cool) method rand</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method rand()</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Num">Num</a> and returns a pseudo-random value between zero and the number.</p>
<pre class="pod-block-code">say 1e5.rand;           # OUTPUT: «33128.495184283␤»</pre>
<h2 id="(Cool)_routine_sin"><a href="/Documentable/integration-test/type/Cool#routine_sin">(Cool) routine sin</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub sin(Numeric(Cool))
method sin()</pre>
<p>Coerces the invocant (or in the sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians, returns its <a href="https://en.wikipedia.org/wiki/Sine">sine</a>.</p>
<pre class="pod-block-code">say sin(0);             # OUTPUT: «0␤»
say sin(pi/4);          # OUTPUT: «0.707106781186547␤»
say sin(pi/2);          # OUTPUT: «1␤»</pre>
<p>Note that Raku is no computer algebra system, so <code>sin(pi)</code> typically does not produce an exact 0, but rather a very small <a href="/Documentable/integration-test/type/Num">floating-point number</a>.</p>
<h2 id="(Cool)_routine_asin"><a href="/Documentable/integration-test/type/Cool#routine_asin">(Cool) routine asin</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub asin(Numeric(Cool))
method asin()</pre>
<p>Coerces the invocant (or in the sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arc-sine</a> in radians.</p>
<pre class="pod-block-code">say 0.1.asin;               # OUTPUT: «0.10016742116156␤»
say asin(0.1);              # OUTPUT: «0.10016742116156␤»</pre>
<h2 id="(Cool)_routine_cos"><a href="/Documentable/integration-test/type/Cool#routine_cos">(Cool) routine cos</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cos(Numeric(Cool))
method cos()</pre>
<p>Coerces the invocant (or in sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians, returns its <a href="https://en.wikipedia.org/wiki/Cosine">cosine</a>.</p>
<pre class="pod-block-code">say 0.cos;                  # OUTPUT: «1␤»
say pi.cos;                 # OUTPUT: «-1␤»
say cos(pi/2);              # OUTPUT: «6.12323399573677e-17␤»</pre>
<h2 id="(Cool)_routine_acos"><a href="/Documentable/integration-test/type/Cool#routine_acos">(Cool) routine acos</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub acos(Numeric(Cool))
method acos()</pre>
<p>Coerces the invocant (or in sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arc-cosine</a> in radians.</p>
<pre class="pod-block-code">say 1.acos;                 # OUTPUT: «0␤»
say acos(-1);               # OUTPUT: «3.14159265358979␤»</pre>
<h2 id="(Cool)_routine_tan"><a href="/Documentable/integration-test/type/Cool#routine_tan">(Cool) routine tan</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub tan(Numeric(Cool))
method tan()</pre>
<p>Coerces the invocant (or in sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians, returns its <a href="https://en.wikipedia.org/wiki/Tangent">tangent</a>.</p>
<pre class="pod-block-code">say tan(3);                 # OUTPUT: «-0.142546543074278␤»
say 3.tan;                  # OUTPUT: «-0.142546543074278␤»</pre>
<h2 id="(Cool)_routine_atan"><a href="/Documentable/integration-test/type/Cool#routine_atan">(Cool) routine atan</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub atan(Numeric(Cool))
method atan()</pre>
<p>Coerces the invocant (or in sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arc-tangent</a> in radians.</p>
<pre class="pod-block-code">say atan(3);                # OUTPUT: «1.24904577239825␤»
say 3.atan;                 # OUTPUT: «1.24904577239825␤»</pre>
<h2 id="(Cool)_routine_atan2"><a href="/Documentable/integration-test/type/Cool#routine_atan2">(Cool) routine atan2</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub atan2($y, $x = 1e0)
method atan2($x = 1e0)</pre>
<p>The sub should usually be written with two arguments for clarity as it is seen in other languages and in mathematical texts, but the single-argument form is available; its result will always match that of <a href="/Documentable/integration-test/routine/atan">atan</a>.</p>
<pre class="pod-block-code">say atan2 3, 1;             # OUTPUT: «1.2490457723982544␤»
say atan2 3;                # OUTPUT: «1.2490457723982544␤»
say atan2 ⅔, ⅓;             # OUTPUT: «1.1071487177940904␤»</pre>
<p>The method coerces self and its single argument to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, using them to compute the two-argument <a href="https://en.wikipedia.org/wiki/Atan2">arc-tangent</a> in radians.</p>
<pre class="pod-block-code">say 3.atan2;                # OUTPUT: «1.24904577239825␤»
say ⅔.atan2(⅓);             # OUTPUT: «1.1071487177940904␤»</pre>
<p>The $x argument in either the method or the sub defaults to 1 so, in both single-argument cases, the function will return the angle θ in radians between the x-axis and a vector that goes from the origin to the point (3, 1).</p>
<h2 id="(Cool)_routine_sec"><a href="/Documentable/integration-test/type/Cool#routine_sec">(Cool) routine sec</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub sec(Numeric(Cool))
method sec()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians, returns its <a href="https://en.wikipedia.org/wiki/Trigonometric_functions#Reciprocal_functions">secant</a>, that is, the reciprocal of its cosine.</p>
<pre class="pod-block-code">say 45.sec;                 # OUTPUT: «1.90359440740442␤»
say sec(45);                # OUTPUT: «1.90359440740442␤»</pre>
<h2 id="(Cool)_routine_asec"><a href="/Documentable/integration-test/type/Cool#routine_asec">(Cool) routine asec</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub asec(Numeric(Cool))
method asec()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arc-secant</a> in radians.</p>
<pre class="pod-block-code">say 1.asec;                 # OUTPUT: «0␤»
say sqrt(2).asec;           # OUTPUT: «0.785398163397448␤»</pre>
<h2 id="(Cool)_routine_cosec"><a href="/Documentable/integration-test/type/Cool#routine_cosec">(Cool) routine cosec</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cosec(Numeric(Cool))
method cosec()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians, returns its <a href="https://en.wikipedia.org/wiki/Trigonometric_functions#Reciprocal_functions">cosecant</a>, that is, the reciprocal of its sine.</p>
<pre class="pod-block-code">say 0.45.cosec;             # OUTPUT: «2.29903273150897␤»
say cosec(0.45);            # OUTPUT: «2.29903273150897␤»</pre>
<h2 id="(Cool)_routine_acosec"><a href="/Documentable/integration-test/type/Cool#routine_acosec">(Cool) routine acosec</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub acosec(Numeric(Cool))
method acosec()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arc-cosecant</a> in radians.</p>
<pre class="pod-block-code">say 45.acosec;              # OUTPUT: «0.0222240516182672␤»
say acosec(45)              # OUTPUT: «0.0222240516182672␤»</pre>
<h2 id="(Cool)_routine_cotan"><a href="/Documentable/integration-test/type/Cool#routine_cotan">(Cool) routine cotan</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cotan(Numeric(Cool))
method cotan()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians, returns its <a href="https://en.wikipedia.org/wiki/Trigonometric_functions#Reciprocal_functions">cotangent</a>, that is, the reciprocal of its tangent.</p>
<pre class="pod-block-code">say 45.cotan;               # OUTPUT: «0.617369623783555␤»
say cotan(45);              # OUTPUT: «0.617369623783555␤»</pre>
<h2 id="(Cool)_routine_acotan"><a href="/Documentable/integration-test/type/Cool#routine_acotan">(Cool) routine acotan</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub acotan(Numeric(Cool))
method acotan()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arc-cotangent</a> in radians.</p>
<pre class="pod-block-code">say 45.acotan;              # OUTPUT: «0.0222185653267191␤»
say acotan(45)              # OUTPUT: «0.0222185653267191␤»</pre>
<h2 id="(Cool)_routine_sinh"><a href="/Documentable/integration-test/type/Cool#routine_sinh">(Cool) routine sinh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub sinh(Numeric(Cool))
method sinh()</pre>
<p>Coerces the invocant (or in method form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Sine hyperbolicus</a>.</p>
<pre class="pod-block-code">say 1.sinh;                 # OUTPUT: «1.1752011936438␤»
say sinh(1);                # OUTPUT: «1.1752011936438␤»</pre>
<h2 id="(Cool)_routine_asinh"><a href="/Documentable/integration-test/type/Cool#routine_asinh">(Cool) routine asinh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub asinh(Numeric(Cool))
method asinh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_hyperbolic_function">Inverse Sine hyperbolicus</a>.</p>
<pre class="pod-block-code">say 1.asinh;                # OUTPUT: «0.881373587019543␤»
say asinh(1);               # OUTPUT: «0.881373587019543␤»</pre>
<h2 id="(Cool)_routine_cosh"><a href="/Documentable/integration-test/type/Cool#routine_cosh">(Cool) routine cosh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cosh(Numeric(Cool))
method cosh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Cosine hyperbolicus</a>.</p>
<pre class="pod-block-code">say cosh(0.5);              # OUTPUT: «1.12762596520638␤»</pre>
<h2 id="(Cool)_routine_acosh"><a href="/Documentable/integration-test/type/Cool#routine_acosh">(Cool) routine acosh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub acosh(Numeric(Cool))
method acosh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_hyperbolic_function">Inverse Cosine hyperbolicus</a>.</p>
<pre class="pod-block-code">say acosh(45);              # OUTPUT: «4.4996861906715␤»</pre>
<h2 id="(Cool)_routine_tanh"><a href="/Documentable/integration-test/type/Cool#routine_tanh">(Cool) routine tanh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub tanh(Numeric(Cool))
method tanh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Tangent hyperbolicus</a>.</p>
<pre class="pod-block-code">say tanh(0.5);              # OUTPUT: «0.46211715726001␤»
say tanh(atanh(0.5));       # OUTPUT: «0.5␤»</pre>
<h2 id="(Cool)_routine_atanh"><a href="/Documentable/integration-test/type/Cool#routine_atanh">(Cool) routine atanh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub atanh(Numeric(Cool))
method atanh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_hyperbolic_function">Inverse tangent hyperbolicus</a>.</p>
<pre class="pod-block-code">say atanh(0.5);             # OUTPUT: «0.549306144334055␤»</pre>
<h2 id="(Cool)_routine_sech"><a href="/Documentable/integration-test/type/Cool#routine_sech">(Cool) routine sech</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub sech(Numeric(Cool))
method sech()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Secant hyperbolicus</a>.</p>
<pre class="pod-block-code">say 0.sech;                 # OUTPUT: «1␤»</pre>
<h2 id="(Cool)_routine_asech"><a href="/Documentable/integration-test/type/Cool#routine_asech">(Cool) routine asech</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub asech(Numeric(Cool))
method asech()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Inverse hyperbolic secant</a>.</p>
<pre class="pod-block-code">say 0.8.asech;              # OUTPUT: «0.693147180559945␤»</pre>
<h2 id="(Cool)_routine_cosech"><a href="/Documentable/integration-test/type/Cool#routine_cosech">(Cool) routine cosech</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cosech(Numeric(Cool))
method cosech()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Hyperbolic cosecant</a>.</p>
<pre class="pod-block-code">say cosech(pi/2);           # OUTPUT: «0.434537208094696␤»</pre>
<h2 id="(Cool)_routine_acosech"><a href="/Documentable/integration-test/type/Cool#routine_acosech">(Cool) routine acosech</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub acosech(Numeric(Cool))
method acosech()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_hyperbolic_function">Inverse hyperbolic cosecant</a>.</p>
<pre class="pod-block-code">say acosech(4.5);           # OUTPUT: «0.220432720979802␤»</pre>
<h2 id="(Cool)_routine_cotanh"><a href="/Documentable/integration-test/type/Cool#routine_cotanh">(Cool) routine cotanh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cotanh(Numeric(Cool))
method cotanh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Hyperbolic cotangent</a>.</p>
<pre class="pod-block-code">say cotanh(pi);             # OUTPUT: «1.00374187319732␤»</pre>
<h2 id="(Cool)_routine_acotanh"><a href="/Documentable/integration-test/type/Cool#routine_acotanh">(Cool) routine acotanh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub acotanh(Numeric(Cool))
method acotanh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_hyperbolic_function">Inverse hyperbolic cotangent</a>.</p>
<pre class="pod-block-code">say acotanh(2.5);           # OUTPUT: «0.423648930193602␤»</pre>
<h2 id="(Cool)_routine_cis"><a href="/Documentable/integration-test/type/Cool#routine_cis">(Cool) routine cis</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cis(Numeric(Cool))
method cis()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns <a href="https://en.wikipedia.org/wiki/Cis_%28mathematics%29">cos(argument) + i*sin(argument)</a>.</p>
<pre class="pod-block-code">say cis(pi/4);              # OUTPUT: «0.707106781186548+0.707106781186547i␤»</pre>
<h2 id="(Cool)_routine_log"><a href="/Documentable/integration-test/type/Cool#routine_log">(Cool) routine log</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub log(Numeric(Cool) $number, Numeric(Cool) $base?)
multi method log(Cool:D: Cool:D $base?)</pre>
<p>Coerces the arguments (including the invocant in the method form) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Logarithm">Logarithm</a> to base <code>$base</code>, or to base <code>e</code> (Euler&#39;s Number) if no base was supplied (<a href="https://en.wikipedia.org/wiki/Natural_logarithm">Natural logarithm</a>). Returns <code>NaN</code> if <code>$base</code> is negative. Throws an exception if <code>$base</code> is <code>1</code>.</p>
<pre class="pod-block-code">say (e*e).log;              # OUTPUT: «2␤»</pre>
<h2 id="(Cool)_routine_log10"><a href="/Documentable/integration-test/type/Cool#routine_log10">(Cool) routine log10</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub log10(Cool(Numeric))
multi method log10()</pre>
<p>Coerces the invocant (or in the sub form, the invocant) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Logarithm">Logarithm</a> to base 10, that is, a number that approximately produces the original number when raised to the power of 10. Returns <code>NaN</code> for negative arguments and <code>-Inf</code> for <code>0</code>.</p>
<pre class="pod-block-code">say log10(1001);            # OUTPUT: «3.00043407747932␤»</pre>
<h2 id="(Cool)_routine_log2"><a href="/Documentable/integration-test/type/Cool#routine_log2">(Cool) routine log2</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method log2()</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Logarithm">Logarithm</a> to base 2, that is, a number that approximately produces the original number when raised to the power of 2. Returns <code>NaN</code> for negative arguments and <code>-Inf</code> for <code>0</code>.</p>
<pre class="pod-block-code">say log2(5);            # OUTPUT: «2.321928094887362␤»
say &quot;4&quot;.log2;           # OUTPUT: «2␤»</pre>
<h2 id="(Cool)_routine_exp"><a href="/Documentable/integration-test/type/Cool#routine_exp">(Cool) routine exp</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub exp(Cool:D $pow, Cool:D $base?)
multi method exp(Cool:D: Cool:D $base?)</pre>
<p>Coerces the arguments (including the invocant in the method from) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns <code>$base</code> raised to the power of the first number. If no <code>$base</code> is supplied, <code>e</code> (Euler&#39;s Number) is used.</p>
<pre class="pod-block-code">say 0.exp;      # OUTPUT: «1␤»
say 1.exp;      # OUTPUT: «2.71828182845905␤»
say 10.exp;     # OUTPUT: «22026.4657948067␤»</pre>
<h2 id="(Cool)_method_unpolar"><a href="/Documentable/integration-test/type/Cool#method_unpolar">(Cool) method unpolar</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method unpolar(Numeric(Cool))</pre>
<p>Coerces the arguments (including the invocant in the method form) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns a complex number from the given polar coordinates. The invocant (or the first argument in sub form) is the magnitude while the argument (i.e. the second argument in sub form) is the angle. The angle is assumed to be in radians.</p>
<pre class="pod-block-code">say sqrt(2).unpolar(pi/4);      # OUTPUT: «1+1i␤»</pre>
<h2 id="(Cool)_routine_round"><a href="/Documentable/integration-test/type/Cool#routine_round">(Cool) routine round</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub round(Numeric(Cool))
multi method round(Cool:D: $unit = 1)</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and rounds it to the unit of <code>$unit</code>. If <code>$unit</code> is 1, rounds to the nearest integer.</p>
<pre class="pod-block-code">say 1.7.round;          # OUTPUT: «2␤»
say 1.07.round(0.1);    # OUTPUT: «1.1␤»
say 21.round(10);       # OUTPUT: «20␤»</pre>
<p>Always rounds <strong>up</strong> if the number is at mid-point:</p>
<pre class="pod-block-code">say (−.5 ).round;       # OUTPUT: «0␤»
say ( .5 ).round;       # OUTPUT: «1␤»
say (−.55).round(.1);   # OUTPUT: «-0.5␤»
say ( .55).round(.1);   # OUTPUT: «0.6␤»</pre>
<p><strong>Pay attention</strong> to types when using this method, as ending up with the wrong type may affect the precision you seek to achieve. For <a href="/Documentable/integration-test/type/Real">Real</a> types, the type of the result is the type of the argument (<a href="/Documentable/integration-test/type/Complex">Complex</a> argument gets coerced to <a href="/Documentable/integration-test/type/Real">Real</a>, ending up a <a href="/Documentable/integration-test/type/Num">Num</a>). If rounding a <a href="/Documentable/integration-test/type/Complex">Complex</a>, the result is <a href="/Documentable/integration-test/type/Complex">Complex</a> as well, regardless of the type of the argument.</p>
<pre class="pod-block-code">9930972392403501.round(1)      .raku.say; # OUTPUT: «9930972392403501␤»
9930972392403501.round(1e0)    .raku.say; # OUTPUT: «9.9309723924035e+15␤»
9930972392403501.round(1e0).Int.raku.say; # OUTPUT: «9930972392403500␤»</pre>
<h2 id="(Cool)_routine_floor"><a href="/Documentable/integration-test/type/Cool#routine_floor">(Cool) routine floor</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub floor(Numeric(Cool))
multi method floor</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and rounds it downwards to the nearest integer.</p>
<pre class="pod-block-code">say &quot;1.99&quot;.floor;       # OUTPUT: «1␤»
say &quot;-1.9&quot;.floor;       # OUTPUT: «-2␤»
say 0.floor;            # OUTPUT: «0␤»</pre>
<h2 id="(Cool)_method_fmt"><a href="/Documentable/integration-test/type/Cool#method_fmt">(Cool) method fmt</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method fmt($format = &#39;%s&#39;)</pre>
<p>Uses <code>$format</code> to return a formatted representation of the invocant; equivalent to calling <a href="/Documentable/integration-test/routine/sprintf">sprintf</a> with <code>$format</code> as format and the invocant as the second argument. The <code>$format</code> will be coerced to <a href="/Documentable/integration-test/type/Stringy">Stringy</a> and defaults to <code>&#39;%s&#39;</code>.</p>
<p>For more information about formats strings, see <a href="/Documentable/integration-test/routine/sprintf">sprintf</a>.</p>
<pre class="pod-block-code">say 11.fmt(&#39;This Int equals %03d&#39;);         # OUTPUT: «This Int equals 011␤»
say &#39;16&#39;.fmt(&#39;Hexadecimal %x&#39;);             # OUTPUT: «Hexadecimal 10␤»</pre>
<h2 id="(Cool)_routine_ceiling"><a href="/Documentable/integration-test/type/Cool#routine_ceiling">(Cool) routine ceiling</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub ceiling(Numeric(Cool))
multi method ceiling</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and rounds it upwards to the nearest integer.</p>
<pre class="pod-block-code">say &quot;1&quot;.ceiling;        # OUTPUT: «1␤»
say &quot;-0.9&quot;.ceiling;     # OUTPUT: «0␤»
say &quot;42.1&quot;.ceiling;     # OUTPUT: «43␤»</pre>
<h2 id="(Cool)_routine_truncate"><a href="/Documentable/integration-test/type/Cool#routine_truncate">(Cool) routine truncate</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub truncate(Numeric(Cool))
multi method truncate()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and rounds it towards zero.</p>
<pre class="pod-block-code">say 1.2.truncate;       # OUTPUT: «1␤»
say truncate -1.2;      # OUTPUT: «-1␤»</pre>
<h2 id="(Cool)_routine_ord"><a href="/Documentable/integration-test/type/Cool#routine_ord">(Cool) routine ord</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub ord(Str(Cool))
method ord()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the <a href="https://en.wikipedia.org/wiki/Code_point">Unicode code point</a> number of the first code point.</p>
<pre class="pod-block-code">say &#39;a&#39;.ord;            # OUTPUT: «97␤»</pre>
<p>The inverse operation is <a href="/Documentable/integration-test/routine/chr">chr</a>.</p>
<p>Mnemonic: returns an ordinal number</p>
<h2 id="(Cool)_method_path"><a href="/Documentable/integration-test/type/Cool#method_path">(Cool) method path</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method path()</pre>
<p><strong>DEPRECATED</strong>. <em>It&#39;s been deprecated as of the 6.d version. Will be removed in the next ones.</em></p>
<p>Stringifies the invocant and converts it to <a href="/Documentable/integration-test/type/IO::Path">IO::Path</a> object. Use the <a href="/Documentable/integration-test/routine/IO"><code>.IO method</code></a> instead.</p>
<h2 id="(Cool)_routine_chr"><a href="/Documentable/integration-test/type/Cool#routine_chr">(Cool) routine chr</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub chr(Int(Cool))
method chr()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Int">Int</a>, interprets it as a <a href="https://en.wikipedia.org/wiki/Code_point">Unicode code points</a>, and returns a <a href="/Documentable/integration-test/type/Str">string</a> made of that code point.</p>
<pre class="pod-block-code">say &#39;65&#39;.chr;       # OUTPUT: «A␤»</pre>
<p>The inverse operation is <a href="/Documentable/integration-test/routine/ord">ord</a>.</p>
<p>Mnemonic: turns an integer into a <em>char</em>acter.</p>
<h2 id="(Cool)_routine_chars"><a href="/Documentable/integration-test/type/Cool#routine_chars">(Cool) routine chars</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub chars(Cool $x)
multi sub chars(Str:D $x)
multi sub chars(str $x --&gt; int)
method chars(--&gt; Int:D)</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the number of characters in the string. Please note that on the JVM, you currently get codepoints instead of graphemes.</p>
<pre class="pod-block-code">say &#39;møp&#39;.chars;    # OUTPUT: «3␤»
say &#39;ã̷̠̬̊&#39;.chars;     # OUTPUT: «1␤»
say &#39;👨‍👩‍👧‍👦🏿&#39;.chars;    # OUTPUT: «1␤»</pre>
<p>If the string is native, the number of chars will be also returned as a native <code>int</code>.</p>
<p><a name="Documentable/integration-test/index-entry-Grapheme"></a></p>
<p>Graphemes are user visible characters. That is, this is what the user thinks of as a “character”.</p>
<p>Graphemes can contain more than one codepoint. Typically the number of graphemes and codepoints differs when <code>Prepend</code> or <code>Extend</code> characters are involved (also known as <a href="https://en.wikipedia.org/wiki/Combining_character">Combining characters</a>), but there are many other cases when this may happen. Another example is <code>\c[ZWJ]</code> (<a href="https://en.wikipedia.org/wiki/Zero-width_joiner">Zero-width joiner</a>).</p>
<p>You can check <code>Grapheme_Cluster_Break</code> property of a character in order to see how it is going to behave:</p>
<pre class="pod-block-code">say ‘ã̷̠̬̊’.uniprops(‘Grapheme_Cluster_Break’); # OUTPUT: «(Other Extend Extend Extend Extend)␤»
say ‘👨‍👩‍👧‍👦🏿’.uniprops(‘Grapheme_Cluster_Break’); # OUTPUT: «(E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ E_Modifier)␤»</pre>
<p>You can read more about graphemes in the <a href="https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">Unicode Standard</a>, which Raku tightly follows, using a method called <a href="/Documentable/integration-test/language/glossary#NFG">NFG, normal form graphemes</a> for efficiently representing them.</p>
<h2 id="(Cool)_routine_codes"><a href="/Documentable/integration-test/type/Cool#routine_codes">(Cool) routine codes</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub codes(Str(Cool))
method codes()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the number of <a href="https://en.wikipedia.org/wiki/Code_point">Unicode code points</a>.</p>
<pre class="pod-block-code">say &#39;møp&#39;.codes;    # OUTPUT: «3␤»</pre>
<p>The same result will be obtained with</p>
<pre class="pod-block-code">say +&#39;møp&#39;.ords;    # OUTPUT: «3␤»</pre>
<p><a href="/Documentable/integration-test/routine/ords">ords</a> first obtains the actual codepoints, so there might be a difference in speed.</p>
<h2 id="(Cool)_routine_flip"><a href="/Documentable/integration-test/type/Cool#routine_flip">(Cool) routine flip</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub flip(Cool $s --&gt; Str:D)
method flip()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns a reversed version.</p>
<pre class="pod-block-code">say 421.flip;       # OUTPUT: «124␤»</pre>
<h2 id="(Cool)_routine_trim"><a href="/Documentable/integration-test/type/Cool#routine_trim">(Cool) routine trim</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub trim(Str(Cool))
method trim()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the string with both leading and trailing whitespace stripped.</p>
<pre class="pod-block-code">my $stripped = &#39;  abc &#39;.trim;
say &quot;&lt;$stripped&gt;&quot;;          # OUTPUT: «&lt;abc&gt;␤»</pre>
<h2 id="(Cool)_routine_trim-leading"><a href="/Documentable/integration-test/type/Cool#routine_trim-leading">(Cool) routine trim-leading</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub trim-leading(Str(Cool))
method trim-leading()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the string with leading whitespace stripped.</p>
<pre class="pod-block-code">my $stripped = &#39;  abc &#39;.trim-leading;
say &quot;&lt;$stripped&gt;&quot;;          # OUTPUT: «&lt;abc &gt;␤»</pre>
<h2 id="(Cool)_routine_trim-trailing"><a href="/Documentable/integration-test/type/Cool#routine_trim-trailing">(Cool) routine trim-trailing</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub trim-trailing(Str(Cool))
method trim-trailing()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the string with trailing whitespace stripped.</p>
<pre class="pod-block-code">my $stripped = &#39;  abc &#39;.trim-trailing;
say &quot;&lt;$stripped&gt;&quot;;          # OUTPUT: «&lt;  abc&gt;␤»</pre>
<h2 id="(Cool)_routine_lc"><a href="/Documentable/integration-test/type/Cool#routine_lc">(Cool) routine lc</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub lc(Str(Cool))
method lc()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns it case-folded to lower case.</p>
<pre class="pod-block-code">say &quot;ABC&quot;.lc;       # OUTPUT: «abc␤»</pre>
<h2 id="(Cool)_routine_uc"><a href="/Documentable/integration-test/type/Cool#routine_uc">(Cool) routine uc</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub uc(Str(Cool))
method uc()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns it case-folded to upper case (capital letters).</p>
<pre class="pod-block-code">say &quot;Abc&quot;.uc;       # OUTPUT: «ABC␤»</pre>
<h2 id="(Cool)_routine_fc"><a href="/Documentable/integration-test/type/Cool#routine_fc">(Cool) routine fc</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub fc(Str(Cool))
method fc()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the result a Unicode &quot;case fold&quot; operation suitable for doing caseless string comparisons. (In general, the returned string is unlikely to be useful for any purpose other than comparison.)</p>
<pre class="pod-block-code">say &quot;groß&quot;.fc;       # OUTPUT: «gross␤»</pre>
<h2 id="(Cool)_routine_tc"><a href="/Documentable/integration-test/type/Cool#routine_tc">(Cool) routine tc</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub tc(Str(Cool))
method tc()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns it with the first letter case-folded to title case (or where not available, upper case).</p>
<pre class="pod-block-code">say &quot;abC&quot;.tc;       # OUTPUT: «AbC␤»</pre>
<h2 id="(Cool)_routine_tclc"><a href="/Documentable/integration-test/type/Cool#routine_tclc">(Cool) routine tclc</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub tclc(Str(Cool))
method tclc()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns it with the first letter case-folded to title case (or where not available, upper case), and the rest of the string case-folded to lower case.</p>
<pre class="pod-block-code">say &#39;abC&#39;.tclc;     # OUTPUT: «Abc␤»</pre>
<h2 id="(Cool)_routine_wordcase"><a href="/Documentable/integration-test/type/Cool#routine_wordcase">(Cool) routine wordcase</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub wordcase(Str(Cool) $input, :&amp;filter = &amp;tclc, Mu :$where = True)
method wordcase(:&amp;filter = &amp;tclc, Mu :$where = True)</pre>
<p>Coerces the invocant (or in sub form, the first argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and filters each word that smartmatches against <code>$where</code> through the <code>&amp;filter</code>. With the default filter (first character to upper case, rest to lower) and matcher (which accepts everything), this title-cases each word:</p>
<pre class="pod-block-code">say &quot;raku programming&quot;.wordcase;        # OUTPUT: «Raku Programming␤»</pre>
<p>With a matcher:</p>
<pre class="pod-block-code">say &quot;have fun working on perl&quot;.wordcase(:where({ .chars &gt; 3 }));
                                        # Have fun Working on Perl</pre>
<p>With a customer filter too:</p>
<pre class="pod-block-code">say &quot;have fun working on perl&quot;.wordcase(:filter(&amp;uc), :where({ .chars &gt; 3 }));
                                        # HAVE fun WORKING on PERL</pre>
<h2 id="(Cool)_routine_samecase"><a href="/Documentable/integration-test/type/Cool#routine_samecase">(Cool) routine samecase</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub samecase(Cool $string, Cool $pattern)
method samecase(Cool:D: Cool $pattern)</pre>
<p>Coerces the invocant (or in sub form, the first argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns a copy of <code>$string</code> with case information for each individual character changed according to <code>$pattern</code>.</p>
<p><strong>Note</strong>: The pattern string can contain three types of characters, i.e. uppercase, lowercase and caseless. For a given character in <code>$pattern</code> its case information determines the case of the corresponding character in the result.</p>
<p>If <code>$string</code> is longer than <code>$pattern</code>, the case information from the last character of <code>$pattern</code> is applied to the remaining characters of <code>$string</code>.</p>
<pre class="pod-block-code">say &quot;raKu&quot;.samecase(&quot;A_a_&quot;); # OUTPUT: «Raku␤»
say &quot;rAKU&quot;.samecase(&quot;Ab&quot;);   # OUTPUT: «Raku␤»</pre>
<h2 id="(Cool)_routine_uniprop"><a href="/Documentable/integration-test/type/Cool#routine_uniprop">(Cool) routine uniprop</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub uniprop(Str:D, |c)
multi sub uniprop(Int:D $code)
multi sub uniprop(Int:D $code, Stringy:D $propname)
multi method uniprop(|c)</pre>
<p>Returns the <a href="http://userguide.icu-project.org/strings/properties">unicode property</a> of the first character. If no property is specified returns the <a href="https://en.wikipedia.org/wiki/Unicode_character_property#General_Category">General Category</a>. Returns a Bool for Boolean properties. A <a href="/Documentable/integration-test/routine/uniprops">uniprops</a> routine can be used to get the property for every character in a string.</p>
<pre class="pod-block-code">say &#39;a&#39;.uniprop;               # OUTPUT: «Ll␤»
say &#39;1&#39;.uniprop;               # OUTPUT: «Nd␤»
say &#39;a&#39;.uniprop(&#39;Alphabetic&#39;); # OUTPUT: «True␤»
say &#39;1&#39;.uniprop(&#39;Alphabetic&#39;); # OUTPUT: «False␤»</pre>
<h2 id="(Cool)_sub_uniprops"><a href="/Documentable/integration-test/type/Cool#sub_uniprops">(Cool) sub uniprops</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub uniprops(Str:D $str, Stringy:D $propname = &quot;General_Category&quot;)</pre>
<p>Interprets the invocant as a <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the <a href="http://userguide.icu-project.org/strings/properties">unicode property</a> for each character as a Seq. If no property is specified returns the <a href="https://en.wikipedia.org/wiki/Unicode_character_property#General_Category">General Category</a>. Returns a Bool for Boolean properties. Similar to <a href="/Documentable/integration-test/routine/uniprop">uniprop</a>, but for each character in the passed string.</p>
<h2 id="(Cool)_routine_uniname"><a href="/Documentable/integration-test/type/Cool#routine_uniname">(Cool) routine uniname</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub uniname(Str(Cool) --&gt; Str)
method uniname(--&gt; Str)</pre>
<p>Interprets the invocant or first argument as a <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the Unicode codepoint name of the first codepoint of the first character. See <a href="/Documentable/integration-test/routine/uninames">uninames</a> for a routine that works with multiple codepoints, and <a href="/Documentable/integration-test/routine/uniparse">uniparse</a> for the opposite direction.</p>
<pre class="pod-block-code"># Camelia in Unicode
say ‘»ö«’.uniname;
# OUTPUT: «&quot;RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK&quot;␤»
say &quot;Ḍ̇&quot;.uniname; # Note, doesn&#39;t show &quot;COMBINING DOT ABOVE&quot;
# OUTPUT: «&quot;LATIN CAPITAL LETTER D WITH DOT BELOW&quot;␤»

# Find the char with the longest Unicode name.
say (0..0x1FFFF).sort(*.uniname.chars)[*-1].chr.uniname;
# OUTPUT: ««ARABIC LIGATURE UIGHUR KIRGHIZ YEH WITH HAMZA ABOVE WITH ALEF MAKSURA INITIAL FORM␤»␤»</pre>
<h2 id="(Cool)_routine_uninames"><a href="/Documentable/integration-test/type/Cool#routine_uninames">(Cool) routine uninames</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub uninames(Str:D)
method uninames()</pre>
<p>Returns of a Seq of Unicode names for the all the codepoints in the Str provided.</p>
<pre class="pod-block-code">say ‘»ö«’.uninames.raku;
# OUTPUT: «(&quot;RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK&quot;, &quot;LATIN SMALL LETTER O WITH DIAERESIS&quot;, &quot;LEFT-POINTING DOUBLE ANGLE QUOTATION MARK&quot;).Seq␤»</pre>
<p>Note this example, which gets a Seq where each element is a Seq of all the codepoints in that character.</p>
<pre class="pod-block-code">say &quot;Ḍ̇&#39;oh&quot;.comb&gt;&gt;.uninames.raku;
# OUTPUT: «((&quot;LATIN CAPITAL LETTER D WITH DOT BELOW&quot;, &quot;COMBINING DOT ABOVE&quot;).Seq, (&quot;APOSTROPHE&quot;,).Seq, (&quot;LATIN SMALL LETTER O&quot;,).Seq, (&quot;LATIN SMALL LETTER H&quot;,).Seq)␤»</pre>
<p>See <a href="/Documentable/integration-test/routine/uniparse">uniparse</a> for the opposite direction.</p>
<h2 id="(Cool)_routine_unimatch"><a href="/Documentable/integration-test/type/Cool#routine_unimatch">(Cool) routine unimatch</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub unimatch(Str:D $str, |c)
multi unimatch(Int:D $code, Stringy:D $pvalname, Stringy:D $propname = $pvalname)</pre>
<p>Checks if the given integer codepoint or the first letter of the given string has a unicode property equal to the value you give. If you supply the Unicode property to be checked it will only return True if that property matches the given value.</p>
<pre class="pod-block-code">say unimatch &#39;A&#39;, &#39;Latin&#39;;           # OUTPUT: «True␤»
say unimatch &#39;A&#39;, &#39;Latin&#39;, &#39;Script&#39;; # OUTPUT: «True␤»
say unimatch &#39;A&#39;, &#39;Ll&#39;;              # OUTPUT: «False␤»</pre>
<p>The last property corresponds to &quot;lowercase letter&quot;, which explains why it returns false.</p>
<h2 id="(Cool)_routine_chop"><a href="/Documentable/integration-test/type/Cool#routine_chop">(Cool) routine chop</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub chop(Str(Cool))
method chop()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns it with the last character removed.</p>
<pre class="pod-block-code">say &#39;perl&#39;.chop;                        # OUTPUT: «per␤»</pre>
<h2 id="(Cool)_routine_chomp"><a href="/Documentable/integration-test/type/Cool#routine_chomp">(Cool) routine chomp</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub chomp(Str(Cool))
method chomp()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns it with the last character removed, if it is a logical newline.</p>
<pre class="pod-block-code">say &#39;ab&#39;.chomp.chars;                   # OUTPUT: «2␤»
say &quot;a\n&quot;.chomp.chars;                  # OUTPUT: «1␤»</pre>
<h2 id="(Cool)_routine_substr"><a href="/Documentable/integration-test/type/Cool#routine_substr">(Cool) routine substr</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub substr(Str(Cool) $str, |c)
method substr(|c)</pre>
<p>Coerces the invocant (or in the sub form, the first argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and calls <a href="/Documentable/integration-test/type/Str#routine_substr">Str.substr</a> with the arguments.</p>
<h2 id="(Cool)_routine_substr-rw"><a href="/Documentable/integration-test/type/Cool#routine_substr-rw">(Cool) routine substr-rw</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method substr-rw(|) is rw
multi sub substr-rw(|) is rw</pre>
<p>Coerces the invocant (or in the sub form, the first argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and calls <a href="/Documentable/integration-test/type/Str#routine_substr-rw">Str.substr-rw</a> with the arguments.</p>
<h2 id="(Cool)_routine_ords"><a href="/Documentable/integration-test/type/Cool#routine_ords">(Cool) routine ords</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub ords(Str(Cool) $str)
method ords()</pre>
<p>Coerces the invocant (or in the sub form, the first argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns a list of Unicode codepoints for each character.</p>
<pre class="pod-block-code">say &quot;Camelia&quot;.ords;              # OUTPUT: «67 97 109 101 108 105 97␤»
say ords 10;                     # OUTPUT: «49 48␤»</pre>
<p>This is the list-returning version of <a href="/Documentable/integration-test/routine/ord">ord</a>. The inverse operation in <a href="/Documentable/integration-test/routine/chrs">chrs</a>. If you are only interested in the number of codepoints, <a href="/Documentable/integration-test/routine/codes">codes</a> is a possibly faster option.</p>
<h2 id="(Cool)_routine_chrs"><a href="/Documentable/integration-test/type/Cool#routine_chrs">(Cool) routine chrs</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub chrs(*@codepoints --&gt; Str:D)
method chrs()</pre>
<p>Coerces the invocant (or in the sub form, the argument list) to a list of integers, and returns the string created by interpreting each integer as a Unicode codepoint, and joining the characters.</p>
<pre class="pod-block-code">say &lt;67 97 109 101 108 105 97&gt;.chrs;   # OUTPUT: «Camelia␤»</pre>
<p>This is the list-input version of <a href="/Documentable/integration-test/routine/chr">chr</a>. The inverse operation is <a href="/Documentable/integration-test/routine/ords">ords</a>.</p>
<h2 id="(Cool)_routine_split"><a href="/Documentable/integration-test/type/Cool#routine_split">(Cool) routine split</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub    split(  Str:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
multi sub    split(Regex:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
multi sub    split(@delimiters, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
multi method split(  Str:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
multi method split(Regex:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
multi method split(@delimiters, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)</pre>
<p><a href="#fn-1" id="fn-ref-1">[1]</a></p>
<p>Coerces the invocant (or in the sub form, the second argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and splits it into pieces based on delimiters found in the string.</p>
<p>If <code>$delimiter</code> is a string, it is searched for literally and not treated as a regex. You can also provide multiple delimiters by specifying them as a list; mixing Cool and Regex objects is OK.</p>
<pre class="pod-block-code">say split(&#39;;&#39;, &quot;a;b;c&quot;).raku;               # OUTPUT: «(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)␤»
say split(&#39;;&#39;, &quot;a;b;c&quot;, 2).raku;            # OUTPUT: «(&quot;a&quot;, &quot;b;c&quot;).Seq␤»

say split(&#39;;&#39;, &quot;a;b;c,d&quot;).raku;             # OUTPUT: «(&quot;a&quot;, &quot;b&quot;, &quot;c,d&quot;)␤»
say split(/\;/, &quot;a;b;c,d&quot;).raku;            # OUTPUT: «(&quot;a&quot;, &quot;b&quot;, &quot;c,d&quot;)␤»
say split(/&lt;[;,]&gt;/, &quot;a;b;c,d&quot;).raku;        # OUTPUT: «(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)␤»

say split([&#39;a&#39;, /b+/, 4], &#39;1a2bb345&#39;).raku; # OUTPUT: «(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;5&quot;)␤»</pre>
<p>By default, split omits the matches, and returns a list of only those parts of the string that did not match. Specifying one of the <code>:k, :v, :kv, :p</code> adverbs changes that. Think of the matches as a list that is interleaved with the non-matching parts.</p>
<p>The <code>:v</code> interleaves the values of that list, which will be either <a href="/Documentable/integration-test/type/Match">Match</a> objects, if a <a href="/Documentable/integration-test/type/Regex">Regex</a> was used as a matcher in the split, or <a href="/Documentable/integration-test/type/Str">Str</a> objects, if a <a href="/Documentable/integration-test/type/Cool">Cool</a> was used as matcher. If multiple delimiters are specified, <a href="/Documentable/integration-test/type/Match">Match</a> objects will be generated for all of them, unless <strong>all</strong> of the delimiters are <a href="/Documentable/integration-test/type/Cool">Cool</a>.</p>
<pre class="pod-block-code">say &#39;abc&#39;.split(/b/, :v);               # OUTPUT: «(a ｢b｣ c)␤»
say &#39;abc&#39;.split(&#39;b&#39;, :v);               # OUTPUT: «(a b c)␤»</pre>
<p><code>:k</code> interleaves the keys, that is, the indexes:</p>
<pre class="pod-block-code">say &#39;abc&#39;.split(/b/, :k);               # OUTPUT: «(a 0 c)␤»</pre>
<p><code>:kv</code> adds both indexes and matches:</p>
<pre class="pod-block-code">say &#39;abc&#39;.split(/b/, :kv);               # OUTPUT: «(a 0 ｢b｣ c)␤»</pre>
<p>and <code>:p</code> adds them as <a href="/Documentable/integration-test/type/Pair">Pairs</a>, using the same types for values as <code>:v</code> does:</p>
<pre class="pod-block-code">say &#39;abc&#39;.split(/b/, :p);               # OUTPUT: «(a 0 =&gt; ｢b｣ c)␤»
say &#39;abc&#39;.split(&#39;b&#39;, :p);               # OUTPUT: «(a 0 =&gt; b c)␤»</pre>
<p>You can only use one of the <code>:k, :v, :kv, :p</code> adverbs in a single call to <code>split</code>.</p>
<p>Note that empty chunks are not removed from the result list. For that behavior, use the <code>:skip-empty</code> named argument:</p>
<pre class="pod-block-code">say (&quot;f,,b,c,d&quot;.split: /&quot;,&quot;/             ).raku;  # OUTPUT: «(&quot;f&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)␤»
say (&quot;f,,b,c,d&quot;.split: /&quot;,&quot;/, :skip-empty).raku;  # OUTPUT: «(&quot;f&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)␤»</pre>
<h2 id="(Cool)_routine_lines"><a href="/Documentable/integration-test/type/Cool#routine_lines">(Cool) routine lines</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub lines(Str(Cool))
method lines()</pre>
<p>Coerces the invocant (and in sub form, the argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, decomposes it into lines (with the newline characters stripped), and returns the list of lines.</p>
<pre class="pod-block-code">say lines(&quot;a\nb\n&quot;).join(&#39;|&#39;);          # OUTPUT: «a|b␤»
say &quot;some\nmore\nlines&quot;.lines.elems;    # OUTPUT: «3␤»</pre>
<p>This method can be used as part of an <code>IO::Path</code> to process a file line-by-line, since <code>IO::Path</code> objects inherit from <code>Cool</code>, e.g.:</p>
<pre class="pod-block-code">for &#39;huge-csv&#39;.IO.lines -&gt; $line {
    # Do something with $line
}

# or if you&#39;ll be processing later
my @lines = &#39;huge-csv&#39;.IO.lines;
</pre>
<p>Without any arguments, sub <code>lines</code> operates on <code>$*ARGFILES</code>, which defaults to <code>$*IN</code> in the absence of any filenames.</p>
<p>To modify values in place use <code>is copy</code> to force a writable container.</p>
<pre class="pod-block-code">for $*IN.lines -&gt; $_ is copy { s/(\w+)/{$0 ~ $0}/; .say }
</pre>
<h2 id="(Cool)_method_words"><a href="/Documentable/integration-test/type/Cool#method_words">(Cool) method words</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method words(Cool:D: |c)</pre>
<p>Coerces the invocant (or first argument, if it is called as a subroutine) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns a list of words that make up the string. Check <a href="/Documentable/integration-test/type/Str#routine_words"><code>Str.words</code></a> for additional arguments and its meaning.</p>
<pre class="pod-block-code">say &lt;The quick brown fox&gt;.words.join(&#39;|&#39;);     # OUTPUT: «The|quick|brown|fox␤»
say &lt;The quick brown fox&gt;.words(2).join(&#39;|&#39;);  # OUTPUT: «The|quick␤»
</pre>
<p><code>Cool</code> is the base class for many other classes, and some of them, like <a href="/Documentable/integration-test/type/Match">Match</a>, can be converted to a string. This is what happens in this case:</p>
<pre class="pod-block-code">say ( &quot;easy come, easy goes&quot; ~~ m:g/(ea\w+)/).words(Inf);
# OUTPUT: «(easy easy)␤»
say words( &quot;easy come, easy goes&quot; ~~ m:g/(ea\w+)/ , ∞);
# OUTPUT: «(easy easy)␤»</pre>
<p>The example above illustrates two of the ways <code>words</code> can be invoked, with the first argument turned into invocant by its signature. Of course, <code>Inf</code> is the default value of the second argument, so in both cases (and forms) it can be simply omitted.</p>
<p>Only whitespace (including no-break space) counts as word boundaries</p>
<pre class="pod-block-code">say &lt;Flying on a Boeing&nbsp;747&gt;.words.join(&#39;|&#39;);  # OUTPUT: «Flying|on|a|Boeing|747␤»</pre>
<p>In this case, &quot;Boeing&nbsp;747&quot; includes a (visible only in the source) no-break space; <code>words</code> still splits the (resulting) <code>Str</code> on it, even if the original array only had 4 elements:</p>
<pre class="pod-block-code">say &lt;Flying on a Boeing&nbsp;747&gt;.join(&#39;|&#39;);        # OUTPUT: «Flying|on|a|Boeing&nbsp;747␤»</pre>
<p>Please see <a href="/Documentable/integration-test/type/Str#routine_words"><code>Str.words</code></a> for more examples and ways to invoke it.</p>
<h2 id="(Cool)_routine_comb"><a href="/Documentable/integration-test/type/Cool#routine_comb">(Cool) routine comb</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub comb(Regex $matcher, Cool $input, $limit = *)
multi sub comb(Str $matcher, Cool $input, $limit = *)
multi sub comb(Int:D $size, Cool $input, $limit = *)
multi method comb(|c)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Seq">Seq</a> of all (or if supplied, at most <code>$limit</code>) matches of the invocant (method form) or the second argument (sub form) against the <a href="/Documentable/integration-test/type/Regex">Regex</a>, string or defined number.</p>
<pre class="pod-block-code">say &quot;6 or 12&quot;.comb(/\d+/).join(&quot;, &quot;);           # OUTPUT: «6, 12␤»
say comb(/\d &lt;[1..9]&gt; /,(11..30)).join(&quot;--&quot;);
# OUTPUT:
# «11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29␤»</pre>
<p>The second statement exemplifies the first form of <code>comb</code>, with a <code>Regex</code> that excludes multiples of ten, and a <code>Range</code> (which is <code>Cool</code>) as <code>$input</code>. <code>comb</code> stringifies the <code>Range</code> before applying <code>.comb</code> on the resulting string. Check <a href="/Documentable/integration-test/type/Str#routine_comb"><code>Str.comb</code></a> for its effect on different kind of input strings. When the first argument is an integer, it indicates the (maximum) size of the chunks the input is going to be divided in</p>
<pre class="pod-block-code">say comb(3,[3,33,333,3333]).join(&quot;*&quot;);  # OUTPUT: «3 3*3 3*33 *333*3␤»</pre>
<p>In this case the input is a list, which after transformation to <code>Str</code> (which includes the spaces) is divided in chunks of size 3.</p>
<h2 id="(Cool)_method_contains"><a href="/Documentable/integration-test/type/Cool#method_contains">(Cool) method contains</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method contains(Cool:D: |c)</pre>
<p>Coerces the invocant to a <a href="/Documentable/integration-test/type/Str"><code>Str</code></a>, and calls <a href="/Documentable/integration-test/type/Str#method_contains"><code>Str.contains</code></a> on it. Please refer to that version of the method for arguments and general syntax.</p>
<pre class="pod-block-code">say 123.contains(&quot;2&quot;)# OUTPUT: «True␤»</pre>
<p>Since <a href="/Documentable/integration-test/type/Int">Int</a> is a subclass of <code>Cool</code>, <code>123</code> is coerced to a <code>Str</code> and then <code>contains</code> is called on it.</p>
<pre class="pod-block-code">say (1,1, * + * … * &gt; 250).contains(233)# OUTPUT: «True␤»</pre>
<p><a href="/Documentable/integration-test/type/Seq">Seq</a>s are also subclasses of <code>Cool</code>, and they are stringified to a comma-separated form. In this case we are also using an <code>Int</code>, which is going to be stringified also; <code>&quot;233&quot;</code> is included in that sequence, so it returns <code>True</code>. Please note that this sequence is not lazy; the stringification of lazy sequences does not include each and every one of their components for obvious reasons.</p>
<h2 id="(Cool)_routine_index"><a href="/Documentable/integration-test/type/Cool#routine_index">(Cool) routine index</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub index(Cool:D $s, Cool:D $needle, :i(:$ignorecase), :m(:$ignoremark) --&gt; Int:D)
multi sub index(Cool:D $s, Cool:D $needle, Cool:D $pos, :i(:$ignorecase), :m(:$ignoremark) --&gt; Int:D)
multi method index(Cool:D: Cool:D $needle --&gt; Int:D)
multi method index(Cool:D: Cool:D $needle, :m(:$ignoremark)! --&gt; Int:D)
multi method index(Cool:D: Cool:D $needle, :i(:$ignorecase)!, :m(:$ignoremark) --&gt; Int:D)
multi method index(Cool:D: Cool:D $needle, Cool:D $pos --&gt; Int:D)
multi method index(Cool:D: Cool:D $needle, Cool:D $pos, :m(:$ignoremark)!  --&gt; Int:D)
multi method index(Cool:D: Cool:D $needle, Cool:D $pos, :i(:$ignorecase)!, :m(:$ignoremark) --&gt; Int:D)</pre>
<p>Coerces the first two arguments (in method form, also counting the invocant) to a <a href="/Documentable/integration-test/type/Str">Str</a>, and searches for <code>$needle</code> in the string <code>$s</code> starting from <code>$pos</code>. It returns the offset into the string where <code>$needle</code> was found, and <code>Nil</code> if it was not found.</p>
<p>See <a href="/Documentable/integration-test/type/Str#routine_index">the documentation in type Str</a> for examples.</p>
<h2 id="(Cool)_routine_rindex"><a href="/Documentable/integration-test/type/Cool#routine_rindex">(Cool) routine rindex</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub rindex(Cool:D $s, Cool:D $needle --&gt; Int:D)
multi sub rindex(Cool:D $s, Cool:D $needle, Cool:D $pos --&gt; Int:D)
multi method rindex(Cool:D: Cool:D $needle --&gt; Int:D)
multi method rindex(Cool:D: Cool:D $needle, Cool:D $pos --&gt; Int:D)</pre>
<p>Coerces the first two arguments (including the invocant in method form) to <a href="/Documentable/integration-test/type/Str">Str</a> and <code>$pos</code> to <a href="/Documentable/integration-test/type/Int">Int</a>, and returns the last position of <code>$needle</code> in the string not after <code>$pos</code>. Returns <code>Nil</code> if <code>$needle</code> wasn&#39;t found.</p>
<p>See <a href="/Documentable/integration-test/type/Str#routine_rindex">the documentation in type Str</a> for examples.</p>
<h2 id="(Cool)_method_match"><a href="/Documentable/integration-test/type/Cool#method_match">(Cool) method match</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method match(Cool:D: $target, *%adverbs)</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Str">Str</a> and calls the method <a href="/Documentable/integration-test/type/Str#method_match">match</a> on it.</p>
<h2 id="(Cool)_routine_roots"><a href="/Documentable/integration-test/type/Cool#routine_roots">(Cool) routine roots</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub roots(Numeric(Cool) $x, Int(Cool) $n)
multi method roots(Int(Cool) $n)</pre>
<p>Coerces the first argument (and in method form, the invocant) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> and the second (<code>$n</code>) to <a href="/Documentable/integration-test/type/Int">Int</a>, and produces a list of <code>$n</code> <a href="/Documentable/integration-test/type/Complex">Complex</a> <code>$n</code>-roots, which means numbers that, raised to the <code>$n</code>th power, approximately produce the original number.</p>
<p>For example</p>
<pre class="pod-block-code">my $original = 16;
my @roots = $original.roots(4);
say @roots;

for @roots -&gt; $r {
    say abs($r ** 4 - $original);
}

# OUTPUT:«2+0i 1.22464679914735e-16+2i -2+2.44929359829471e-16i -3.67394039744206e-16-2i␤»
# OUTPUT:«1.77635683940025e-15␤»
# OUTPUT:«4.30267170434156e-15␤»
# OUTPUT:«8.03651692704705e-15␤»
# OUTPUT:«1.04441561648202e-14␤»
</pre>
<h2 id="(Cool)_method_match"><a href="/Documentable/integration-test/type/Cool#method_match">(Cool) method match</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method match(|)</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Stringy">Stringy</a> and calls <a href="/Documentable/integration-test/type/Str#method_match">Str.match</a>.</p>
<h2 id="(Cool)_method_subst"><a href="/Documentable/integration-test/type/Cool#method_subst">(Cool) method subst</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method subst(|)</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Stringy">Stringy</a> and calls <a href="/Documentable/integration-test/type/Str#method_subst">Str.subst</a>.</p>
<h2 id="(Cool)_method_trans"><a href="/Documentable/integration-test/type/Cool#method_trans">(Cool) method trans</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method trans(|)</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Str">Str</a> and calls <a href="/Documentable/integration-test/type/Str#method_trans">Str.trans</a></p>
<h2 id="(Cool)_method_IO"><a href="/Documentable/integration-test/type/Cool#method_IO">(Cool) method IO</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method IO(--&gt; IO::Path:D)</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/IO::Path">IO::Path</a>.</p>
<pre class="pod-block-code">.say for &#39;.&#39;.IO.dir;        # gives a directory listing
</pre>
<h1 id="Routines_supplied_by_role_Positional"><a class="u" href="#___top" title="go to top of document">Routines supplied by role Positional</a></h1>
<p>Slip inherits from class <a href="/Documentable/integration-test/type/List">List</a>, which does role <a href="/Documentable/integration-test/type/Positional">Positional</a>, which provides the following routines:</p>
<h2 id="(Positional)_method_of"><a href="/Documentable/integration-test/type/Positional#method_of">(Positional) method of</a></h2>
<pre class="pod-block-code">method of()</pre>
<p>Returns the type constraint for elements of the positional container. Defaults to <a href="/Documentable/integration-test/type/Mu">Mu</a>.</p>
<h2 id="(Positional)_method_elems"><a href="/Documentable/integration-test/type/Positional#method_elems">(Positional) method elems</a></h2>
<pre class="pod-block-code">method elems()</pre>
<p>Should return the number of available elements in the instantiated object.</p>
<h2 id="(Positional)_method_AT-POS"><a href="/Documentable/integration-test/type/Positional#method_AT-POS">(Positional) method AT-POS</a></h2>
<pre class="pod-block-code">method AT-POS(\position)</pre>
<p>Should return the value / container at the given position.</p>
<h2 id="(Positional)_method_EXISTS-POS"><a href="/Documentable/integration-test/type/Positional#method_EXISTS-POS">(Positional) method EXISTS-POS</a></h2>
<pre class="pod-block-code">method EXISTS-POS(\position)</pre>
<p>Should return a <code>Bool</code> indicating whether the given position actually has a value.</p>
<h2 id="(Positional)_method_STORE"><a href="/Documentable/integration-test/type/Positional#method_STORE">(Positional) method STORE</a></h2>
<pre class="pod-block-code">method STORE(\values, :$initialize)</pre>
<p>This method should only be supplied if you want to support the:</p>
<pre class="pod-block-code">my @a is Foo = 1,2,3;
</pre>
<p>syntax for binding your implementation of the <code>Positional</code> role.</p>
<p>Should accept the values to (re-)initialize the object with. The optional named parameter will contain a <code>True</code> value when the method is called on the object for the first time. Should return the invocant.</p>
<h1 id="Routines_supplied_by_role_Iterable"><a class="u" href="#___top" title="go to top of document">Routines supplied by role Iterable</a></h1>
<p>Slip inherits from class <a href="/Documentable/integration-test/type/List">List</a>, which does role <a href="/Documentable/integration-test/type/Iterable">Iterable</a>, which provides the following routines:</p>
<h2 id="(Iterable)_method_iterator"><a href="/Documentable/integration-test/type/Iterable#method_iterator">(Iterable) method iterator</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method iterator(--&gt; Iterator:D)</pre>
<p>Method stub that ensures all classes doing the <code>Iterable</code> role have a method <code>iterator</code>.</p>
<p>It is supposed to return an <a href="/Documentable/integration-test/type/Iterator">Iterator</a>.</p>
<pre class="pod-block-code">say (1..10).iterator;</pre>
<h2 id="(Iterable)_method_flat"><a href="/Documentable/integration-test/type/Iterable#method_flat">(Iterable) method flat</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method flat(--&gt; Iterable)</pre>
<p>Returns another <a href="/Documentable/integration-test/type/Iterable">Iterable</a> that flattens out all iterables that the first one returns.</p>
<p>For example</p>
<pre class="pod-block-code">say (&lt;a b&gt;, &#39;c&#39;).elems;         # OUTPUT: «2␤»
say (&lt;a b&gt;, &#39;c&#39;).flat.elems;    # OUTPUT: «3␤»</pre>
<p>because <code>&lt;a b&gt; </code> is a <a href="/Documentable/integration-test/type/List">List</a> and thus iterable, so <code> (&lt;a b&gt;, &#39;c&#39;).flat </code> returns <code>(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code>, which has three elems.</p>
<p>Note that the flattening is recursive, so <code>(((&quot;a&quot;, &quot;b&quot;), &quot;c&quot;), &quot;d&quot;).flat</code> returns <code>(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</code>, but it does not flatten itemized sublists:</p>
<pre class="pod-block-code">say ($(&#39;a&#39;, &#39;b&#39;), &#39;c&#39;).raku;    # OUTPUT: «($(&quot;a&quot;, &quot;b&quot;), &quot;c&quot;)␤»</pre>
<p>You can use the <a href="/Documentable/integration-test/language/operators#index-entry-postfix_»..html">hyper method call</a> to call the <a href="/Documentable/integration-test/routine/List"><code>.List</code></a> method on all the inner itemized sublists and so de-containerize them, so that <code>flat</code> can flatten them:</p>
<pre class="pod-block-code">say ($(&#39;a&#39;, &#39;b&#39;), &#39;c&#39;)&gt;&gt;.List.flat.elems;    # OUTPUT: «3␤»</pre>
<h2 id="(Iterable)_method_lazy"><a href="/Documentable/integration-test/type/Iterable#method_lazy">(Iterable) method lazy</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method lazy(--&gt; Iterable)</pre>
<p>Returns a lazy iterable wrapping the invocant.</p>
<pre class="pod-block-code">say (1 ... 1000).is-lazy;      # OUTPUT: «False␤»
say (1 ... 1000).lazy.is-lazy; # OUTPUT: «True␤»</pre>
<h2 id="(Iterable)_method_hyper"><a href="/Documentable/integration-test/type/Iterable#method_hyper">(Iterable) method hyper</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method hyper(Int(Cool) :$batch = 64, Int(Cool) :$degree = 4)</pre>
<p>Returns another Iterable that is potentially iterated in parallel, with a given batch size and degree of parallelism.</p>
<p>The order of elements is preserved.</p>
<pre class="pod-block-code">say ([1..100].hyper.map({ $_ +1 }).list);</pre>
<p>Use <code>hyper</code> in situations where it is OK to do the processing of items in parallel, and the output order should be kept relative to the input order. See <a href="/Documentable/integration-test/routine/race"><code>race</code></a> for situations where items are processed in parallel and the output order does not matter.</p>
<h3 id="Options_degree_and_batch"><a class="u" href="#___top" title="go to top of document">Options degree and batch</a></h3>
<p>The <code>degree</code> option (short for &quot;degree of parallelism&quot;) configures how many parallel workers should be started. To start 4 workers (e.g. to use at most 4 cores), pass <code>:4degree</code> to the <code>hyper</code> or <code>race</code> method. Note that in some cases, choosing a degree higher than the available CPU cores can make sense, for example I/O bound work or latency-heavy tasks like web crawling. For CPU-bound work, however, it makes no sense to pick a number higher than the CPU core count.</p>
<p>The <code>batch</code> size option configures the number of items sent to a given parallel worker at once. It allows for making a throughput/latency trade-off. If, for example, an operation is long-running per item, and you need the first results as soon as possible, set it to 1. That means every parallel worker gets 1 item to process at a time, and reports the result as soon as possible. In consequence, the overhead for inter-thread communication is maximized. In the other extreme, if you have 1000 items to process and 10 workers, and you give every worker a batch of 100 items, you will incur minimal overhead for dispatching the items, but you will only get the first results when 100 items are processed by the fastest worker (or, for <code>hyper</code>, when the worker getting the first batch returns.) Also, if not all items take the same amount of time to process, you might run into the situation where some workers are already done and sit around without being able to help with the remaining work. In situations where not all items take the same time to process, and you don&#39;t want too much inter-thread communication overhead, picking a number somewhere in the middle makes sense. Your aim might be to keep all workers about evenly busy to make best use of the resources available.</p>
<p>You can also check out this <strong><a href="https://6guts.wordpress.com/2017/03/16/considering-hyperrace-semantics/">blog post on the semantics of hyper and race</a></strong></p>
<h2 id="(Iterable)_method_race"><a href="/Documentable/integration-test/type/Iterable#method_race">(Iterable) method race</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method race(Int(Cool) :$batch = 64, Int(Cool) :$degree = 4 --&gt; Iterable)</pre>
<p>Returns another Iterable that is potentially iterated in parallel, with a given batch size and degree of parallelism (number of parallel workers).</p>
<p>Unlike <a href="/Documentable/integration-test/routine/hyper"><code>hyper</code></a>, <code>race</code> does not preserve the order of elements.</p>
<pre class="pod-block-code">say ([1..100].race.map({ $_ +1 }).list);</pre>
<p>Use race in situations where it is OK to do the processing of items in parallel, and the output order does not matter. See <a href="/Documentable/integration-test/routine/hyper"><code>hyper</code></a> for situations where you want items processed in parallel and the output order should be kept relative to the input order.</p>
<p><strong><a href="https://6guts.wordpress.com/2017/03/16/considering-hyperrace-semantics/">Blog post on the semantics of hyper and race</a></strong></p>
<p>See <a href="/Documentable/integration-test/routine/hyper"><code>hyper</code></a> for an explanation of <code>:$batch</code> and <code>:$degree</code>.</p>

        </div>
    </div>

    <aside><ol start="1">
<li><a href="#fn-ref-1" id="fn-1">[↑]</a> <em>the <a href="/Documentable/integration-test/routine/comb">comb</a> routine is a much better choice for many tasks that in other languages are handled by the <code>split</code>.</em> </li>
</ol></aside>


    <footer class="pretty-box yellow">
        <p>
            Generated from <a href="https://github.com/Raku/doc/tree/master/docs/Type/Slip.pod6">https://github.com/Raku/doc/tree/master/docs/Type/Slip.pod6</a>.
        </p>
        <p>
            This is a work in progress to document Raku (formerly known as Perl 6), and
            known to be incomplete.
        </p>
        <p>
            <a href="https://github.com/raku/doc/blob/master/CONTRIBUTING.md#reporting-bugs">
                Please report any issues
            </a>
            Your contribution is appreciated.
        </p>
        <p>
            This documentation is provided under the terms of the
            <a href="https://raw.githubusercontent.com/raku/doc/master/LICENSE">
                Artistic License 2.0
            </a>. The Camelia image is
            <a href="https://raw.githubusercontent.com/raku/mu/master/misc/camelia.txt">
                copyright © 2009 by Larry Wall.
            </a>
            <!-- CREDITS -->
            <!--External Link Image by Zapyon, CCA-SA 4.0. Derived from Wikimedia Foundation https://commons.wikimedia.org/wiki/File:External-link-04-bold-12x12.svg -->
        </p>
    </footer>

    <script type="text/javascript" src="/Documentable/integration-test/js/app.js?v=1"></script>
    <script type="text/javascript" src="/Documentable/integration-test/js/search.js?v=3"></script>
</body>
</html>


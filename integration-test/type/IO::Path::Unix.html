<!doctype html>
<html lang="en">
<head>
    <title>class IO::Path::Unix</title>
    <meta charset="UTF-8"/>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <link rel="icon" href="/Documentable/integration-test/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" type="text/css" href="/Documentable/integration-test/css/app.css" media="screen" title="default" />
    <noscript> <style> #search { visibility: hidden; } </style> </noscript>
</head>

<body class="pod">

    <div id="___top"></div>

    <div id="header" class="pretty-box green">

        <a href="/Documentable/integration-test/">
            <img src="/Documentable/integration-test/images/Camelia.svg"alt="»ö«"id="logo"width="62"height="48"/> &nbsp;Raku Documentation
        </a>

        <div id="search" class="ui-widget">
            <div class="green">
                <input placeholder="Loading..." id="query" accesskey="f" title="Enter term to search for (hit Esc to focus)"/>
            </div>
            <p id="not-found-message">
                Not in Index (<a href="" id="try-web-search">try site search</a>)
            </p>
        </div>
        
        <div class="menu">
            
            <div class="menu-items dark-green">
                <a class='menu-item darker-green' href='https://raku.org'><strong>Raku homepage</strong></a>
                    <a class="menu-item " href="/Documentable/integration-test/language.html"> Language </a>
                    <a class="menu-item selected darker-green" href="/Documentable/integration-test/type.html"> Types </a>
                    <a class="menu-item " href="/Documentable/integration-test/routine.html"> Routines </a>
                    <a class="menu-item " href="https://webchat.freenode.net/?channels=#raku"> Chat with us </a>
            </div>
            
            <div class="menu-items darker-green"><div class="menu-items darker-green"><div class="menu-items darker-green"><div class="menu-items darker-green">
                    <a class="menu-item" href="/Documentable/integration-test/type.html"> All </a>
                    <a class="menu-item" href="/Documentable/integration-test/type-basic.html"> Basic </a>
                    <a class="menu-item" href="/Documentable/integration-test/type-html-generation.html"> HTML Generation </a>
                    <a class="menu-item" href="/Documentable/integration-test/type-exception.html"> Exceptions </a>
            </div></div></div></div>
        
        </div>
    </div>

    <div id="content" class="pretty-box yellow content_fragment">

        <div align="right" style="display:;">
            <button title="Edit this page"  class="pencil" onclick="location='https://github.com/Raku/doc/tree/master/docs/Type/IO/Path/Unix.pod6'">
                <svg width="14px" height="16px" viewBox="0 0 14 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                    <defs></defs>
                    <g id="Octicons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g id="pencil" fill="#000000">
                            <path d="M0,12 L0,15 L3,15 L11,7 L8,4 L0,12 L0,12 Z M3,14 L1,14 L1,12 L2,12 L2,13 L3,13 L3,14 L3,14 Z M13.3,4.7 L12,6 L9,3 L10.3,1.7 C10.69,1.31 11.32,1.31 11.71,1.7 L13.3,3.29 C13.69,3.68 13.69,4.31 13.3,4.7 L13.3,4.7 Z" id="Shape"></path>
                        </g>
                    </g>
                </svg>
            </button>
        </div>

        <h1 class="title">class IO::Path::Unix</h1>
        <p class="subtitle">IO::Path pre-loaded with IO::Spec::Unix</p>

        <nav class="indexgroup">
<table id="TOC">
<caption><h2 id="TOC_Title">Table of Contents</h2></caption>
          <tr class="toc-level-1"><td class="toc-number">1</td><td class="toc-text"><a href="#Methods">Methods</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">1.1</td><td class="toc-text"><a href="#method_new">method new</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">1.2</td><td class="toc-text"><a href="#method_perl">method perl</a></td></tr>
               <tr class="toc-level-1"><td class="toc-number">2</td><td class="toc-text"><a href="#Type_Graph">Type Graph</a></td></tr>
  <tr class="toc-level-1"><td class="toc-number">3</td><td class="toc-text"><a href="#Routines_supplied_by_class_IO::Path">Routines supplied by class IO::Path</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">4.1</td><td class="toc-text"><a href="#(IO::Path)_method_new">(IO::Path) method new</a></td></tr>
                           <tr class="toc-level-2"><td class="toc-number">4.2</td><td class="toc-text"><a href="#(IO::Path)_method_ACCEPTS">(IO::Path) method ACCEPTS</a></td></tr>
                   <tr class="toc-level-2"><td class="toc-number">4.3</td><td class="toc-text"><a href="#(IO::Path)_method_basename">(IO::Path) method basename</a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">4.4</td><td class="toc-text"><a href="#(IO::Path)_method_add">(IO::Path) method add</a></td></tr>
                     <tr class="toc-level-2"><td class="toc-number">4.5</td><td class="toc-text"><a href="#(IO::Path)_method_child">(IO::Path) method child</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.6</td><td class="toc-text"><a href="#(IO::Path)_method_cleanup">(IO::Path) method cleanup</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">4.7</td><td class="toc-text"><a href="#(IO::Path)_method_comb">(IO::Path) method comb</a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">4.8</td><td class="toc-text"><a href="#(IO::Path)_method_split">(IO::Path) method split</a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">4.9</td><td class="toc-text"><a href="#(IO::Path)_method_extension">(IO::Path) method extension</a></td></tr>
                                                            <tr class="toc-level-2"><td class="toc-number">4.10</td><td class="toc-text"><a href="#(IO::Path)_method_dirname">(IO::Path) method dirname</a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">4.11</td><td class="toc-text"><a href="#(IO::Path)_method_volume">(IO::Path) method volume</a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">4.12</td><td class="toc-text"><a href="#(IO::Path)_method_parts">(IO::Path) method parts</a></td></tr>
                   <tr class="toc-level-2"><td class="toc-number">4.13</td><td class="toc-text"><a href="#(IO::Path)_method_perl">(IO::Path) method perl</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">4.14</td><td class="toc-text"><a href="#(IO::Path)_method_gist">(IO::Path) method gist</a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">4.15</td><td class="toc-text"><a href="#(IO::Path)_method_Str">(IO::Path) method Str</a></td></tr>
                 <tr class="toc-level-2"><td class="toc-number">4.16</td><td class="toc-text"><a href="#(IO::Path)_method_succ">(IO::Path) method succ</a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">4.17</td><td class="toc-text"><a href="#(IO::Path)_method_open">(IO::Path) method open</a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">4.18</td><td class="toc-text"><a href="#(IO::Path)_method_pred">(IO::Path) method pred</a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">4.19</td><td class="toc-text"><a href="#(IO::Path)_method_watch">(IO::Path) method watch</a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">4.20</td><td class="toc-text"><a href="#(IO::Path)_method_is-absolute">(IO::Path) method is-absolute</a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">4.21</td><td class="toc-text"><a href="#(IO::Path)_method_is-relative">(IO::Path) method is-relative</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.22</td><td class="toc-text"><a href="#(IO::Path)_method_absolute">(IO::Path) method absolute</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.23</td><td class="toc-text"><a href="#(IO::Path)_method_relative">(IO::Path) method relative</a></td></tr>
                <tr class="toc-level-2"><td class="toc-number">4.24</td><td class="toc-text"><a href="#(IO::Path)_method_parent">(IO::Path) method parent</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">4.25</td><td class="toc-text"><a href="#(IO::Path)_method_resolve">(IO::Path) method resolve</a></td></tr>
                         <tr class="toc-level-2"><td class="toc-number">4.26</td><td class="toc-text"><a href="#(IO::Path)_routine_dir">(IO::Path) routine dir</a></td></tr>
                                                            <tr class="toc-level-2"><td class="toc-number">4.27</td><td class="toc-text"><a href="#(IO::Path)_method_e">(IO::Path) method e</a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">4.28</td><td class="toc-text"><a href="#(IO::Path)_method_d">(IO::Path) method d</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.29</td><td class="toc-text"><a href="#(IO::Path)_method_f">(IO::Path) method f</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.30</td><td class="toc-text"><a href="#(IO::Path)_method_s">(IO::Path) method s</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.31</td><td class="toc-text"><a href="#(IO::Path)_method_l">(IO::Path) method l</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.32</td><td class="toc-text"><a href="#(IO::Path)_method_r">(IO::Path) method r</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.33</td><td class="toc-text"><a href="#(IO::Path)_method_w">(IO::Path) method w</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.34</td><td class="toc-text"><a href="#(IO::Path)_method_rw">(IO::Path) method rw</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.35</td><td class="toc-text"><a href="#(IO::Path)_method_x">(IO::Path) method x</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.36</td><td class="toc-text"><a href="#(IO::Path)_method_rwx">(IO::Path) method rwx</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.37</td><td class="toc-text"><a href="#(IO::Path)_method_z">(IO::Path) method z</a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">4.38</td><td class="toc-text"><a href="#(IO::Path)_method_sibling">(IO::Path) method sibling</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">4.39</td><td class="toc-text"><a href="#(IO::Path)_method_words">(IO::Path) method words</a></td></tr>
                                    <tr class="toc-level-2"><td class="toc-number">4.40</td><td class="toc-text"><a href="#(IO::Path)_method_lines">(IO::Path) method lines</a></td></tr>
                                      <tr class="toc-level-2"><td class="toc-number">4.41</td><td class="toc-text"><a href="#(IO::Path)_routine_slurp">(IO::Path) routine slurp</a></td></tr>
                    <tr class="toc-level-2"><td class="toc-number">4.42</td><td class="toc-text"><a href="#(IO::Path)_method_spurt">(IO::Path) method spurt</a></td></tr>
                                  <tr class="toc-level-2"><td class="toc-number">4.43</td><td class="toc-text"><a href="#(IO::Path)_method_chdir">(IO::Path) method chdir</a></td></tr>
                                              <tr class="toc-level-2"><td class="toc-number">4.44</td><td class="toc-text"><a href="#(IO::Path)_method_mkdir">(IO::Path) method mkdir</a></td></tr>
                            <tr class="toc-level-2"><td class="toc-number">4.45</td><td class="toc-text"><a href="#(IO::Path)_routine_rmdir">(IO::Path) routine rmdir</a></td></tr>
                  <tr class="toc-level-2"><td class="toc-number">4.46</td><td class="toc-text"><a href="#(IO::Path)_method_chmod">(IO::Path) method chmod</a></td></tr>
                            <tr class="toc-level-2"><td class="toc-number">4.47</td><td class="toc-text"><a href="#(IO::Path)_routine_rename">(IO::Path) routine rename</a></td></tr>
                    <tr class="toc-level-2"><td class="toc-number">4.48</td><td class="toc-text"><a href="#(IO::Path)_routine_copy">(IO::Path) routine copy</a></td></tr>
                    <tr class="toc-level-2"><td class="toc-number">4.49</td><td class="toc-text"><a href="#(IO::Path)_routine_move">(IO::Path) routine move</a></td></tr>
                         <tr class="toc-level-2"><td class="toc-number">4.50</td><td class="toc-text"><a href="#(IO::Path)_method_Numeric">(IO::Path) method Numeric</a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">4.51</td><td class="toc-text"><a href="#(IO::Path)_method_Int">(IO::Path) method Int</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">4.52</td><td class="toc-text"><a href="#(IO::Path)_routine_symlink">(IO::Path) routine symlink</a></td></tr>
                         <tr class="toc-level-2"><td class="toc-number">4.53</td><td class="toc-text"><a href="#(IO::Path)_routine_link">(IO::Path) routine link</a></td></tr>
                  <tr class="toc-level-2"><td class="toc-number">4.54</td><td class="toc-text"><a href="#(IO::Path)_routine_unlink">(IO::Path) routine unlink</a></td></tr>
                               <tr class="toc-level-2"><td class="toc-number">4.55</td><td class="toc-text"><a href="#(IO::Path)_method_IO">(IO::Path) method IO</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">4.56</td><td class="toc-text"><a href="#(IO::Path)_method_SPEC">(IO::Path) method SPEC</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.57</td><td class="toc-text"><a href="#(IO::Path)_method_modified">(IO::Path) method modified</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.58</td><td class="toc-text"><a href="#(IO::Path)_method_accessed">(IO::Path) method accessed</a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">4.59</td><td class="toc-text"><a href="#(IO::Path)_method_changed">(IO::Path) method changed</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.60</td><td class="toc-text"><a href="#(IO::Path)_method_mode">(IO::Path) method mode</a></td></tr>
                   <tr class="toc-level-1"><td class="toc-number">4</td><td class="toc-text"><a href="#Routines_supplied_by_class_Cool">Routines supplied by class Cool</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">4.61</td><td class="toc-text"><a href="#(Cool)_routine_abs">(Cool) routine abs</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.62</td><td class="toc-text"><a href="#(Cool)_method_conj">(Cool) method conj</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.63</td><td class="toc-text"><a href="#(Cool)_routine_EVAL">(Cool) routine EVAL</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.64</td><td class="toc-text"><a href="#(Cool)_routine_sqrt">(Cool) routine sqrt</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.65</td><td class="toc-text"><a href="#(Cool)_method_sign">(Cool) method sign</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.66</td><td class="toc-text"><a href="#(Cool)_method_rand">(Cool) method rand</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.67</td><td class="toc-text"><a href="#(Cool)_routine_sin">(Cool) routine sin</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">4.68</td><td class="toc-text"><a href="#(Cool)_routine_asin">(Cool) routine asin</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.69</td><td class="toc-text"><a href="#(Cool)_routine_cos">(Cool) routine cos</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.70</td><td class="toc-text"><a href="#(Cool)_routine_acos">(Cool) routine acos</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.71</td><td class="toc-text"><a href="#(Cool)_routine_tan">(Cool) routine tan</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.72</td><td class="toc-text"><a href="#(Cool)_routine_atan">(Cool) routine atan</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.73</td><td class="toc-text"><a href="#(Cool)_routine_atan2">(Cool) routine atan2</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">4.74</td><td class="toc-text"><a href="#(Cool)_routine_sec">(Cool) routine sec</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.75</td><td class="toc-text"><a href="#(Cool)_routine_asec">(Cool) routine asec</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.76</td><td class="toc-text"><a href="#(Cool)_routine_cosec">(Cool) routine cosec</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.77</td><td class="toc-text"><a href="#(Cool)_routine_acosec">(Cool) routine acosec</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.78</td><td class="toc-text"><a href="#(Cool)_routine_cotan">(Cool) routine cotan</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.79</td><td class="toc-text"><a href="#(Cool)_routine_acotan">(Cool) routine acotan</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.80</td><td class="toc-text"><a href="#(Cool)_routine_sinh">(Cool) routine sinh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.81</td><td class="toc-text"><a href="#(Cool)_routine_asinh">(Cool) routine asinh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.82</td><td class="toc-text"><a href="#(Cool)_routine_cosh">(Cool) routine cosh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.83</td><td class="toc-text"><a href="#(Cool)_routine_acosh">(Cool) routine acosh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.84</td><td class="toc-text"><a href="#(Cool)_routine_tanh">(Cool) routine tanh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.85</td><td class="toc-text"><a href="#(Cool)_routine_atanh">(Cool) routine atanh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.86</td><td class="toc-text"><a href="#(Cool)_routine_sech">(Cool) routine sech</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.87</td><td class="toc-text"><a href="#(Cool)_routine_asech">(Cool) routine asech</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.88</td><td class="toc-text"><a href="#(Cool)_routine_cosech">(Cool) routine cosech</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.89</td><td class="toc-text"><a href="#(Cool)_routine_acosech">(Cool) routine acosech</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.90</td><td class="toc-text"><a href="#(Cool)_routine_cotanh">(Cool) routine cotanh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.91</td><td class="toc-text"><a href="#(Cool)_routine_acotanh">(Cool) routine acotanh</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.92</td><td class="toc-text"><a href="#(Cool)_routine_cis">(Cool) routine cis</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">4.93</td><td class="toc-text"><a href="#(Cool)_routine_log">(Cool) routine log</a></td></tr>
                       <tr class="toc-level-2"><td class="toc-number">4.94</td><td class="toc-text"><a href="#(Cool)_routine_log10">(Cool) routine log10</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">4.95</td><td class="toc-text"><a href="#(Cool)_routine_log2">(Cool) routine log2</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">4.96</td><td class="toc-text"><a href="#(Cool)_routine_exp">(Cool) routine exp</a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">4.97</td><td class="toc-text"><a href="#(Cool)_method_unpolar">(Cool) method unpolar</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.98</td><td class="toc-text"><a href="#(Cool)_routine_round">(Cool) routine round</a></td></tr>
                              <tr class="toc-level-2"><td class="toc-number">4.99</td><td class="toc-text"><a href="#(Cool)_routine_floor">(Cool) routine floor</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.100</td><td class="toc-text"><a href="#(Cool)_method_fmt">(Cool) method fmt</a></td></tr>
                    <tr class="toc-level-2"><td class="toc-number">4.101</td><td class="toc-text"><a href="#(Cool)_routine_ceiling">(Cool) routine ceiling</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.102</td><td class="toc-text"><a href="#(Cool)_routine_truncate">(Cool) routine truncate</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.103</td><td class="toc-text"><a href="#(Cool)_routine_ord">(Cool) routine ord</a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">4.104</td><td class="toc-text"><a href="#(Cool)_method_path">(Cool) method path</a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">4.105</td><td class="toc-text"><a href="#(Cool)_routine_chr">(Cool) routine chr</a></td></tr>
                 <tr class="toc-level-2"><td class="toc-number">4.106</td><td class="toc-text"><a href="#(Cool)_routine_chars">(Cool) routine chars</a></td></tr>
                                <tr class="toc-level-2"><td class="toc-number">4.107</td><td class="toc-text"><a href="#(Cool)_routine_codes">(Cool) routine codes</a></td></tr>
             <tr class="toc-level-2"><td class="toc-number">4.108</td><td class="toc-text"><a href="#(Cool)_routine_flip">(Cool) routine flip</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.109</td><td class="toc-text"><a href="#(Cool)_routine_trim">(Cool) routine trim</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.110</td><td class="toc-text"><a href="#(Cool)_routine_trim-leading">(Cool) routine trim-leading</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.111</td><td class="toc-text"><a href="#(Cool)_routine_trim-trailing">(Cool) routine trim-trailing</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.112</td><td class="toc-text"><a href="#(Cool)_routine_lc">(Cool) routine lc</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.113</td><td class="toc-text"><a href="#(Cool)_routine_uc">(Cool) routine uc</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.114</td><td class="toc-text"><a href="#(Cool)_routine_fc">(Cool) routine fc</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.115</td><td class="toc-text"><a href="#(Cool)_routine_tc">(Cool) routine tc</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.116</td><td class="toc-text"><a href="#(Cool)_routine_tclc">(Cool) routine tclc</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.117</td><td class="toc-text"><a href="#(Cool)_routine_wordcase">(Cool) routine wordcase</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">4.118</td><td class="toc-text"><a href="#(Cool)_routine_samecase">(Cool) routine samecase</a></td></tr>
                        <tr class="toc-level-2"><td class="toc-number">4.119</td><td class="toc-text"><a href="#(Cool)_routine_uniprop">(Cool) routine uniprop</a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">4.120</td><td class="toc-text"><a href="#(Cool)_sub_uniprops">(Cool) sub uniprops</a></td></tr>
            <tr class="toc-level-2"><td class="toc-number">4.121</td><td class="toc-text"><a href="#(Cool)_routine_uniname">(Cool) routine uniname</a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">4.122</td><td class="toc-text"><a href="#(Cool)_routine_uninames">(Cool) routine uninames</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.123</td><td class="toc-text"><a href="#(Cool)_routine_unimatch">(Cool) routine unimatch</a></td></tr>
      <tr class="toc-level-2"><td class="toc-number">4.124</td><td class="toc-text"><a href="#(Cool)_routine_chop">(Cool) routine chop</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.125</td><td class="toc-text"><a href="#(Cool)_routine_chomp">(Cool) routine chomp</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.126</td><td class="toc-text"><a href="#(Cool)_routine_substr">(Cool) routine substr</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">4.127</td><td class="toc-text"><a href="#(Cool)_routine_substr-rw">(Cool) routine substr-rw</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">4.128</td><td class="toc-text"><a href="#(Cool)_routine_ords">(Cool) routine ords</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">4.129</td><td class="toc-text"><a href="#(Cool)_routine_chrs">(Cool) routine chrs</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">4.130</td><td class="toc-text"><a href="#(Cool)_routine_split">(Cool) routine split</a></td></tr>
                                                           <tr class="toc-level-2"><td class="toc-number">4.131</td><td class="toc-text"><a href="#(Cool)_routine_lines">(Cool) routine lines</a></td></tr>
                                     <tr class="toc-level-2"><td class="toc-number">4.132</td><td class="toc-text"><a href="#(Cool)_method_words">(Cool) method words</a></td></tr>
                                 <tr class="toc-level-2"><td class="toc-number">4.133</td><td class="toc-text"><a href="#(Cool)_routine_comb">(Cool) routine comb</a></td></tr>
                                  <tr class="toc-level-2"><td class="toc-number">4.134</td><td class="toc-text"><a href="#(Cool)_method_contains">(Cool) method contains</a></td></tr>
                               <tr class="toc-level-2"><td class="toc-number">4.135</td><td class="toc-text"><a href="#(Cool)_routine_index">(Cool) routine index</a></td></tr>
                   <tr class="toc-level-2"><td class="toc-number">4.136</td><td class="toc-text"><a href="#(Cool)_routine_rindex">(Cool) routine rindex</a></td></tr>
                     <tr class="toc-level-2"><td class="toc-number">4.137</td><td class="toc-text"><a href="#(Cool)_method_match">(Cool) method match</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">4.138</td><td class="toc-text"><a href="#(Cool)_routine_roots">(Cool) routine roots</a></td></tr>
                                           <tr class="toc-level-2"><td class="toc-number">4.139</td><td class="toc-text"><a href="#(Cool)_method_match">(Cool) method match</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">4.140</td><td class="toc-text"><a href="#(Cool)_method_subst">(Cool) method subst</a></td></tr>
        <tr class="toc-level-2"><td class="toc-number">4.141</td><td class="toc-text"><a href="#(Cool)_method_trans">(Cool) method trans</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">4.142</td><td class="toc-text"><a href="#(Cool)_method_IO">(Cool) method IO</a></td></tr>
       
</table>
</nav>

        <div class="pod-body ">
            <pre class="pod-block-code">class IO::Path::Unix is IO::Path { }</pre>
<p>This sub-class of <a href="/Documentable/integration-test/type/IO::Path"><code>IO::Path</code></a>, pre-loaded with <a href="/Documentable/integration-test/type/IO::Spec::Unix"><code>IO::Spec::Unix</code></a> in the <code>$.SPEC</code> attribute.</p>
<h1 id="Methods"><a class="u" href="#___top" title="go to top of document">Methods</a></h1>
<h2 id="method_new"><a class="u" href="#___top" title="go to top of document">method new</a></h2>
<p>Same as <a href="/Documentable/integration-test/type/IO::Path#method_new"><code>IO::Path.new</code></a>, except <code>:$SPEC</code> cannot be set and defaults to <a href="/Documentable/integration-test/type/IO::Spec::Unix"><code>IO::Spec::Unix</code></a>, regardless of the operating system the code is being run on.</p>
<h2 id="method_perl"><a class="u" href="#___top" title="go to top of document">method perl</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method perl(IO::Path::Unix:D: --&gt; Str:D)</pre>
<p>Returns a string that, when given passed through <a href="/Documentable/integration-test/routine/EVAL"><code>EVAL</code></a> gives the original invocant back.</p>
<pre class="pod-block-code">    IO::Path::Unix.new(&quot;foo/bar&quot;).perl.say;
    # OUTPUT: IO::Path::Unix.new(&quot;foo/bar&quot;, :CWD(&quot;/home/camelia&quot;))
</pre>
<p>Note that this string includes the value of the <code>.CWD</code> attribute that is set to <a href="/Documentable/integration-test/language/variables#Dynamic_variables"><code>$*CWD</code></a> when the path object was created, by default.</p>
<h1 id="Type_Graph"><a class="u" href="#___top" title="go to top of document">Type Graph</a></h1>
<figure>
  <figcaption>Type relations for <code>IO::Path::Unix</code></figcaption>
  <svg width="167pt" height="332pt"
 viewBox="0.00 0.00 166.59 332.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 328)">
<title>perl6&#45;type&#45;graph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-328 162.59,-328 162.59,4 -4,4"/>
<!-- IO::Path::Unix -->
<g id="node1" class="node">
<title>IO::Path::Unix</title>
<g id="a_node1"><a xlink:href="/type/IO::Path::Unix" xlink:title="IO::Path::Unix">
<ellipse fill="none" stroke="#000000" cx="79.29" cy="-18" rx="79.09" ry="18"/>
<text text-anchor="middle" x="79.29" y="-14.3" font-family="FreeSans" font-size="14.00" fill="#000000">IO::Path::Unix</text>
</a>
</g>
</g>
<!-- IO::Path -->
<g id="node6" class="node">
<title>IO::Path</title>
<g id="a_node6"><a xlink:href="/type/IO::Path" xlink:title="IO::Path">
<ellipse fill="none" stroke="#000000" cx="79.29" cy="-90" rx="50.09" ry="18"/>
<text text-anchor="middle" x="79.29" y="-86.3" font-family="FreeSans" font-size="14.00" fill="#000000">IO::Path</text>
</a>
</g>
</g>
<!-- IO::Path::Unix&#45;&gt;IO::Path -->
<g id="edge1" class="edge">
<title>IO::Path::Unix&#45;&gt;IO::Path</title>
<path fill="none" stroke="#000000" d="M79.29,-36.3C79.29,-44.02 79.29,-53.29 79.29,-61.89"/>
<polygon fill="#000000" stroke="#000000" points="75.79,-61.9 79.29,-71.9 82.79,-61.9 75.79,-61.9"/>
</g>
<!-- Mu -->
<g id="node2" class="node">
<title>Mu</title>
<g id="a_node2"><a xlink:href="/type/Mu" xlink:title="Mu">
<ellipse fill="none" stroke="#000000" cx="41.29" cy="-306" rx="27" ry="18"/>
<text text-anchor="middle" x="41.29" y="-302.3" font-family="FreeSans" font-size="14.00" fill="#000000">Mu</text>
</a>
</g>
</g>
<!-- Any -->
<g id="node3" class="node">
<title>Any</title>
<g id="a_node3"><a xlink:href="/type/Any" xlink:title="Any">
<ellipse fill="none" stroke="#000000" cx="41.29" cy="-234" rx="27" ry="18"/>
<text text-anchor="middle" x="41.29" y="-230.3" font-family="FreeSans" font-size="14.00" fill="#000000">Any</text>
</a>
</g>
</g>
<!-- Any&#45;&gt;Mu -->
<g id="edge2" class="edge">
<title>Any&#45;&gt;Mu</title>
<path fill="none" stroke="#000000" d="M41.29,-252.3C41.29,-260.02 41.29,-269.29 41.29,-277.89"/>
<polygon fill="#000000" stroke="#000000" points="37.79,-277.9 41.29,-287.9 44.79,-277.9 37.79,-277.9"/>
</g>
<!-- Cool -->
<g id="node4" class="node">
<title>Cool</title>
<g id="a_node4"><a xlink:href="/type/Cool" xlink:title="Cool">
<ellipse fill="none" stroke="#000000" cx="41.29" cy="-162" rx="30.59" ry="18"/>
<text text-anchor="middle" x="41.29" y="-158.3" font-family="FreeSans" font-size="14.00" fill="#000000">Cool</text>
</a>
</g>
</g>
<!-- Cool&#45;&gt;Any -->
<g id="edge3" class="edge">
<title>Cool&#45;&gt;Any</title>
<path fill="none" stroke="#000000" d="M41.29,-180.3C41.29,-188.02 41.29,-197.29 41.29,-205.89"/>
<polygon fill="#000000" stroke="#000000" points="37.79,-205.9 41.29,-215.9 44.79,-205.9 37.79,-205.9"/>
</g>
<!-- IO -->
<g id="node5" class="node">
<title>IO</title>
<g id="a_node5"><a xlink:href="/type/IO" xlink:title="IO">
<ellipse fill="none" stroke="#6666ff" cx="117.29" cy="-162" rx="27" ry="18"/>
<text text-anchor="middle" x="117.29" y="-158.3" font-family="FreeSans" font-size="14.00" fill="#6666ff">IO</text>
</a>
</g>
</g>
<!-- IO::Path&#45;&gt;Cool -->
<g id="edge4" class="edge">
<title>IO::Path&#45;&gt;Cool</title>
<path fill="none" stroke="#000000" d="M70.09,-107.95C65.55,-116.32 59.97,-126.6 54.94,-135.87"/>
<polygon fill="#000000" stroke="#000000" points="51.84,-134.23 50.15,-144.69 57.99,-137.57 51.84,-134.23"/>
</g>
<!-- IO::Path&#45;&gt;IO -->
<g id="edge5" class="edge">
<title>IO::Path&#45;&gt;IO</title>
<path fill="none" stroke="#6666ff" d="M88.49,-107.95C93.04,-116.32 98.62,-126.6 103.65,-135.87"/>
<polygon fill="#6666ff" stroke="#6666ff" points="100.59,-137.57 108.44,-144.69 106.75,-134.23 100.59,-137.57"/>
</g>
</g>
</svg>

  <p class="fallback">
    <a
      rel="alternate"
      href="/images/type-graph-IO%3A%3APath%3A%3AUnix.svg"
      type="image/svg+xml"
      >Expand above chart</a
    >
  </p>
</figure>
<h1 id="Routines_supplied_by_class_IO::Path"><a class="u" href="#___top" title="go to top of document">Routines supplied by class IO::Path</a></h1>
<p>IO::Path::Unix inherits from class <a href="/Documentable/integration-test/type/IO::Path">IO::Path</a>, which provides the following routines:</p>
<h2 id="(IO::Path)_method_new"><a href="/Documentable/integration-test/type/IO::Path#method_new">(IO::Path) method new</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)
multi method new(
    :$basename!, :$dirname = &#39;.&#39;, :$volume = &#39;&#39;
    IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD
)
</pre>
<p>Creates a new <code>IO::Path</code> object from a path string (which is being parsed for volume, directory name and basename), or from volume, directory name and basename passed as named arguments.</p>
<p>The path&#39;s operation will be performed using <code>:$SPEC</code> semantics (defaults to current <a href="/Documentable/integration-test/language/variables#Dynamic_variables"><code>$*SPEC</code></a>) and will use <code>:$CWD</code> as the directory the path is relative to (defaults to <a href="/Documentable/integration-test/language/variables#Dynamic_variables"><code>$*CWD</code></a>).</p>
<p>If <code>$path</code> includes the null byte, it will throw an Exception with a &quot;Cannot use null character (U+0000) as part of the path&quot; message.</p>
<h2 id="(IO::Path)_method_ACCEPTS"><a href="/Documentable/integration-test/type/IO::Path#method_ACCEPTS">(IO::Path) method ACCEPTS</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method ACCEPTS(IO::Path:D: Cool:D $other --&gt; Bool:D)</pre>
<p>Coerces the argument to <code>IO::Path</code>, if necessary. Returns <code>True</code> if <a href="/Documentable/integration-test/routine/absolute"><code>.absolute</code></a> method on both paths returns the same string. <strong>NOTE:</strong> it&#39;s possible for two paths that superficially point to the same resource to NOT smartmatch as <code>True</code>, if they were constructed differently and were never fully resolved:</p>
<pre class="pod-block-code">say &quot;foo/../bar&quot;.IO ~~ &quot;bar&quot;.IO # False</pre>
<p>The reason is the two paths above may point to different resources when fully resolved (e.g. if <code>foo</code> is a symlink). Resolve the paths before smartmatching to check they point to same resource:</p>
<pre class="pod-block-code">say &quot;foo/../bar&quot;.IO.resolve(:completely) ~~ &quot;bar&quot;.IO.resolve(:completely) # True</pre>
<h2 id="(IO::Path)_method_basename"><a href="/Documentable/integration-test/type/IO::Path#method_basename">(IO::Path) method basename</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method basename(IO::Path:D:)</pre>
<p>Returns the basename part of the path object, which is the name of the filesystem object itself that is referenced by the path.</p>
<pre class="pod-block-code">&quot;docs/README.pod&quot;.IO.basename.say; # OUTPUT: «README.pod␤»
&quot;/tmp/&quot;.IO.basename.say;           # OUTPUT: «tmp␤»</pre>
<p>Note that in <a href="/Documentable/integration-test/type/IO::Spec::Win32"><code>IO::Spec::Win32</code></a> semantics, the <code>basename</code> of a Windows share is <code>\</code>, not the name of the share itself:</p>
<pre class="pod-block-code">IO::Path::Win32.new(&#39;//server/share&#39;).basename.say; # OUTPUT: «\␤»</pre>
<h2 id="(IO::Path)_method_add"><a href="/Documentable/integration-test/type/IO::Path#method_add">(IO::Path) method add</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method add(IO::Path:D: Str() $what --&gt; IO::Path:D)</pre>
<p>Concatenates a path fragment to the invocant and returns the resultant <code>IO::Path</code>. If adding <code>../</code> to paths that end with a file, you may need to call <a href="/Documentable/integration-test/routine/resolve">resolve</a> for the resultant path to be accessible by other <code>IO::Path</code> methods like <a href="/Documentable/integration-test/routine/dir">dir</a> or <a href="/Documentable/integration-test/routine/open">open</a>. See also <a href="/Documentable/integration-test/routine/sibling">sibling</a> and <a href="/Documentable/integration-test/routine/parent">parent</a>.</p>
<pre class="pod-block-code">&quot;foo/bar&quot;.IO.mkdir;
&quot;foo/bar&quot;.IO.add(&quot;meow&quot;)    .resolve.relative.say; # OUTPUT: «foo/bar/meow␤»
&quot;foo/bar&quot;.IO.add(&quot;/meow&quot;)   .resolve.relative.say; # OUTPUT: «foo/bar/meow␤»
&quot;foo/bar&quot;.IO.add(&quot;meow.txt&quot;).resolve.relative.say; # OUTPUT: «foo/bar/meow.txt␤»
&quot;foo/bar&quot;.IO.add(&quot;../meow&quot;) .resolve.relative.say; # OUTPUT: «foo/meow␤»
&quot;foo/bar&quot;.IO.add(&quot;../../&quot;)  .resolve.relative.say; # OUTPUT: «.␤»</pre>
<h2 id="(IO::Path)_method_child"><a href="/Documentable/integration-test/type/IO::Path#method_child">(IO::Path) method child</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method child(IO::Path:D: Str() $childname --&gt; IO::Path:D)</pre>
<p>Alias for <a href="/Documentable/integration-test/routine/add"><code>.add</code></a>. <strong>NOTE:</strong> This method has been deprecated as of the 6.d version, and will be removed in the future. For any new code, please use <a href="/Documentable/integration-test/routine/add"><code>.add</code></a></p>
<h2 id="(IO::Path)_method_cleanup"><a href="/Documentable/integration-test/type/IO::Path#method_cleanup">(IO::Path) method cleanup</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method cleanup(IO::Path:D: --&gt; IO::Path:D)</pre>
<p>Returns a new path that is a canonical representation of the invocant path, cleaning up any extraneous path parts:</p>
<pre class="pod-block-code">&quot;foo/./././..////bar&quot;.IO.cleanup.say;      # OUTPUT: «&quot;foo/../bar&quot;.IO␤»
IO::Path::Win32.new(&quot;foo/./././..////bar&quot;)
    .cleanup.say; &quot;foo\..\bar&quot;.IO;         # OUTPUT: «&quot;foo\..\bar&quot;.IO␤»</pre>
<p>Note that no filesystem access is made. See also <a href="/Documentable/integration-test/routine/resolve"><code>resolve</code></a>.</p>
<h2 id="(IO::Path)_method_comb"><a href="/Documentable/integration-test/type/IO::Path#method_comb">(IO::Path) method comb</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method comb(IO::Path:D: |args --&gt; Seq:D)</pre>
<p>Opens the file and processes its contents the same way <a href="/Documentable/integration-test/type/Str#routine_comb"><code>Str.comb</code></a> does, taking the same arguments. Implementations may slurp the file in its entirety when this method is called.</p>
<h2 id="(IO::Path)_method_split"><a href="/Documentable/integration-test/type/IO::Path#method_split">(IO::Path) method split</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method split(IO::Path:D: |args --&gt; Seq:D)</pre>
<p>Opens the file and processes its contents the same way <a href="/Documentable/integration-test/type/Str#routine_split"><code>Str.split</code></a> does, taking the same arguments. Implementations may slurp the file in its entirety when this method is called.</p>
<h2 id="(IO::Path)_method_extension"><a href="/Documentable/integration-test/type/IO::Path#method_extension">(IO::Path) method extension</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method extension(IO::Path:D:                                         --&gt; Str:D)
multi method extension(IO::Path:D:               Int :$parts               --&gt; Str:D)
multi method extension(IO::Path:D:             Range :$parts               --&gt; Str:D)
multi method extension(IO::Path:D: Str $subst,   Int :$parts, Str :$joiner --&gt; IO::Path:D)
multi method extension(IO::Path:D: Str $subst, Range :$parts, Str :$joiner --&gt; IO::Path:D)</pre>
<p>Returns the extension consisting of <code>$parts</code> parts (defaults to <code>1</code>), where a &quot;part&quot; is defined as a dot followed by possibly-empty string up to the end of the string, or previous part. That is <code>&quot;foo.tar.gz&quot;</code> has an extension of two parts: first part is <code>&quot;gz&quot;</code> and second part is <code>&quot;tar&quot;</code> and calling <code>&quot;foo.tar.gz&quot;.IO.extension: :2parts</code> gives <code>&quot;tar.gz&quot;</code>. If an extension with the specified number of <code>$parts</code> is not found, returns an empty string.</p>
<p><code>$parts</code> can be a <a href="/Documentable/integration-test/type/Range"><code>Range</code></a>, specifying the minimum number of parts and maximum number of parts the extension should have. The routine will attempt to much the most parts it can. If <code>$parts</code> range&#39;s endpoints that are smaller than <code>0</code> they&#39;ll be treated as <code>0</code>; implementations may treat endpoints larger than <code>2⁶³-1</code> as <code>2⁶³-1</code>. Ranges with <code>NaN</code> or <a href="/Documentable/integration-test/type/Str"><code>Str</code></a> endpoints will cause an exception to be thrown.</p>
<p>If <code>$subst</code> is provided, the extension will be instead replaced with <code>$subst</code> and a new <code>IO::Path</code> object will be returned. It will be joined to the file&#39;s name with <code>$joiner</code>, which defaults to an empty string when <code>$subst</code> is an empty string and to <code>&quot;.&quot;</code> when <code>$subst</code> is not empty. <strong>Note:</strong> if as the result of replacement the <a href="/Documentable/integration-test/routine/basename"><code>basename</code></a> of the path ends up being empty, it will be assumed to be <code>.</code> (a single dot).</p>
<pre class="pod-block-code"># Getting an extension:
say &quot;foo.tar.gz&quot;.IO.extension;               # OUTPUT: «gz␤»
say &quot;foo.tar.gz&quot;.IO.extension: :2parts;      # OUTPUT: «tar.gz␤»
say &quot;foo.tar.gz&quot;.IO.extension: :parts(^5);   # OUTPUT: «tar.gz␤»
say &quot;foo.tar.gz&quot;.IO.extension: :parts(0..1); # OUTPUT: «gz␤»

# Replacing an extension
say &quot;foo.tar.gz&quot;.IO.extension: &#39;&#39;;                # OUTPUT: «&quot;foo.tar&quot;.IO␤»
say &quot;foo.tar.gz&quot;.IO.extension: &#39;ZIP&#39;;             # OUTPUT: «&quot;foo.tar.ZIP&quot;.IO␤»
say &quot;foo.tar.gz&quot;.IO.extension: &#39;ZIP&#39;, :0parts;    # OUTPUT: «&quot;foo.tar.gz.ZIP&quot;.IO␤»
say &quot;foo.tar.gz&quot;.IO.extension: &#39;ZIP&#39;, :2parts;    # OUTPUT: «&quot;foo.ZIP&quot;.IO␤»
say &quot;foo.tar.gz&quot;.IO.extension: &#39;ZIP&#39;, :parts(^5); # OUTPUT: «&quot;foo.ZIP&quot;.IO␤»

# Replacing an extension using non-standard joiner:
say &quot;foo.tar.gz&quot;.IO.extension: &#39;&#39;,    :joiner&lt;_&gt;;  # OUTPUT: «&quot;foo.tar_&quot;.IO␤»
say &quot;foo.tar.gz&quot;.IO.extension: &#39;ZIP&#39;, :joiner&lt;_&gt;;  # OUTPUT: «&quot;foo.tar_ZIP&quot;.IO␤»
say &quot;foo.tar.gz&quot;.IO.extension: &#39;ZIP&#39;, :joiner&lt;_&gt;,
                                       :2parts;     # OUTPUT: «&quot;foo_ZIP&quot;.IO␤»
say &quot;foo.tar.gz&quot;.IO.extension: &#39;ZIP&#39;, :joiner&lt;_&gt;,
                                       :parts(^5);  # OUTPUT: «&quot;foo_ZIP&quot;.IO␤»

# EDGE CASES:

# There is no 5-part extension, so returned value is an empty string
say &quot;foo.tar.gz&quot;.IO.extension: :5parts; # OUTPUT: «␤»

# There is no 5-part extension, so we replaced nothing:
say &quot;foo.tar.gz&quot;.IO.extension: &#39;ZIP&#39;, :5parts; # OUTPUT: «&quot;foo.tar.gz&quot;.IO␤»

# Replacing a 0-part extension is just appending:
say &quot;foo.tar.gz&quot;.IO.extension: &#39;ZIP&#39;, :0parts; # OUTPUT: «&quot;foo.tar.gz.ZIP&quot;.IO␤»

# Replace 1-part of the extension, using &#39;.&#39; joiner
say &quot;...&quot;.IO.extension: &#39;tar&#39;; # OUTPUT: «&quot;...tar&quot;.IO␤»

# Replace 1-part of the extension, using empty string joiner
say &quot;...&quot;.IO.extension: &#39;tar&#39;, :joiner(&#39;&#39;); # OUTPUT: «&quot;..tar&quot;.IO␤»

# Remove 1-part extension; results in empty basename, so result is &quot;.&quot;.IO
say &quot;.&quot;.IO.extension: &#39;&#39;; # OUTPUT: «&quot;.&quot;.IO␤»</pre>
<h2 id="(IO::Path)_method_dirname"><a href="/Documentable/integration-test/type/IO::Path#method_dirname">(IO::Path) method dirname</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method dirname(IO::Path:D:)</pre>
<p>Returns the directory name portion of the path object. That is, it returns the path excluding the <a href="/Documentable/integration-test/routine/volume">volume</a> and the <a href="/Documentable/integration-test/routine/basename">base name</a>. Unless the dirname consist of <em>only</em> the directory separator (i.e. it&#39;s the top directory), the trailing directory separator will <em>not</em> be included in the return value.</p>
<pre class="pod-block-code">say IO::Path.new(&quot;/home/camelia/myfile.p6&quot;).dirname; # OUTPUT: «/home/camelia␤»
say IO::Path::Win32.new(&quot;C:/home/camelia&quot;).dirname;  # OUTPUT: «/home␤»
say IO::Path.new(&quot;/home&quot;).dirname;                   # OUTPUT: «/␤»</pre>
<h2 id="(IO::Path)_method_volume"><a href="/Documentable/integration-test/type/IO::Path#method_volume">(IO::Path) method volume</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method volume(IO::Path:D:)</pre>
<p>Returns the volume portion of the path object. On Unix system, this is always the empty string.</p>
<pre class="pod-block-code">say IO::Path::Win32.new(&quot;C:\\Windows\\registry.ini&quot;).volume;    # OUTPUT: «C:␤»</pre>
<h2 id="(IO::Path)_method_parts"><a href="/Documentable/integration-test/type/IO::Path#method_parts">(IO::Path) method parts</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method parts(IO::Path:D: --&gt; Map:D)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Map">Map</a> with the keys <code>volume</code>, <code>dirname</code>, <code>basename</code> whose values are the same as available via methods <a href="/Documentable/integration-test/routine/volume"><code>.volume</code></a>, <a href="/Documentable/integration-test/routine/dirname"><code>.dirname</code></a>, and <a href="/Documentable/integration-test/routine/basename"><code>.basename</code></a> respectively.</p>
<pre class="pod-block-code">say IO::Path::Win32.new(&quot;C:/rakudo/perl6.bat&quot;).parts.raku;
# OUTPUT: «Map.new((:basename(&quot;perl6.bat&quot;),:dirname(&quot;/rakudo&quot;),:volume(&quot;C:&quot;)))␤»</pre>
<h2 id="(IO::Path)_method_perl"><a href="/Documentable/integration-test/type/IO::Path#method_perl">(IO::Path) method perl</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method perl(IO::Path:D: --&gt; Str:D)</pre>
<p>Returns a string that, when given passed through <a href="/Documentable/integration-test/routine/EVAL"><code>EVAL</code></a> gives the original invocant back.</p>
<pre class="pod-block-code">    &quot;foo/bar&quot;.IO.perl.say;
    # OUTPUT: IO::Path.new(&quot;foo/bar&quot;, :SPEC(IO::Spec::Unix), :CWD(&quot;/home/camelia&quot;))
</pre>
<p>Note that this string includes the value of the <code>.CWD</code> attribute that is set to <a href="/Documentable/integration-test/language/variables#Dynamic_variables"><code>$*CWD</code></a> when the path object was created, by default.</p>
<h2 id="(IO::Path)_method_gist"><a href="/Documentable/integration-test/type/IO::Path#method_gist">(IO::Path) method gist</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method gist(IO::Path:D: --&gt; Str:D)</pre>
<p>Returns a string, part of which contains either the value of <a href="/Documentable/integration-test/type/IO::Path#method_absolute"><code>.absolute</code></a> (if path is absolute) or <a href="/Documentable/integration-test/type/IO::Path#attribute_path"><code>.path</code></a>. Note that no escaping of special characters is made, so e.g. <code>&quot;\b&quot;</code> means a path contains a backslash and letter &quot;b&quot;, not a backspace.</p>
<pre class="pod-block-code">say &quot;foo/bar&quot;.IO;                       # OUTPUT: «&quot;foo/bar&quot;.IO␤»
say IO::Path::Win32.new: ｢C:\foo/bar\｣; # OUTPUT: «&quot;C:\foo/bar\&quot;.IO␤»</pre>
<h2 id="(IO::Path)_method_Str"><a href="/Documentable/integration-test/type/IO::Path#method_Str">(IO::Path) method Str</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Str(IO::Path:D: --&gt; Str)</pre>
<p>Alias for <a href="/Documentable/integration-test/routine/path"><code>IO::Path.path</code></a>. In particular, note that default stringification of an <code>IO::Path</code> does <strong>NOT</strong> use the value of <a href="/Documentable/integration-test/type/IO::Path#attribute_CWD"><code>$.CWD</code> attribute</a>. To stringify while retaining full path information use <a href="/Documentable/integration-test/routine/absolute"><code>.absolute</code></a> or <a href="/Documentable/integration-test/routine/relative"><code>.relative</code></a> methods.</p>
<h2 id="(IO::Path)_method_succ"><a href="/Documentable/integration-test/type/IO::Path#method_succ">(IO::Path) method succ</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method succ(IO::Path:D: --&gt; IO::Path:D)</pre>
<p>Returns a new <a href="/Documentable/integration-test/type/IO::Path">IO::Path</a> constructed from the invocant, with <a href="/Documentable/integration-test/routine/basename"><code>.basename</code></a> changed by calling <a href="/Documentable/integration-test/type/Str#method_succ"><code>Str.succ</code></a> on it.</p>
<pre class="pod-block-code">&quot;foo/file02.txt&quot;.IO.succ.say; # OUTPUT: «&quot;foo/file03.txt&quot;.IO␤»</pre>
<h2 id="(IO::Path)_method_open"><a href="/Documentable/integration-test/type/IO::Path#method_open">(IO::Path) method open</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method open(IO::Path:D: *%opts)</pre>
<p>Opens the path as a file; the named options control the mode, and are the same as the <a href="/Documentable/integration-test/routine/open">open</a> function accepts.</p>
<h2 id="(IO::Path)_method_pred"><a href="/Documentable/integration-test/type/IO::Path#method_pred">(IO::Path) method pred</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method pred(IO::Path:D: --&gt; IO::Path:D)</pre>
<p>Returns a new <a href="/Documentable/integration-test/type/IO::Path">IO::Path</a> constructed from the invocant, with <a href="/Documentable/integration-test/routine/basename"><code>.basename</code></a> changed by calling <a href="/Documentable/integration-test/type/Str#method_pred"><code>Str.pred</code></a> on it.</p>
<pre class="pod-block-code">&quot;foo/file02.txt&quot;.IO.pred.say; # OUTPUT: «&quot;foo/file01.txt&quot;.IO␤»</pre>
<h2 id="(IO::Path)_method_watch"><a href="/Documentable/integration-test/type/IO::Path#method_watch">(IO::Path) method watch</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method watch(IO::Path:D: --&gt; Supply:D)</pre>
<p>Equivalent to calling <a href="/Documentable/integration-test/type/IO::Notification#method_watch-path">IO::Notification.watch-path</a> with the invocant as the argument.</p>
<h2 id="(IO::Path)_method_is-absolute"><a href="/Documentable/integration-test/type/IO::Path#method_is-absolute">(IO::Path) method is-absolute</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method is-absolute(IO::Path:D: --&gt; Bool)</pre>
<p>Returns <code>True</code> if the path is an absolute path, and <code>False</code> otherwise.</p>
<pre class="pod-block-code">&quot;/foo&quot;.IO.is-absolute.say; # OUTPUT: «True␤»
&quot;bars&quot;.IO.is-absolute.say; # OUTPUT: «False␤»</pre>
<p>Note that on Windows a path that starts with a slash or backslash is still considered absolute even if no volume was given, as it is absolute for that particular volume:</p>
<pre class="pod-block-code">IO::Path::Win32.new(&quot;/foo&quot;  ).is-absolute.say; # OUTPUT: «True␤»
IO::Path::Win32.new(&quot;C:/foo&quot;).is-absolute.say; # OUTPUT: «True␤»
IO::Path::Win32.new(&quot;C:foo&quot; ).is-absolute.say; # OUTPUT: «False␤»</pre>
<h2 id="(IO::Path)_method_is-relative"><a href="/Documentable/integration-test/type/IO::Path#method_is-relative">(IO::Path) method is-relative</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method is-relative(IO::Path:D: --&gt; Bool)</pre>
<p>Returns <code>True</code> if the path is a relative path, and <code>False</code> otherwise. Windows caveats for <a href="/Documentable/integration-test/type/IO::Path#method_is-absolute"><code>.is-absolute</code></a> apply.</p>
<h2 id="(IO::Path)_method_absolute"><a href="/Documentable/integration-test/type/IO::Path#method_absolute">(IO::Path) method absolute</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method absolute(IO::Path:D: --&gt; Str)
multi method absolute(IO::Path:D: $base --&gt; Str)</pre>
<p>Returns a new <code>Str</code> object that is an absolute path. If the invocant is not already an absolute path, it is first made absolute using <code>$base</code> as base, if it is provided, or the <code>.CWD</code> attribute the object was created with if it is not.</p>
<h2 id="(IO::Path)_method_relative"><a href="/Documentable/integration-test/type/IO::Path#method_relative">(IO::Path) method relative</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method relative(IO::Path:D: $base = $*CWD --&gt; Str)</pre>
<p>Returns a new <code>Str</code> object with the path relative to the <code>$base</code>. If <code>$base</code> is not provided, <code>$*CWD</code> is used in its place. If the invocant is not an absolute path, it&#39;s first made to be absolute using the <code>.CWD</code> attribute the object was created with, and then is made relative to <code>$base</code>.</p>
<h2 id="(IO::Path)_method_parent"><a href="/Documentable/integration-test/type/IO::Path#method_parent">(IO::Path) method parent</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method parent(IO::Path:D:)
multi method parent(IO::Path:D: UInt:D $level)</pre>
<p>Returns the parent path of the invocant. Note that no actual filesystem access is made, so the returned parent is physical and not the logical parent of symlinked directories.</p>
<pre class="pod-block-code">&#39;/etc/foo&#39;.IO.parent.say; # OUTPUT: «&quot;/etc&quot;.IO␤»
&#39;/etc/..&#39; .IO.parent.say; # OUTPUT: «&quot;/etc&quot;.IO␤»
&#39;/etc/../&#39;.IO.parent.say; # OUTPUT: «&quot;/etc&quot;.IO␤»
&#39;./&#39;      .IO.parent.say; # OUTPUT: «&quot;..&quot;.IO␤»
&#39;foo&#39;     .IO.parent.say; # OUTPUT: «&quot;.&quot;.IO␤»
&#39;/&#39;       .IO.parent.say; # OUTPUT: «&quot;/&quot;.IO␤»
IO::Path::Win32.new(&#39;C:/&#39;).parent.say; # OUTPUT: «&quot;C:/&quot;.IO␤»</pre>
<p>If <code>$level</code> is specified, the call is equivalent to calling <code>.parent()</code> <code>$level</code> times:</p>
<pre class="pod-block-code">say &quot;/etc/foo&quot;.IO.parent(2) eqv &quot;/etc/foo&quot;.IO.parent.parent; # OUTPUT: «True␤»
</pre>
<h2 id="(IO::Path)_method_resolve"><a href="/Documentable/integration-test/type/IO::Path#method_resolve">(IO::Path) method resolve</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method resolve(IO::Path:D: :$completely --&gt; IO::Path)</pre>
<p>Returns a new <code>IO::Path</code> object with all symbolic links and references to the parent directory (<code>..</code>) resolved. This means that the filesystem is examined for each directory in the path, and any symlinks found are followed.</p>
<pre class="pod-block-code"># bar is a symlink pointing to &quot;/baz&quot;
my $io = &quot;foo/./bar/..&quot;.IO.resolve;      # now &quot;/&quot; (the parent of &quot;/baz&quot;)</pre>
<p>If <code>:$completely</code>, which defaults to <code>False</code>, is set to a true value, the method will <a href="/Documentable/integration-test/routine/fail"><code>fail</code></a> with <code>X::IO::Resolve</code> if it cannot completely resolve the path, otherwise, it will resolve as much as possible, and will merely perform <a href="/Documentable/integration-test/routine/cleanup"><code>cleanup</code></a> of the rest of the path. The last part of the path does <strong>NOT</strong> have to exist to <code>:$completely</code> resolve the path.</p>
<p>NOTE: Currently (April 2017) this method doesn&#39;t work correctly on all platforms, e.g. Windows, since it assumes POSIX semantics.</p>
<h2 id="(IO::Path)_routine_dir"><a href="/Documentable/integration-test/type/IO::Path#routine_dir">(IO::Path) routine dir</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub dir(*%_)
multi sub dir(IO::Path:D $path, |c)
multi sub dir(IO()       $path, |c)
method dir(IO::Path:D: Mu :$test = $*SPEC.curupdir)</pre>
<p>Returns the contents of a directory as a lazy list of <code>IO::Path</code> objects representing relative paths, filtered by <a href="/Documentable/integration-test/language/operators#infix_~~">smartmatching</a> their names (as strings) against the <code>:test</code> parameter. The path of returned files will be absolute or relative depending on what <code>$path</code> is.</p>
<p>Since the tests are performed against <code>Str</code> arguments, not <code>IO</code>, the tests are executed in the <code>$*CWD</code>, instead of the target directory. When testing against file test operators, this won&#39;t work:</p>
<pre class="pod-block-code">dir(&#39;mydir&#39;, test =&gt; { .IO.d })</pre>
<p>while this will:</p>
<pre class="pod-block-code">dir(&#39;mydir&#39;, test =&gt; { &quot;mydir/$_&quot;.IO.d })</pre>
<p><strong>NOTE:</strong> a <code>dir</code> call opens a directory for reading, which counts towards maximum per-process open files for your program. Be sure to exhaust returned <a href="/Documentable/integration-test/type/Seq">Seq</a> before doing something like recursively performing more <code>dir</code> calls. You can exhaust it by assigning to a <code>@-</code>sigiled variable or simply looping over it. Note how examples below push further dirs to look through into an <a href="/Documentable/integration-test/type/Array">Array</a>, rather than immediately calling <code>dir</code> on them. See also <a href="https://modules.raku.org/dist/IO::Dir"><code>IO::Dir</code> module</a> that gives you finer control over closing dir handles.</p>
<p>Examples:</p>
<pre class="pod-block-code"># To iterate over the contents of the current directory:
for dir() -&gt; $file {
    say $file;
}

# As before, but include even &#39;.&#39; and &#39;..&#39; which are filtered out by
# the default :test matcher:
for dir(test =&gt; *) -&gt; $file {
    say $file;
}

# To get the names of all .jpg and .jpeg files in the home directory of the current user:
my @jpegs = $*HOME.dir: test =&gt; /:i &#39;.&#39; jpe?g $/;</pre>
<p>An example program that lists all files and directories recursively:</p>
<pre class="pod-block-code">sub MAIN($dir = &#39;.&#39;) {
    my @todo = $dir.IO;
    while @todo {
        for @todo.pop.dir -&gt; $path {
            say $path.Str;
            @todo.push: $path if $path.d;
        }
    }
}</pre>
<p>A lazy way to find the first three files ending in &quot;.p6&quot; recursively starting from the current directory:</p>
<pre class="pod-block-code">my @stack = &#39;.&#39;.IO;
my $perl-files = gather while @stack {
    with @stack.pop {
        when :d { @stack.append: .dir }
        .take when .extension.lc eq &#39;p6&#39;
    }
}
.put for $perl-files[^3];
</pre>
<h2 id="(IO::Path)_method_e"><a href="/Documentable/integration-test/type/IO::Path#method_e">(IO::Path) method e</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method e(--&gt; Bool:D)</pre>
<p>Returns <code>True</code> if the invocant is a path that exists.</p>
<h2 id="(IO::Path)_method_d"><a href="/Documentable/integration-test/type/IO::Path#method_d">(IO::Path) method d</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method d(--&gt; Bool:D)</pre>
<p>Returns <code>True</code> if the invocant is a path that exists and is a directory. The method will <a href="/Documentable/integration-test/routine/fail"><code>fail</code></a> with <code>X::IO::DoesNotExist</code> if the path points to a non-existent filesystem entity.</p>
<h2 id="(IO::Path)_method_f"><a href="/Documentable/integration-test/type/IO::Path#method_f">(IO::Path) method f</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method f(--&gt; Bool:D)</pre>
<p>Returns <code>True</code> if the invocant is a path that exists and is a file. The method will <a href="/Documentable/integration-test/routine/fail"><code>fail</code></a> with <code>X::IO::DoesNotExist</code> if the path points to a non-existent filesystem entity.</p>
<h2 id="(IO::Path)_method_s"><a href="/Documentable/integration-test/type/IO::Path#method_s">(IO::Path) method s</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method s(--&gt; Int:D)</pre>
<p>Returns the file size in bytes. May be called on paths that are directories, in which case the reported size is dependent on the operating system. The method will <a href="/Documentable/integration-test/routine/fail"><code>fail</code></a> with <code>X::IO::DoesNotExist</code> if the path points to a non-existent filesystem entity.</p>
<pre class="pod-block-code">say $*EXECUTABLE.IO.s; # OUTPUT : «467␤»</pre>
<h2 id="(IO::Path)_method_l"><a href="/Documentable/integration-test/type/IO::Path#method_l">(IO::Path) method l</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method l(--&gt; Bool:D)</pre>
<p>Returns <code>True</code> if the invocant is a path that exists and is a symlink. The method will <a href="/Documentable/integration-test/routine/fail"><code>fail</code></a> with <code>X::IO::DoesNotExist</code> if the path points to a non-existent filesystem entity.</p>
<h2 id="(IO::Path)_method_r"><a href="/Documentable/integration-test/type/IO::Path#method_r">(IO::Path) method r</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method r(--&gt; Bool:D)</pre>
<p>Returns <code>True</code> if the invocant is a path that exists and is accessible. The method will <a href="/Documentable/integration-test/routine/fail"><code>fail</code></a> with <code>X::IO::DoesNotExist</code> if the path points to a non-existent filesystem entity.</p>
<h2 id="(IO::Path)_method_w"><a href="/Documentable/integration-test/type/IO::Path#method_w">(IO::Path) method w</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method w(--&gt; Bool:D)</pre>
<p>Returns <code>True</code> if the invocant is a path that exists and is writable. The method will <a href="/Documentable/integration-test/routine/fail"><code>fail</code></a> with <code>X::IO::DoesNotExist</code> if the path points to a non-existent filesystem entity.</p>
<h2 id="(IO::Path)_method_rw"><a href="/Documentable/integration-test/type/IO::Path#method_rw">(IO::Path) method rw</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method rw(--&gt; Bool:D)</pre>
<p>Returns <code>True</code> if the invocant is a path that exists and is readable and writable. The method will <a href="/Documentable/integration-test/routine/fail"><code>fail</code></a> with <code>X::IO::DoesNotExist</code> if the path points to a non-existent filesystem entity.</p>
<h2 id="(IO::Path)_method_x"><a href="/Documentable/integration-test/type/IO::Path#method_x">(IO::Path) method x</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method x(--&gt; Bool:D)</pre>
<p>Returns <code>True</code> if the invocant is a path that exists and is executable. The method will <a href="/Documentable/integration-test/routine/fail"><code>fail</code></a> with <code>X::IO::DoesNotExist</code> if the path points to a non-existent filesystem entity.</p>
<h2 id="(IO::Path)_method_rwx"><a href="/Documentable/integration-test/type/IO::Path#method_rwx">(IO::Path) method rwx</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method rwx(--&gt; Bool:D)</pre>
<p>Returns <code>True</code> if the invocant is a path that exists and is executable, readable, and writable. The method will <a href="/Documentable/integration-test/routine/fail"><code>fail</code></a> with <code>X::IO::DoesNotExist</code> if the path points to a non-existent filesystem entity.</p>
<h2 id="(IO::Path)_method_z"><a href="/Documentable/integration-test/type/IO::Path#method_z">(IO::Path) method z</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method z(--&gt; Bool:D)</pre>
<p>Returns <code>True</code> if the invocant is a path that exists and has size of <code>0</code>. May be called on paths that are directories, in which case the reported file size (and thus the result of this method) is dependent on the operating system. The method will <a href="/Documentable/integration-test/routine/fail"><code>fail</code></a> with <code>X::IO::DoesNotExist</code> if the path points to a non-existent filesystem entity.</p>
<h2 id="(IO::Path)_method_sibling"><a href="/Documentable/integration-test/type/IO::Path#method_sibling">(IO::Path) method sibling</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method sibling(IO::Path:D: Str() $sibling --&gt; IO::Path:D)</pre>
<p>Allows to reference a sibling file or directory. Returns a new <a href="/Documentable/integration-test/type/IO::Path"><code>IO::Path</code></a> based on the invocant, with the <a href="/Documentable/integration-test/type/IO::Path#method_basename"><code>.basename</code></a> changed to <code>$sibling</code>. The <code>$sibling</code> is allowed to be a multi-part path fragment; see also <a href="/Documentable/integration-test/type/IO::Path#method_add"><code>.add</code></a>.</p>
<pre class="pod-block-code">say &#39;.bashrc&#39;.IO.sibling: &#39;.bash_aliases&#39;; # OUTPUT: «.bash_aliases&quot;.IO␤»
say &#39;/home/camelia/.bashrc&#39;.IO.sibling: &#39;.bash_aliases&#39;;
# OUTPUT: «/home/camelia/.bash_aliases&quot;.IO␤»

say &#39;/foo/&#39; .IO.sibling: &#39;bar&#39;;  # OUTPUT: «/bar&quot;.IO␤»
say &#39;/foo/.&#39;.IO.sibling: &#39;bar&#39;;  # OUTPUT: «/foo/bar&quot;.IO␤»</pre>
<h2 id="(IO::Path)_method_words"><a href="/Documentable/integration-test/type/IO::Path#method_words">(IO::Path) method words</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method words(IO::Path:D: :$chomp = True, :$enc = &#39;utf8&#39;, :$nl-in = [&quot;\x0A&quot;, &quot;\r\n&quot;], |c --&gt; Seq:D)</pre>
<p>Opens the invocant and returns its <a href="/Documentable/integration-test/type/IO::Handle#routine_words">words</a>.</p>
<p>The behavior is equivalent to <a href="/Documentable/integration-test/routine/open">opening</a> the file specified by the invocant, forwarding the <code>:$chomp</code>, <code>:$enc</code>, and <code>:$nl-in</code> arguments to <a href="/Documentable/integration-test/type/IO::Handle#routine_open"><code>IO::Handle.open</code></a>, then calling <a href="/Documentable/integration-test/type/IO::Handle#routine_words"><code>IO::Handle.words</code></a> on that handle, forwarding any of the remaining arguments to that method, and returning the resultant <a href="/Documentable/integration-test/type/Seq">Seq</a>.</p>
<p><strong>NOTE:</strong> words are lazily read. The handle used under the hood is not closed until the returned <a href="/Documentable/integration-test/type/Seq">Seq</a> is <a href="/Documentable/integration-test/language/glossary#index-entry-Reify">fully reified</a>, and this could lead to leaking open filehandles. It is possible to avoid leaking open filehandles using the <a href="/Documentable/integration-test/type/IO::Handle#routine_words"><code>$limit</code> argument</a> to cut down the <code>Seq</code> of words to be generated.</p>
<pre class="pod-block-code">my %dict := bag &#39;my-file.txt&#39;.IO.words;
say &quot;Most common words: &quot;, %dict.sort(-*.value).head: 5;
</pre>
<h2 id="(IO::Path)_method_lines"><a href="/Documentable/integration-test/type/IO::Path#method_lines">(IO::Path) method lines</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method lines(IO::Path:D: :$chomp = True, :$enc = &#39;utf8&#39;, :$nl-in = [&quot;\x0A&quot;, &quot;\r\n&quot;], |c --&gt; Seq:D)</pre>
<p>Opens the invocant and returns its <a href="/Documentable/integration-test/type/IO::Handle#routine_lines">lines</a>.</p>
<p>The behavior is equivalent to <a href="/Documentable/integration-test/routine/open">opening</a> the file specified by the invocant, forwarding the <code>:$chomp</code>, <code>:$enc</code>, and <code>:$nl-in</code> arguments to <a href="/Documentable/integration-test/type/IO::Handle#routine_open"><code>IO::Handle.open</code></a>, then calling <a href="/Documentable/integration-test/type/IO::Handle#routine_lines"><code>IO::Handle.lines</code></a> on that handle, forwarding any of the remaining arguments to that method, and returning the resultant <a href="/Documentable/integration-test/type/Seq">Seq</a>.</p>
<p><strong>NOTE:</strong> the lines are ready lazily and the handle used under the hood won&#39;t get closed until the returned <a href="/Documentable/integration-test/type/Seq">Seq</a> is <a href="/Documentable/integration-test/language/glossary#index-entry-Reify">fully reified</a>, so ensure it is, or you&#39;ll be leaking open filehandles. (TIP: use the <a href="/Documentable/integration-test/type/IO::Handle#routine_lines"><code>$limit</code> argument</a>)</p>
<pre class="pod-block-code">say &quot;The file contains &quot;,
  &#39;50GB-file&#39;.IO.lines.grep(*.contains: &#39;Perl&#39;).elems,
  &quot; lines that mention Perl&quot;;
# OUTPUT: «The file contains 72 lines that mention Perl␤»
</pre>
<h2 id="(IO::Path)_routine_slurp"><a href="/Documentable/integration-test/type/IO::Path#routine_slurp">(IO::Path) routine slurp</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method slurp(IO::Path:D: :$bin, :$enc)</pre>
<p>Read all of the file&#39;s content and return it as either <a href="/Documentable/integration-test/type/Buf">Buf</a>, if <code>:$bin</code> is <code>True</code>, or if not, as <a href="/Documentable/integration-test/type/Str">Str</a> decoded with <code>:$enc</code> encoding, which defaults to <code>utf8</code>. File will be closed afterwards. See <a href="/Documentable/integration-test/routine/open"><code>&amp;open</code></a> for valid values for <code>:$enc</code>.</p>
<h2 id="(IO::Path)_method_spurt"><a href="/Documentable/integration-test/type/IO::Path#method_spurt">(IO::Path) method spurt</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method spurt(IO::Path:D: $data, :$enc, :$append, :$createonly)</pre>
<p>Opens the file path for writing, and writes all of the <code>$data</code> into it. File will be closed, afterwards. Will <a href="/Documentable/integration-test/routine/fail"><code>fail</code></a> if it cannot succeed for any reason. The <code>$data</code> can be any <a href="/Documentable/integration-test/type/Cool"><code>Cool</code></a> type or any <a href="/Documentable/integration-test/type/Blob"><code>Blob</code></a> type. Arguments are as follows:</p>
<li><p><code>:$enc</code> — character encoding of the data. Takes same values as <code>:$enc</code> in <a href="/Documentable/integration-test/routine/open"><code>IO::Handle.open</code></a>. Defaults to <code>utf8</code>. Ignored if <code>$data</code> is a <a href="/Documentable/integration-test/type/Blob"><code>Blob</code></a>.</p>
</li>
<li><p><code>:$append</code> — open the file in <code>append</code> mode, preserving existing contents, and appending data to the end of the file.</p>
</li>
<li><p><code>:$createonly</code> — <a href="/Documentable/integration-test/routine/fail"><code>fail</code></a> if the file already exists.</p>
</li>
<h2 id="(IO::Path)_method_chdir"><a href="/Documentable/integration-test/type/IO::Path#method_chdir">(IO::Path) method chdir</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method chdir(IO::Path:D: Str() $path, :$d = True, :$r, :$w, :$x)</pre>
<p><strong>DEPRECATION NOTICE:</strong> this method will be deprecated in <code>6.d</code> language and removed in <code>6.e</code>. Do not use it for new code. Instead, create a new path or use <a href="/Documentable/integration-test/routine/add"><code>add</code></a> method. For altering current working directory see <a href="/Documentable/integration-test/routine/chdir"><code>&amp;chdir</code></a> and <a href="/Documentable/integration-test/routine/&*chdir"><code>&amp;*chdir</code></a> subroutines.</p>
<p>Contrary to the name, the <code>.chdir</code> method does not change any directories, but merely concatenates the given <code>$path</code> to the invocant and returns the resultant <code>IO::Path</code>. Optional file tests can be performed by providing <code>:d</code>, <code>:r</code>, <code>:w</code>, or <code>:x</code> <a href="/Documentable/integration-test/type/Bool"><code>Bool</code></a> named arguments; when set to <code>True</code>, they&#39;ll perform <a href="/Documentable/integration-test/routine/d"><code>.d</code></a>, <a href="/Documentable/integration-test/routine/r"><code>.r</code></a>, <a href="/Documentable/integration-test/routine/w"><code>.w</code></a>, and <a href="/Documentable/integration-test/routine/x"><code>.x</code></a> tests respectively. By default, only <code>:d</code> is set to <code>True</code>.</p>
<h2 id="(IO::Path)_method_mkdir"><a href="/Documentable/integration-test/type/IO::Path#method_mkdir">(IO::Path) method mkdir</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method mkdir(IO::Path:D: Int() $mode = 0o777 --&gt; IO::Path:D)</pre>
<p>Creates a new directory, including its parent directories, as needed (similar to *nix utility <code>mkdir</code> with <code>-p</code> option). That is, <code>mkdir &quot;foo/bar/ber/meow&quot;</code> will create <code>foo</code>, <code>foo/bar</code>, and <code>foo/bar/ber</code> directories as well if they do not exist.</p>
<p>Returns the <a href="/Documentable/integration-test/type/IO::Path">IO::Path</a> object pointing to the newly created directory on success; <a href="/Documentable/integration-test/routine/fail">fails</a> with <a href="/Documentable/integration-test/type/X::IO::Mkdir">X::IO::Mkdir</a> if directory cannot be created.</p>
<p>See also <a href="/Documentable/integration-test/routine/mode"><code>mode</code></a> for explanation and valid values for <code>$mode</code>.</p>
<h2 id="(IO::Path)_routine_rmdir"><a href="/Documentable/integration-test/type/IO::Path#routine_rmdir">(IO::Path) routine rmdir</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub    rmdir(*@dirs --&gt; List:D)
method rmdir(IO::Path:D: --&gt; True)</pre>
<p>Remove the invocant, or in sub form, all of the provided directories in the given list, which can contain any <a href="/Documentable/integration-test/type/Cool">Cool</a> object. Only works on empty directories.</p>
<p>Method form returns <code>True</code> on success and returns a <a href="/Documentable/integration-test/type/Failure">Failure</a> of type <code>X::IO::Rmdir</code> if the directory cannot be removed (e.g. the directory is not empty, or the path is not a directory). Subroutine form returns a list of directories that were successfully deleted.</p>
<p>To delete non-empty directory, see <a href="https://github.com/labster/p6-file-directory-tree">rmtree in <code>File::Directory::Tree</code> module</a>.</p>
<h2 id="(IO::Path)_method_chmod"><a href="/Documentable/integration-test/type/IO::Path#method_chmod">(IO::Path) method chmod</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method chmod(IO::Path:D: Int() $mode --&gt; Bool)</pre>
<p>Changes the POSIX permissions of a file or directory to <code>$mode</code>. Returns <code>True</code> on success; on failure, <a href="/Documentable/integration-test/routine/fail">fails</a> with <a href="/Documentable/integration-test/type/X::IO::Chmod">X::IO::Chmod</a>.</p>
<p>The mode is expected as an integer following the <a href="https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation">standard numeric notation</a>, and is best written as an octal number:</p>
<pre class="pod-block-code">&#39;myfile&#39;.IO.chmod(0o444);          # make a file read-only
&#39;somedir&#39;.IO.chmod(0o777);         # set 0777 permissions on a directory
</pre>
<p>Make sure you <em>don&#39;t</em> accidentally pass the intended octal digits as a decimal number (or string containing a decimal number):</p>
<pre class="pod-block-code">&#39;myfile&#39;.IO.chmod:  &#39;0444&#39;;        # BAD!!! (interpreted as mode 0o674)
&#39;myfile&#39;.IO.chmod: &#39;0o444&#39;;        # OK (an octal in a string)
&#39;myfile&#39;.IO.chmod:  0o444;         # Also OK (an octal literal)
</pre>
<h2 id="(IO::Path)_routine_rename"><a href="/Documentable/integration-test/type/IO::Path#routine_rename">(IO::Path) routine rename</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method rename(IO::Path:D: IO() $to, :$createonly = False --&gt; Bool:D)
sub    rename(IO() $from, IO() $to, :$createonly = False --&gt; Bool:D)</pre>
<p>Renames a file or directory. Returns <code>True</code> on success; <a href="/Documentable/integration-test/routine/fail">fails</a> with <a href="/Documentable/integration-test/type/X::IO::Rename">X::IO::Rename</a> if <code>:$createonly</code> is <code>True</code> and the <code>$to</code> path already exists or if the operation failed for some other reason.</p>
<p><strong>Note:</strong> some renames will always fail, such as when the new name is on a different storage device. See also: <a href="/Documentable/integration-test/routine/move"><code>move</code></a>.</p>
<h2 id="(IO::Path)_routine_copy"><a href="/Documentable/integration-test/type/IO::Path#routine_copy">(IO::Path) routine copy</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method copy(IO::Path:D: IO() $to, :$createonly --&gt; Bool:D)
sub    copy(IO() $from, IO() $to, :$createonly --&gt; Bool:D)</pre>
<p>Copies a file. Returns <code>True</code> on success; <a href="/Documentable/integration-test/routine/fail">fails</a> with <a href="/Documentable/integration-test/type/X::IO::Copy">X::IO::Copy</a> if <code>:$createonly</code> is <code>True</code> and the <code>$to</code> path already exists or if the operation failed for some other reason, such as when <code>$to</code> and <code>$from</code> are the same file.</p>
<h2 id="(IO::Path)_routine_move"><a href="/Documentable/integration-test/type/IO::Path#routine_move">(IO::Path) routine move</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method move(IO::Path:D: IO() $to, :$createonly --&gt; Bool:D)
sub    move(IO() $from, IO() $to, :$createonly --&gt; Bool:D)</pre>
<p>Copies a file and then removes the original. If removal fails, it&#39;s possible to end up with two copies of the file. Returns <code>True</code> on success; <a href="/Documentable/integration-test/routine/fail">fails</a> with <a href="/Documentable/integration-test/type/X::IO::Move">X::IO::Move</a> if <code>:$createonly</code> is <code>True</code> and the <code>$to</code> path already exists or if the operation failed for some other reason, such as when <code>$to</code> and <code>$from</code> are the same file.</p>
<p>To avoid copying, you can use <a href="/Documentable/integration-test/routine/rename"><code>rename</code></a>, if the files are on the same storage device. It also works with directories, while <code>move</code> does not.</p>
<h2 id="(IO::Path)_method_Numeric"><a href="/Documentable/integration-test/type/IO::Path#method_Numeric">(IO::Path) method Numeric</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Numeric(IO::Path:D: --&gt; Numeric:D)</pre>
<p>Coerces <a href="/Documentable/integration-test/routine/basename"><code>.basename</code></a> to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>. <a href="/Documentable/integration-test/routine/fail">Fails</a> with <code>X::Str::Numeric</code> if base name is not numerical.</p>
<h2 id="(IO::Path)_method_Int"><a href="/Documentable/integration-test/type/IO::Path#method_Int">(IO::Path) method Int</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Int(IO::Path:D: --&gt; Int:D)</pre>
<p>Coerces <a href="/Documentable/integration-test/routine/basename"><code>.basename</code></a> to <a href="/Documentable/integration-test/type/Int">Int</a>. <a href="/Documentable/integration-test/routine/fail">Fails</a> with <code>X::Str::Numeric</code> if base name is not numerical.</p>
<p><a name="Documentable/integration-test/index-entry-symlink_(sub)"></a> <a name="Documentable/integration-test/index-entry-symlink_(method)"></a></p>
<h2 id="(IO::Path)_routine_symlink"><a href="/Documentable/integration-test/type/IO::Path#routine_symlink">(IO::Path) routine symlink</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method symlink(IO::Path:D $target: IO() $link --&gt; Bool:D)
sub    symlink(      IO() $target, IO() $link --&gt; Bool:D)</pre>
<p>Create a new <em>symbolic</em> link <code>$link</code> to existing <code>$target</code>. Returns <code>True</code> on success; <a href="/Documentable/integration-test/routine/fail">fails</a> with <a href="/Documentable/integration-test/type/X::IO::Symlink">X::IO::Symlink</a> if the symbolic link could not be created. If <code>$target</code> does not exist, creates a dangling symbolic link. To create a hard link, see <a href="/Documentable/integration-test/routine/link"><code>link</code></a>.</p>
<p><strong>Note:</strong> on Windows, creation of symbolic links may require escalated privileges.</p>
<p><a name="Documentable/integration-test/index-entry-link_(sub)"></a> <a name="Documentable/integration-test/index-entry-link_(method)"></a></p>
<h2 id="(IO::Path)_routine_link"><a href="/Documentable/integration-test/type/IO::Path#routine_link">(IO::Path) routine link</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method link(IO::Path:D $target: IO() $link --&gt; Bool:D)
sub    link(      IO() $target, IO() $link --&gt; Bool:D)</pre>
<p>Create a new <em>hard</em> link <code>$link</code> to existing <code>$target</code>. Returns <code>True</code> on success; <a href="/Documentable/integration-test/routine/fail">fails</a> with <a href="/Documentable/integration-test/type/X::IO::Link">X::IO::Link</a> if the hard link could not be created. To create a symbolic link, see <a href="/Documentable/integration-test/routine/symlink"><code>symlink</code></a>.</p>
<h2 id="(IO::Path)_routine_unlink"><a href="/Documentable/integration-test/type/IO::Path#routine_unlink">(IO::Path) routine unlink</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method unlink(IO::Path:D: --&gt; True)
sub    unlink(*@filenames --&gt; List:D)</pre>
<p>Delete all specified ordinary files, links, or symbolic links for which there are privileges to do so. See <a href="/Documentable/integration-test/routine/rmdir">rmdir</a> to delete directories.</p>
<p>The subroutine form returns the names of all the files in the list, excluding those for which the filesystem raised some error; since trying to delete a file that does not exist does not raise any error at that level, this list will include the names of the files in the list that do not exist.</p>
<p>The method form returns <code>True</code> on success, or <a href="/Documentable/integration-test/routine/fail">fails</a> with <a href="/Documentable/integration-test/type/X::IO::Unlink">X::IO::Unlink</a> if the operation could not be completed. If the file to be deleted does not exist, the routine treats it as success.</p>
<pre class="pod-block-code">&#39;foo.txt&#39;.IO.open(:w).close;
&#39;bar&#39;.IO.mkdir;
say unlink &lt;foo.txt  bar  not-there.txt&gt;; # OUTPUT: «[foo.txt not-there.txt]␤»
# `bar` is not in output because it failed to delete (it&#39;s a directory)
# `not-there.txt` is present. It never existed, so that&#39;s deemed a success.

# Method form `fail`s:
say .exception.message without &#39;bar&#39;.IO.unlink;
# OUTPUT: «Failed to remove the file […] illegal operation on a directory␤»
</pre>
<h2 id="(IO::Path)_method_IO"><a href="/Documentable/integration-test/type/IO::Path#method_IO">(IO::Path) method IO</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method IO(IO::Path:D: --&gt; IO::Path)</pre>
<p>Returns the invocant.</p>
<h2 id="(IO::Path)_method_SPEC"><a href="/Documentable/integration-test/type/IO::Path#method_SPEC">(IO::Path) method SPEC</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method SPEC(IO::Path:D: --&gt; IO::Spec)</pre>
<p>Returns the <a href="/Documentable/integration-test/type/IO::Spec">IO::Spec</a> object that was (implicitly) specified at object creation time.</p>
<pre class="pod-block-code">my $io = IO::Path.new(&quot;/bin/bash&quot;);
say $io.SPEC;                            # OUTPUT: «(Unix)␤»
say $io.SPEC.dir-sep;                    # OUTPUT: «/␤»</pre>
<h2 id="(IO::Path)_method_modified"><a href="/Documentable/integration-test/type/IO::Path#method_modified">(IO::Path) method modified</a></h2>
<p>Returns an <a href="/Documentable/integration-test/type/Instant"><code>Instant</code></a> object indicating when the content of the file was last modified. Compare with <a href="/Documentable/integration-test/routine/changed">changed</a>.</p>
<pre class="pod-block-code">say &quot;path/to/file&quot;.IO.modified;          # Instant:1424089165
say &quot;path/to/file&quot;.IO.modified.DateTime; # 2015-02-16T12:18:50Z
</pre>
<h2 id="(IO::Path)_method_accessed"><a href="/Documentable/integration-test/type/IO::Path#method_accessed">(IO::Path) method accessed</a></h2>
<p>Return an <a href="/Documentable/integration-test/type/Instant">Instant</a> object representing the timestamp when the file was last accessed. <strong>Note:</strong> depending on how the filesystem was mounted, the last accessed time may not update on <em>each access</em> to the file, but only on the first access after modifications.</p>
<pre class="pod-block-code">say &quot;path/to/file&quot;.IO.accessed;          # Instant:1424353577
say &quot;path/to/file&quot;.IO.accessed.DateTime; # 2015-02-19T13:45:42Z
</pre>
<h2 id="(IO::Path)_method_changed"><a href="/Documentable/integration-test/type/IO::Path#method_changed">(IO::Path) method changed</a></h2>
<p>Returns an <a href="/Documentable/integration-test/type/Instant"><code>Instant</code></a> object indicating the metadata of the file or directory was last changed (e.g. permissions, or files created/deleted in directory). Compare with <a href="/Documentable/integration-test/routine/modified">modified</a>.</p>
<pre class="pod-block-code">say &quot;path/to/file&quot;.IO.changed;           # Instant:1424089165
say &quot;path/to/file&quot;.IO.changed.DateTime;  # 2015-02-16T12:18:50Z
</pre>
<h2 id="(IO::Path)_method_mode"><a href="/Documentable/integration-test/type/IO::Path#method_mode">(IO::Path) method mode</a></h2>
<p>Return an <a href="/Documentable/integration-test/type/IntStr">IntStr</a> object representing the POSIX permissions of a file. The <code>Str</code> part of the result is the octal representation of the file permission, like the form accepted by the <code>chmod(1)</code> utility.</p>
<pre class="pod-block-code">say ~&quot;path/to/file&quot;.IO.mode;  # e.g. &#39;0644&#39;
say +&quot;path/to/file&quot;.IO.mode;  # e.g. 420, where sprintf(&#39;%04o&#39;, 420) eq &#39;0644&#39;
</pre>
<p>The result of this can be used in the other methods that take a mode as an argument.</p>
<pre class="pod-block-code">&quot;path/to/file1&quot;.IO.chmod(&quot;path/to/file2&quot;.IO.mode);  # will change the
                                                    # permissions of file1
                                                    # to be the same as file2
</pre>
<h1 id="Routines_supplied_by_class_Cool"><a class="u" href="#___top" title="go to top of document">Routines supplied by class Cool</a></h1>
<p>IO::Path::Unix inherits from class <a href="/Documentable/integration-test/type/Cool">Cool</a>, which provides the following routines:</p>
<h2 id="(Cool)_routine_abs"><a href="/Documentable/integration-test/type/Cool#routine_abs">(Cool) routine abs</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub abs(Numeric() $x)
method abs()</pre>
<p>Coerces the invocant (or in the sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> and returns the absolute value (that is, a non-negative number).</p>
<pre class="pod-block-code">say (-2).abs;       # OUTPUT: «2␤»
say abs &quot;6+8i&quot;;     # OUTPUT: «10␤»</pre>
<h2 id="(Cool)_method_conj"><a href="/Documentable/integration-test/type/Cool#method_conj">(Cool) method conj</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method conj()</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> and returns the <a href="/Documentable/integration-test/type/Complex">complex</a> conjugate (that is, the number with the sign of the imaginary part negated).</p>
<pre class="pod-block-code">say (1+2i).conj;        # OUTPUT: «1-2i␤»</pre>
<h2 id="(Cool)_routine_EVAL"><a href="/Documentable/integration-test/type/Cool#routine_EVAL">(Cool) routine EVAL</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method EVAL(*%_)
</pre>
<p>It calls the <a href="/Documentable/integration-test/language/independent-routines#routine_EVAL">subroutine form</a> with the invocant as the first argument, <code>$code</code>, passing along named args, if any.</p>
<h2 id="(Cool)_routine_sqrt"><a href="/Documentable/integration-test/type/Cool#routine_sqrt">(Cool) routine sqrt</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub sqrt(Numeric(Cool) $x)
method sqrt()</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> (or in the sub form, the argument) and returns the square root, that is, a non-negative number that, when multiplied with itself, produces the original number.</p>
<pre class="pod-block-code">say 4.sqrt;             # OUTPUT: «2␤»
say sqrt(2);            # OUTPUT: «1.4142135623731␤»</pre>
<h2 id="(Cool)_method_sign"><a href="/Documentable/integration-test/type/Cool#method_sign">(Cool) method sign</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method sign()</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Real">Numeric</a> and returns its sign, that is, 0 if the number is 0, 1 for positive and -1 for negative values.</p>
<pre class="pod-block-code">say 6.sign;             # OUTPUT: «1␤»
say (-6).sign;          # OUTPUT: «-1␤»
say &quot;0&quot;.sign;           # OUTPUT: «0␤»</pre>
<h2 id="(Cool)_method_rand"><a href="/Documentable/integration-test/type/Cool#method_rand">(Cool) method rand</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method rand()</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Num">Num</a> and returns a pseudo-random value between zero and the number.</p>
<pre class="pod-block-code">say 1e5.rand;           # OUTPUT: «33128.495184283␤»</pre>
<h2 id="(Cool)_routine_sin"><a href="/Documentable/integration-test/type/Cool#routine_sin">(Cool) routine sin</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub sin(Numeric(Cool))
method sin()</pre>
<p>Coerces the invocant (or in the sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians, returns its <a href="https://en.wikipedia.org/wiki/Sine">sine</a>.</p>
<pre class="pod-block-code">say sin(0);             # OUTPUT: «0␤»
say sin(pi/4);          # OUTPUT: «0.707106781186547␤»
say sin(pi/2);          # OUTPUT: «1␤»</pre>
<p>Note that Raku is no computer algebra system, so <code>sin(pi)</code> typically does not produce an exact 0, but rather a very small <a href="/Documentable/integration-test/type/Num">floating-point number</a>.</p>
<h2 id="(Cool)_routine_asin"><a href="/Documentable/integration-test/type/Cool#routine_asin">(Cool) routine asin</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub asin(Numeric(Cool))
method asin()</pre>
<p>Coerces the invocant (or in the sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arc-sine</a> in radians.</p>
<pre class="pod-block-code">say 0.1.asin;               # OUTPUT: «0.10016742116156␤»
say asin(0.1);              # OUTPUT: «0.10016742116156␤»</pre>
<h2 id="(Cool)_routine_cos"><a href="/Documentable/integration-test/type/Cool#routine_cos">(Cool) routine cos</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cos(Numeric(Cool))
method cos()</pre>
<p>Coerces the invocant (or in sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians, returns its <a href="https://en.wikipedia.org/wiki/Cosine">cosine</a>.</p>
<pre class="pod-block-code">say 0.cos;                  # OUTPUT: «1␤»
say pi.cos;                 # OUTPUT: «-1␤»
say cos(pi/2);              # OUTPUT: «6.12323399573677e-17␤»</pre>
<h2 id="(Cool)_routine_acos"><a href="/Documentable/integration-test/type/Cool#routine_acos">(Cool) routine acos</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub acos(Numeric(Cool))
method acos()</pre>
<p>Coerces the invocant (or in sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arc-cosine</a> in radians.</p>
<pre class="pod-block-code">say 1.acos;                 # OUTPUT: «0␤»
say acos(-1);               # OUTPUT: «3.14159265358979␤»</pre>
<h2 id="(Cool)_routine_tan"><a href="/Documentable/integration-test/type/Cool#routine_tan">(Cool) routine tan</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub tan(Numeric(Cool))
method tan()</pre>
<p>Coerces the invocant (or in sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians, returns its <a href="https://en.wikipedia.org/wiki/Tangent">tangent</a>.</p>
<pre class="pod-block-code">say tan(3);                 # OUTPUT: «-0.142546543074278␤»
say 3.tan;                  # OUTPUT: «-0.142546543074278␤»</pre>
<h2 id="(Cool)_routine_atan"><a href="/Documentable/integration-test/type/Cool#routine_atan">(Cool) routine atan</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub atan(Numeric(Cool))
method atan()</pre>
<p>Coerces the invocant (or in sub form, the argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arc-tangent</a> in radians.</p>
<pre class="pod-block-code">say atan(3);                # OUTPUT: «1.24904577239825␤»
say 3.atan;                 # OUTPUT: «1.24904577239825␤»</pre>
<h2 id="(Cool)_routine_atan2"><a href="/Documentable/integration-test/type/Cool#routine_atan2">(Cool) routine atan2</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub atan2($y, $x = 1e0)
method atan2($x = 1e0)</pre>
<p>The sub should usually be written with two arguments for clarity as it is seen in other languages and in mathematical texts, but the single-argument form is available; its result will always match that of <a href="/Documentable/integration-test/routine/atan">atan</a>.</p>
<pre class="pod-block-code">say atan2 3, 1;             # OUTPUT: «1.2490457723982544␤»
say atan2 3;                # OUTPUT: «1.2490457723982544␤»
say atan2 ⅔, ⅓;             # OUTPUT: «1.1071487177940904␤»</pre>
<p>The method coerces self and its single argument to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, using them to compute the two-argument <a href="https://en.wikipedia.org/wiki/Atan2">arc-tangent</a> in radians.</p>
<pre class="pod-block-code">say 3.atan2;                # OUTPUT: «1.24904577239825␤»
say ⅔.atan2(⅓);             # OUTPUT: «1.1071487177940904␤»</pre>
<p>The $x argument in either the method or the sub defaults to 1 so, in both single-argument cases, the function will return the angle θ in radians between the x-axis and a vector that goes from the origin to the point (3, 1).</p>
<h2 id="(Cool)_routine_sec"><a href="/Documentable/integration-test/type/Cool#routine_sec">(Cool) routine sec</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub sec(Numeric(Cool))
method sec()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians, returns its <a href="https://en.wikipedia.org/wiki/Trigonometric_functions#Reciprocal_functions">secant</a>, that is, the reciprocal of its cosine.</p>
<pre class="pod-block-code">say 45.sec;                 # OUTPUT: «1.90359440740442␤»
say sec(45);                # OUTPUT: «1.90359440740442␤»</pre>
<h2 id="(Cool)_routine_asec"><a href="/Documentable/integration-test/type/Cool#routine_asec">(Cool) routine asec</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub asec(Numeric(Cool))
method asec()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arc-secant</a> in radians.</p>
<pre class="pod-block-code">say 1.asec;                 # OUTPUT: «0␤»
say sqrt(2).asec;           # OUTPUT: «0.785398163397448␤»</pre>
<h2 id="(Cool)_routine_cosec"><a href="/Documentable/integration-test/type/Cool#routine_cosec">(Cool) routine cosec</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cosec(Numeric(Cool))
method cosec()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians, returns its <a href="https://en.wikipedia.org/wiki/Trigonometric_functions#Reciprocal_functions">cosecant</a>, that is, the reciprocal of its sine.</p>
<pre class="pod-block-code">say 0.45.cosec;             # OUTPUT: «2.29903273150897␤»
say cosec(0.45);            # OUTPUT: «2.29903273150897␤»</pre>
<h2 id="(Cool)_routine_acosec"><a href="/Documentable/integration-test/type/Cool#routine_acosec">(Cool) routine acosec</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub acosec(Numeric(Cool))
method acosec()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arc-cosecant</a> in radians.</p>
<pre class="pod-block-code">say 45.acosec;              # OUTPUT: «0.0222240516182672␤»
say acosec(45)              # OUTPUT: «0.0222240516182672␤»</pre>
<h2 id="(Cool)_routine_cotan"><a href="/Documentable/integration-test/type/Cool#routine_cotan">(Cool) routine cotan</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cotan(Numeric(Cool))
method cotan()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians, returns its <a href="https://en.wikipedia.org/wiki/Trigonometric_functions#Reciprocal_functions">cotangent</a>, that is, the reciprocal of its tangent.</p>
<pre class="pod-block-code">say 45.cotan;               # OUTPUT: «0.617369623783555␤»
say cotan(45);              # OUTPUT: «0.617369623783555␤»</pre>
<h2 id="(Cool)_routine_acotan"><a href="/Documentable/integration-test/type/Cool#routine_acotan">(Cool) routine acotan</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub acotan(Numeric(Cool))
method acotan()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arc-cotangent</a> in radians.</p>
<pre class="pod-block-code">say 45.acotan;              # OUTPUT: «0.0222185653267191␤»
say acotan(45)              # OUTPUT: «0.0222185653267191␤»</pre>
<h2 id="(Cool)_routine_sinh"><a href="/Documentable/integration-test/type/Cool#routine_sinh">(Cool) routine sinh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub sinh(Numeric(Cool))
method sinh()</pre>
<p>Coerces the invocant (or in method form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Sine hyperbolicus</a>.</p>
<pre class="pod-block-code">say 1.sinh;                 # OUTPUT: «1.1752011936438␤»
say sinh(1);                # OUTPUT: «1.1752011936438␤»</pre>
<h2 id="(Cool)_routine_asinh"><a href="/Documentable/integration-test/type/Cool#routine_asinh">(Cool) routine asinh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub asinh(Numeric(Cool))
method asinh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_hyperbolic_function">Inverse Sine hyperbolicus</a>.</p>
<pre class="pod-block-code">say 1.asinh;                # OUTPUT: «0.881373587019543␤»
say asinh(1);               # OUTPUT: «0.881373587019543␤»</pre>
<h2 id="(Cool)_routine_cosh"><a href="/Documentable/integration-test/type/Cool#routine_cosh">(Cool) routine cosh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cosh(Numeric(Cool))
method cosh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Cosine hyperbolicus</a>.</p>
<pre class="pod-block-code">say cosh(0.5);              # OUTPUT: «1.12762596520638␤»</pre>
<h2 id="(Cool)_routine_acosh"><a href="/Documentable/integration-test/type/Cool#routine_acosh">(Cool) routine acosh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub acosh(Numeric(Cool))
method acosh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_hyperbolic_function">Inverse Cosine hyperbolicus</a>.</p>
<pre class="pod-block-code">say acosh(45);              # OUTPUT: «4.4996861906715␤»</pre>
<h2 id="(Cool)_routine_tanh"><a href="/Documentable/integration-test/type/Cool#routine_tanh">(Cool) routine tanh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub tanh(Numeric(Cool))
method tanh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, interprets it as radians and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Tangent hyperbolicus</a>.</p>
<pre class="pod-block-code">say tanh(0.5);              # OUTPUT: «0.46211715726001␤»
say tanh(atanh(0.5));       # OUTPUT: «0.5␤»</pre>
<h2 id="(Cool)_routine_atanh"><a href="/Documentable/integration-test/type/Cool#routine_atanh">(Cool) routine atanh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub atanh(Numeric(Cool))
method atanh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_hyperbolic_function">Inverse tangent hyperbolicus</a>.</p>
<pre class="pod-block-code">say atanh(0.5);             # OUTPUT: «0.549306144334055␤»</pre>
<h2 id="(Cool)_routine_sech"><a href="/Documentable/integration-test/type/Cool#routine_sech">(Cool) routine sech</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub sech(Numeric(Cool))
method sech()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Secant hyperbolicus</a>.</p>
<pre class="pod-block-code">say 0.sech;                 # OUTPUT: «1␤»</pre>
<h2 id="(Cool)_routine_asech"><a href="/Documentable/integration-test/type/Cool#routine_asech">(Cool) routine asech</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub asech(Numeric(Cool))
method asech()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Inverse hyperbolic secant</a>.</p>
<pre class="pod-block-code">say 0.8.asech;              # OUTPUT: «0.693147180559945␤»</pre>
<h2 id="(Cool)_routine_cosech"><a href="/Documentable/integration-test/type/Cool#routine_cosech">(Cool) routine cosech</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cosech(Numeric(Cool))
method cosech()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Hyperbolic cosecant</a>.</p>
<pre class="pod-block-code">say cosech(pi/2);           # OUTPUT: «0.434537208094696␤»</pre>
<h2 id="(Cool)_routine_acosech"><a href="/Documentable/integration-test/type/Cool#routine_acosech">(Cool) routine acosech</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub acosech(Numeric(Cool))
method acosech()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_hyperbolic_function">Inverse hyperbolic cosecant</a>.</p>
<pre class="pod-block-code">say acosech(4.5);           # OUTPUT: «0.220432720979802␤»</pre>
<h2 id="(Cool)_routine_cotanh"><a href="/Documentable/integration-test/type/Cool#routine_cotanh">(Cool) routine cotanh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cotanh(Numeric(Cool))
method cotanh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">Hyperbolic cotangent</a>.</p>
<pre class="pod-block-code">say cotanh(pi);             # OUTPUT: «1.00374187319732␤»</pre>
<h2 id="(Cool)_routine_acotanh"><a href="/Documentable/integration-test/type/Cool#routine_acotanh">(Cool) routine acotanh</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub acotanh(Numeric(Cool))
method acotanh()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Inverse_hyperbolic_function">Inverse hyperbolic cotangent</a>.</p>
<pre class="pod-block-code">say acotanh(2.5);           # OUTPUT: «0.423648930193602␤»</pre>
<h2 id="(Cool)_routine_cis"><a href="/Documentable/integration-test/type/Cool#routine_cis">(Cool) routine cis</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub cis(Numeric(Cool))
method cis()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns <a href="https://en.wikipedia.org/wiki/Cis_%28mathematics%29">cos(argument) + i*sin(argument)</a>.</p>
<pre class="pod-block-code">say cis(pi/4);              # OUTPUT: «0.707106781186548+0.707106781186547i␤»</pre>
<h2 id="(Cool)_routine_log"><a href="/Documentable/integration-test/type/Cool#routine_log">(Cool) routine log</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub log(Numeric(Cool) $number, Numeric(Cool) $base?)
multi method log(Cool:D: Cool:D $base?)</pre>
<p>Coerces the arguments (including the invocant in the method form) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Logarithm">Logarithm</a> to base <code>$base</code>, or to base <code>e</code> (Euler&#39;s Number) if no base was supplied (<a href="https://en.wikipedia.org/wiki/Natural_logarithm">Natural logarithm</a>). Returns <code>NaN</code> if <code>$base</code> is negative. Throws an exception if <code>$base</code> is <code>1</code>.</p>
<pre class="pod-block-code">say (e*e).log;              # OUTPUT: «2␤»</pre>
<h2 id="(Cool)_routine_log10"><a href="/Documentable/integration-test/type/Cool#routine_log10">(Cool) routine log10</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub log10(Cool(Numeric))
multi method log10()</pre>
<p>Coerces the invocant (or in the sub form, the invocant) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Logarithm">Logarithm</a> to base 10, that is, a number that approximately produces the original number when raised to the power of 10. Returns <code>NaN</code> for negative arguments and <code>-Inf</code> for <code>0</code>.</p>
<pre class="pod-block-code">say log10(1001);            # OUTPUT: «3.00043407747932␤»</pre>
<h2 id="(Cool)_routine_log2"><a href="/Documentable/integration-test/type/Cool#routine_log2">(Cool) routine log2</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method log2()</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns its <a href="https://en.wikipedia.org/wiki/Logarithm">Logarithm</a> to base 2, that is, a number that approximately produces the original number when raised to the power of 2. Returns <code>NaN</code> for negative arguments and <code>-Inf</code> for <code>0</code>.</p>
<pre class="pod-block-code">say log2(5);            # OUTPUT: «2.321928094887362␤»
say &quot;4&quot;.log2;           # OUTPUT: «2␤»</pre>
<h2 id="(Cool)_routine_exp"><a href="/Documentable/integration-test/type/Cool#routine_exp">(Cool) routine exp</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub exp(Cool:D $pow, Cool:D $base?)
multi method exp(Cool:D: Cool:D $base?)</pre>
<p>Coerces the arguments (including the invocant in the method from) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns <code>$base</code> raised to the power of the first number. If no <code>$base</code> is supplied, <code>e</code> (Euler&#39;s Number) is used.</p>
<pre class="pod-block-code">say 0.exp;      # OUTPUT: «1␤»
say 1.exp;      # OUTPUT: «2.71828182845905␤»
say 10.exp;     # OUTPUT: «22026.4657948067␤»</pre>
<h2 id="(Cool)_method_unpolar"><a href="/Documentable/integration-test/type/Cool#method_unpolar">(Cool) method unpolar</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method unpolar(Numeric(Cool))</pre>
<p>Coerces the arguments (including the invocant in the method form) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and returns a complex number from the given polar coordinates. The invocant (or the first argument in sub form) is the magnitude while the argument (i.e. the second argument in sub form) is the angle. The angle is assumed to be in radians.</p>
<pre class="pod-block-code">say sqrt(2).unpolar(pi/4);      # OUTPUT: «1+1i␤»</pre>
<h2 id="(Cool)_routine_round"><a href="/Documentable/integration-test/type/Cool#routine_round">(Cool) routine round</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub round(Numeric(Cool))
multi method round(Cool:D: $unit = 1)</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and rounds it to the unit of <code>$unit</code>. If <code>$unit</code> is 1, rounds to the nearest integer.</p>
<pre class="pod-block-code">say 1.7.round;          # OUTPUT: «2␤»
say 1.07.round(0.1);    # OUTPUT: «1.1␤»
say 21.round(10);       # OUTPUT: «20␤»</pre>
<p>Always rounds <strong>up</strong> if the number is at mid-point:</p>
<pre class="pod-block-code">say (−.5 ).round;       # OUTPUT: «0␤»
say ( .5 ).round;       # OUTPUT: «1␤»
say (−.55).round(.1);   # OUTPUT: «-0.5␤»
say ( .55).round(.1);   # OUTPUT: «0.6␤»</pre>
<p><strong>Pay attention</strong> to types when using this method, as ending up with the wrong type may affect the precision you seek to achieve. For <a href="/Documentable/integration-test/type/Real">Real</a> types, the type of the result is the type of the argument (<a href="/Documentable/integration-test/type/Complex">Complex</a> argument gets coerced to <a href="/Documentable/integration-test/type/Real">Real</a>, ending up a <a href="/Documentable/integration-test/type/Num">Num</a>). If rounding a <a href="/Documentable/integration-test/type/Complex">Complex</a>, the result is <a href="/Documentable/integration-test/type/Complex">Complex</a> as well, regardless of the type of the argument.</p>
<pre class="pod-block-code">9930972392403501.round(1)      .raku.say; # OUTPUT: «9930972392403501␤»
9930972392403501.round(1e0)    .raku.say; # OUTPUT: «9.9309723924035e+15␤»
9930972392403501.round(1e0).Int.raku.say; # OUTPUT: «9930972392403500␤»</pre>
<h2 id="(Cool)_routine_floor"><a href="/Documentable/integration-test/type/Cool#routine_floor">(Cool) routine floor</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub floor(Numeric(Cool))
multi method floor</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and rounds it downwards to the nearest integer.</p>
<pre class="pod-block-code">say &quot;1.99&quot;.floor;       # OUTPUT: «1␤»
say &quot;-1.9&quot;.floor;       # OUTPUT: «-2␤»
say 0.floor;            # OUTPUT: «0␤»</pre>
<h2 id="(Cool)_method_fmt"><a href="/Documentable/integration-test/type/Cool#method_fmt">(Cool) method fmt</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method fmt($format = &#39;%s&#39;)</pre>
<p>Uses <code>$format</code> to return a formatted representation of the invocant; equivalent to calling <a href="/Documentable/integration-test/routine/sprintf">sprintf</a> with <code>$format</code> as format and the invocant as the second argument. The <code>$format</code> will be coerced to <a href="/Documentable/integration-test/type/Stringy">Stringy</a> and defaults to <code>&#39;%s&#39;</code>.</p>
<p>For more information about formats strings, see <a href="/Documentable/integration-test/routine/sprintf">sprintf</a>.</p>
<pre class="pod-block-code">say 11.fmt(&#39;This Int equals %03d&#39;);         # OUTPUT: «This Int equals 011␤»
say &#39;16&#39;.fmt(&#39;Hexadecimal %x&#39;);             # OUTPUT: «Hexadecimal 10␤»</pre>
<h2 id="(Cool)_routine_ceiling"><a href="/Documentable/integration-test/type/Cool#routine_ceiling">(Cool) routine ceiling</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub ceiling(Numeric(Cool))
multi method ceiling</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and rounds it upwards to the nearest integer.</p>
<pre class="pod-block-code">say &quot;1&quot;.ceiling;        # OUTPUT: «1␤»
say &quot;-0.9&quot;.ceiling;     # OUTPUT: «0␤»
say &quot;42.1&quot;.ceiling;     # OUTPUT: «43␤»</pre>
<h2 id="(Cool)_routine_truncate"><a href="/Documentable/integration-test/type/Cool#routine_truncate">(Cool) routine truncate</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub truncate(Numeric(Cool))
multi method truncate()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a>, and rounds it towards zero.</p>
<pre class="pod-block-code">say 1.2.truncate;       # OUTPUT: «1␤»
say truncate -1.2;      # OUTPUT: «-1␤»</pre>
<h2 id="(Cool)_routine_ord"><a href="/Documentable/integration-test/type/Cool#routine_ord">(Cool) routine ord</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub ord(Str(Cool))
method ord()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the <a href="https://en.wikipedia.org/wiki/Code_point">Unicode code point</a> number of the first code point.</p>
<pre class="pod-block-code">say &#39;a&#39;.ord;            # OUTPUT: «97␤»</pre>
<p>The inverse operation is <a href="/Documentable/integration-test/routine/chr">chr</a>.</p>
<p>Mnemonic: returns an ordinal number</p>
<h2 id="(Cool)_method_path"><a href="/Documentable/integration-test/type/Cool#method_path">(Cool) method path</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method path()</pre>
<p><strong>DEPRECATED</strong>. <em>It&#39;s been deprecated as of the 6.d version. Will be removed in the next ones.</em></p>
<p>Stringifies the invocant and converts it to <a href="/Documentable/integration-test/type/IO::Path">IO::Path</a> object. Use the <a href="/Documentable/integration-test/routine/IO"><code>.IO method</code></a> instead.</p>
<h2 id="(Cool)_routine_chr"><a href="/Documentable/integration-test/type/Cool#routine_chr">(Cool) routine chr</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub chr(Int(Cool))
method chr()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Int">Int</a>, interprets it as a <a href="https://en.wikipedia.org/wiki/Code_point">Unicode code points</a>, and returns a <a href="/Documentable/integration-test/type/Str">string</a> made of that code point.</p>
<pre class="pod-block-code">say &#39;65&#39;.chr;       # OUTPUT: «A␤»</pre>
<p>The inverse operation is <a href="/Documentable/integration-test/routine/ord">ord</a>.</p>
<p>Mnemonic: turns an integer into a <em>char</em>acter.</p>
<h2 id="(Cool)_routine_chars"><a href="/Documentable/integration-test/type/Cool#routine_chars">(Cool) routine chars</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub chars(Cool $x)
multi sub chars(Str:D $x)
multi sub chars(str $x --&gt; int)
method chars(--&gt; Int:D)</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the number of characters in the string. Please note that on the JVM, you currently get codepoints instead of graphemes.</p>
<pre class="pod-block-code">say &#39;møp&#39;.chars;    # OUTPUT: «3␤»
say &#39;ã̷̠̬̊&#39;.chars;     # OUTPUT: «1␤»
say &#39;👨‍👩‍👧‍👦🏿&#39;.chars;    # OUTPUT: «1␤»</pre>
<p>If the string is native, the number of chars will be also returned as a native <code>int</code>.</p>
<p><a name="Documentable/integration-test/index-entry-Grapheme"></a></p>
<p>Graphemes are user visible characters. That is, this is what the user thinks of as a “character”.</p>
<p>Graphemes can contain more than one codepoint. Typically the number of graphemes and codepoints differs when <code>Prepend</code> or <code>Extend</code> characters are involved (also known as <a href="https://en.wikipedia.org/wiki/Combining_character">Combining characters</a>), but there are many other cases when this may happen. Another example is <code>\c[ZWJ]</code> (<a href="https://en.wikipedia.org/wiki/Zero-width_joiner">Zero-width joiner</a>).</p>
<p>You can check <code>Grapheme_Cluster_Break</code> property of a character in order to see how it is going to behave:</p>
<pre class="pod-block-code">say ‘ã̷̠̬̊’.uniprops(‘Grapheme_Cluster_Break’); # OUTPUT: «(Other Extend Extend Extend Extend)␤»
say ‘👨‍👩‍👧‍👦🏿’.uniprops(‘Grapheme_Cluster_Break’); # OUTPUT: «(E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ E_Modifier)␤»</pre>
<p>You can read more about graphemes in the <a href="https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">Unicode Standard</a>, which Raku tightly follows, using a method called <a href="/Documentable/integration-test/language/glossary#NFG">NFG, normal form graphemes</a> for efficiently representing them.</p>
<h2 id="(Cool)_routine_codes"><a href="/Documentable/integration-test/type/Cool#routine_codes">(Cool) routine codes</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub codes(Str(Cool))
method codes()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the number of <a href="https://en.wikipedia.org/wiki/Code_point">Unicode code points</a>.</p>
<pre class="pod-block-code">say &#39;møp&#39;.codes;    # OUTPUT: «3␤»</pre>
<p>The same result will be obtained with</p>
<pre class="pod-block-code">say +&#39;møp&#39;.ords;    # OUTPUT: «3␤»</pre>
<p><a href="/Documentable/integration-test/routine/ords">ords</a> first obtains the actual codepoints, so there might be a difference in speed.</p>
<h2 id="(Cool)_routine_flip"><a href="/Documentable/integration-test/type/Cool#routine_flip">(Cool) routine flip</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub flip(Cool $s --&gt; Str:D)
method flip()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns a reversed version.</p>
<pre class="pod-block-code">say 421.flip;       # OUTPUT: «124␤»</pre>
<h2 id="(Cool)_routine_trim"><a href="/Documentable/integration-test/type/Cool#routine_trim">(Cool) routine trim</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub trim(Str(Cool))
method trim()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the string with both leading and trailing whitespace stripped.</p>
<pre class="pod-block-code">my $stripped = &#39;  abc &#39;.trim;
say &quot;&lt;$stripped&gt;&quot;;          # OUTPUT: «&lt;abc&gt;␤»</pre>
<h2 id="(Cool)_routine_trim-leading"><a href="/Documentable/integration-test/type/Cool#routine_trim-leading">(Cool) routine trim-leading</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub trim-leading(Str(Cool))
method trim-leading()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the string with leading whitespace stripped.</p>
<pre class="pod-block-code">my $stripped = &#39;  abc &#39;.trim-leading;
say &quot;&lt;$stripped&gt;&quot;;          # OUTPUT: «&lt;abc &gt;␤»</pre>
<h2 id="(Cool)_routine_trim-trailing"><a href="/Documentable/integration-test/type/Cool#routine_trim-trailing">(Cool) routine trim-trailing</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub trim-trailing(Str(Cool))
method trim-trailing()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the string with trailing whitespace stripped.</p>
<pre class="pod-block-code">my $stripped = &#39;  abc &#39;.trim-trailing;
say &quot;&lt;$stripped&gt;&quot;;          # OUTPUT: «&lt;  abc&gt;␤»</pre>
<h2 id="(Cool)_routine_lc"><a href="/Documentable/integration-test/type/Cool#routine_lc">(Cool) routine lc</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub lc(Str(Cool))
method lc()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns it case-folded to lower case.</p>
<pre class="pod-block-code">say &quot;ABC&quot;.lc;       # OUTPUT: «abc␤»</pre>
<h2 id="(Cool)_routine_uc"><a href="/Documentable/integration-test/type/Cool#routine_uc">(Cool) routine uc</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub uc(Str(Cool))
method uc()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns it case-folded to upper case (capital letters).</p>
<pre class="pod-block-code">say &quot;Abc&quot;.uc;       # OUTPUT: «ABC␤»</pre>
<h2 id="(Cool)_routine_fc"><a href="/Documentable/integration-test/type/Cool#routine_fc">(Cool) routine fc</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub fc(Str(Cool))
method fc()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the result a Unicode &quot;case fold&quot; operation suitable for doing caseless string comparisons. (In general, the returned string is unlikely to be useful for any purpose other than comparison.)</p>
<pre class="pod-block-code">say &quot;groß&quot;.fc;       # OUTPUT: «gross␤»</pre>
<h2 id="(Cool)_routine_tc"><a href="/Documentable/integration-test/type/Cool#routine_tc">(Cool) routine tc</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub tc(Str(Cool))
method tc()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns it with the first letter case-folded to title case (or where not available, upper case).</p>
<pre class="pod-block-code">say &quot;abC&quot;.tc;       # OUTPUT: «AbC␤»</pre>
<h2 id="(Cool)_routine_tclc"><a href="/Documentable/integration-test/type/Cool#routine_tclc">(Cool) routine tclc</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub tclc(Str(Cool))
method tclc()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns it with the first letter case-folded to title case (or where not available, upper case), and the rest of the string case-folded to lower case.</p>
<pre class="pod-block-code">say &#39;abC&#39;.tclc;     # OUTPUT: «Abc␤»</pre>
<h2 id="(Cool)_routine_wordcase"><a href="/Documentable/integration-test/type/Cool#routine_wordcase">(Cool) routine wordcase</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub wordcase(Str(Cool) $input, :&amp;filter = &amp;tclc, Mu :$where = True)
method wordcase(:&amp;filter = &amp;tclc, Mu :$where = True)</pre>
<p>Coerces the invocant (or in sub form, the first argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and filters each word that smartmatches against <code>$where</code> through the <code>&amp;filter</code>. With the default filter (first character to upper case, rest to lower) and matcher (which accepts everything), this title-cases each word:</p>
<pre class="pod-block-code">say &quot;raku programming&quot;.wordcase;        # OUTPUT: «Raku Programming␤»</pre>
<p>With a matcher:</p>
<pre class="pod-block-code">say &quot;have fun working on perl&quot;.wordcase(:where({ .chars &gt; 3 }));
                                        # Have fun Working on Perl</pre>
<p>With a customer filter too:</p>
<pre class="pod-block-code">say &quot;have fun working on perl&quot;.wordcase(:filter(&amp;uc), :where({ .chars &gt; 3 }));
                                        # HAVE fun WORKING on PERL</pre>
<h2 id="(Cool)_routine_samecase"><a href="/Documentable/integration-test/type/Cool#routine_samecase">(Cool) routine samecase</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub samecase(Cool $string, Cool $pattern)
method samecase(Cool:D: Cool $pattern)</pre>
<p>Coerces the invocant (or in sub form, the first argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns a copy of <code>$string</code> with case information for each individual character changed according to <code>$pattern</code>.</p>
<p><strong>Note</strong>: The pattern string can contain three types of characters, i.e. uppercase, lowercase and caseless. For a given character in <code>$pattern</code> its case information determines the case of the corresponding character in the result.</p>
<p>If <code>$string</code> is longer than <code>$pattern</code>, the case information from the last character of <code>$pattern</code> is applied to the remaining characters of <code>$string</code>.</p>
<pre class="pod-block-code">say &quot;raKu&quot;.samecase(&quot;A_a_&quot;); # OUTPUT: «Raku␤»
say &quot;rAKU&quot;.samecase(&quot;Ab&quot;);   # OUTPUT: «Raku␤»</pre>
<h2 id="(Cool)_routine_uniprop"><a href="/Documentable/integration-test/type/Cool#routine_uniprop">(Cool) routine uniprop</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub uniprop(Str:D, |c)
multi sub uniprop(Int:D $code)
multi sub uniprop(Int:D $code, Stringy:D $propname)
multi method uniprop(|c)</pre>
<p>Returns the <a href="http://userguide.icu-project.org/strings/properties">unicode property</a> of the first character. If no property is specified returns the <a href="https://en.wikipedia.org/wiki/Unicode_character_property#General_Category">General Category</a>. Returns a Bool for Boolean properties. A <a href="/Documentable/integration-test/routine/uniprops">uniprops</a> routine can be used to get the property for every character in a string.</p>
<pre class="pod-block-code">say &#39;a&#39;.uniprop;               # OUTPUT: «Ll␤»
say &#39;1&#39;.uniprop;               # OUTPUT: «Nd␤»
say &#39;a&#39;.uniprop(&#39;Alphabetic&#39;); # OUTPUT: «True␤»
say &#39;1&#39;.uniprop(&#39;Alphabetic&#39;); # OUTPUT: «False␤»</pre>
<h2 id="(Cool)_sub_uniprops"><a href="/Documentable/integration-test/type/Cool#sub_uniprops">(Cool) sub uniprops</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub uniprops(Str:D $str, Stringy:D $propname = &quot;General_Category&quot;)</pre>
<p>Interprets the invocant as a <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the <a href="http://userguide.icu-project.org/strings/properties">unicode property</a> for each character as a Seq. If no property is specified returns the <a href="https://en.wikipedia.org/wiki/Unicode_character_property#General_Category">General Category</a>. Returns a Bool for Boolean properties. Similar to <a href="/Documentable/integration-test/routine/uniprop">uniprop</a>, but for each character in the passed string.</p>
<h2 id="(Cool)_routine_uniname"><a href="/Documentable/integration-test/type/Cool#routine_uniname">(Cool) routine uniname</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub uniname(Str(Cool) --&gt; Str)
method uniname(--&gt; Str)</pre>
<p>Interprets the invocant or first argument as a <a href="/Documentable/integration-test/type/Str">Str</a>, and returns the Unicode codepoint name of the first codepoint of the first character. See <a href="/Documentable/integration-test/routine/uninames">uninames</a> for a routine that works with multiple codepoints, and <a href="/Documentable/integration-test/routine/uniparse">uniparse</a> for the opposite direction.</p>
<pre class="pod-block-code"># Camelia in Unicode
say ‘»ö«’.uniname;
# OUTPUT: «&quot;RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK&quot;␤»
say &quot;Ḍ̇&quot;.uniname; # Note, doesn&#39;t show &quot;COMBINING DOT ABOVE&quot;
# OUTPUT: «&quot;LATIN CAPITAL LETTER D WITH DOT BELOW&quot;␤»

# Find the char with the longest Unicode name.
say (0..0x1FFFF).sort(*.uniname.chars)[*-1].chr.uniname;
# OUTPUT: ««ARABIC LIGATURE UIGHUR KIRGHIZ YEH WITH HAMZA ABOVE WITH ALEF MAKSURA INITIAL FORM␤»␤»</pre>
<h2 id="(Cool)_routine_uninames"><a href="/Documentable/integration-test/type/Cool#routine_uninames">(Cool) routine uninames</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub uninames(Str:D)
method uninames()</pre>
<p>Returns of a Seq of Unicode names for the all the codepoints in the Str provided.</p>
<pre class="pod-block-code">say ‘»ö«’.uninames.raku;
# OUTPUT: «(&quot;RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK&quot;, &quot;LATIN SMALL LETTER O WITH DIAERESIS&quot;, &quot;LEFT-POINTING DOUBLE ANGLE QUOTATION MARK&quot;).Seq␤»</pre>
<p>Note this example, which gets a Seq where each element is a Seq of all the codepoints in that character.</p>
<pre class="pod-block-code">say &quot;Ḍ̇&#39;oh&quot;.comb&gt;&gt;.uninames.raku;
# OUTPUT: «((&quot;LATIN CAPITAL LETTER D WITH DOT BELOW&quot;, &quot;COMBINING DOT ABOVE&quot;).Seq, (&quot;APOSTROPHE&quot;,).Seq, (&quot;LATIN SMALL LETTER O&quot;,).Seq, (&quot;LATIN SMALL LETTER H&quot;,).Seq)␤»</pre>
<p>See <a href="/Documentable/integration-test/routine/uniparse">uniparse</a> for the opposite direction.</p>
<h2 id="(Cool)_routine_unimatch"><a href="/Documentable/integration-test/type/Cool#routine_unimatch">(Cool) routine unimatch</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub unimatch(Str:D $str, |c)
multi unimatch(Int:D $code, Stringy:D $pvalname, Stringy:D $propname = $pvalname)</pre>
<p>Checks if the given integer codepoint or the first letter of the given string has a unicode property equal to the value you give. If you supply the Unicode property to be checked it will only return True if that property matches the given value.</p>
<pre class="pod-block-code">say unimatch &#39;A&#39;, &#39;Latin&#39;;           # OUTPUT: «True␤»
say unimatch &#39;A&#39;, &#39;Latin&#39;, &#39;Script&#39;; # OUTPUT: «True␤»
say unimatch &#39;A&#39;, &#39;Ll&#39;;              # OUTPUT: «False␤»</pre>
<p>The last property corresponds to &quot;lowercase letter&quot;, which explains why it returns false.</p>
<h2 id="(Cool)_routine_chop"><a href="/Documentable/integration-test/type/Cool#routine_chop">(Cool) routine chop</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub chop(Str(Cool))
method chop()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns it with the last character removed.</p>
<pre class="pod-block-code">say &#39;perl&#39;.chop;                        # OUTPUT: «per␤»</pre>
<h2 id="(Cool)_routine_chomp"><a href="/Documentable/integration-test/type/Cool#routine_chomp">(Cool) routine chomp</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub chomp(Str(Cool))
method chomp()</pre>
<p>Coerces the invocant (or in sub form, its argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns it with the last character removed, if it is a logical newline.</p>
<pre class="pod-block-code">say &#39;ab&#39;.chomp.chars;                   # OUTPUT: «2␤»
say &quot;a\n&quot;.chomp.chars;                  # OUTPUT: «1␤»</pre>
<h2 id="(Cool)_routine_substr"><a href="/Documentable/integration-test/type/Cool#routine_substr">(Cool) routine substr</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub substr(Str(Cool) $str, |c)
method substr(|c)</pre>
<p>Coerces the invocant (or in the sub form, the first argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and calls <a href="/Documentable/integration-test/type/Str#routine_substr">Str.substr</a> with the arguments.</p>
<h2 id="(Cool)_routine_substr-rw"><a href="/Documentable/integration-test/type/Cool#routine_substr-rw">(Cool) routine substr-rw</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method substr-rw(|) is rw
multi sub substr-rw(|) is rw</pre>
<p>Coerces the invocant (or in the sub form, the first argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and calls <a href="/Documentable/integration-test/type/Str#routine_substr-rw">Str.substr-rw</a> with the arguments.</p>
<h2 id="(Cool)_routine_ords"><a href="/Documentable/integration-test/type/Cool#routine_ords">(Cool) routine ords</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub ords(Str(Cool) $str)
method ords()</pre>
<p>Coerces the invocant (or in the sub form, the first argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns a list of Unicode codepoints for each character.</p>
<pre class="pod-block-code">say &quot;Camelia&quot;.ords;              # OUTPUT: «67 97 109 101 108 105 97␤»
say ords 10;                     # OUTPUT: «49 48␤»</pre>
<p>This is the list-returning version of <a href="/Documentable/integration-test/routine/ord">ord</a>. The inverse operation in <a href="/Documentable/integration-test/routine/chrs">chrs</a>. If you are only interested in the number of codepoints, <a href="/Documentable/integration-test/routine/codes">codes</a> is a possibly faster option.</p>
<h2 id="(Cool)_routine_chrs"><a href="/Documentable/integration-test/type/Cool#routine_chrs">(Cool) routine chrs</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub chrs(*@codepoints --&gt; Str:D)
method chrs()</pre>
<p>Coerces the invocant (or in the sub form, the argument list) to a list of integers, and returns the string created by interpreting each integer as a Unicode codepoint, and joining the characters.</p>
<pre class="pod-block-code">say &lt;67 97 109 101 108 105 97&gt;.chrs;   # OUTPUT: «Camelia␤»</pre>
<p>This is the list-input version of <a href="/Documentable/integration-test/routine/chr">chr</a>. The inverse operation is <a href="/Documentable/integration-test/routine/ords">ords</a>.</p>
<h2 id="(Cool)_routine_split"><a href="/Documentable/integration-test/type/Cool#routine_split">(Cool) routine split</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub    split(  Str:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
multi sub    split(Regex:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
multi sub    split(@delimiters, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
multi method split(  Str:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
multi method split(Regex:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
multi method split(@delimiters, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)</pre>
<p><a href="#fn-1" id="fn-ref-1">[1]</a></p>
<p>Coerces the invocant (or in the sub form, the second argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, and splits it into pieces based on delimiters found in the string.</p>
<p>If <code>$delimiter</code> is a string, it is searched for literally and not treated as a regex. You can also provide multiple delimiters by specifying them as a list; mixing Cool and Regex objects is OK.</p>
<pre class="pod-block-code">say split(&#39;;&#39;, &quot;a;b;c&quot;).raku;               # OUTPUT: «(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)␤»
say split(&#39;;&#39;, &quot;a;b;c&quot;, 2).raku;            # OUTPUT: «(&quot;a&quot;, &quot;b;c&quot;).Seq␤»

say split(&#39;;&#39;, &quot;a;b;c,d&quot;).raku;             # OUTPUT: «(&quot;a&quot;, &quot;b&quot;, &quot;c,d&quot;)␤»
say split(/\;/, &quot;a;b;c,d&quot;).raku;            # OUTPUT: «(&quot;a&quot;, &quot;b&quot;, &quot;c,d&quot;)␤»
say split(/&lt;[;,]&gt;/, &quot;a;b;c,d&quot;).raku;        # OUTPUT: «(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)␤»

say split([&#39;a&#39;, /b+/, 4], &#39;1a2bb345&#39;).raku; # OUTPUT: «(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;5&quot;)␤»</pre>
<p>By default, split omits the matches, and returns a list of only those parts of the string that did not match. Specifying one of the <code>:k, :v, :kv, :p</code> adverbs changes that. Think of the matches as a list that is interleaved with the non-matching parts.</p>
<p>The <code>:v</code> interleaves the values of that list, which will be either <a href="/Documentable/integration-test/type/Match">Match</a> objects, if a <a href="/Documentable/integration-test/type/Regex">Regex</a> was used as a matcher in the split, or <a href="/Documentable/integration-test/type/Str">Str</a> objects, if a <a href="/Documentable/integration-test/type/Cool">Cool</a> was used as matcher. If multiple delimiters are specified, <a href="/Documentable/integration-test/type/Match">Match</a> objects will be generated for all of them, unless <strong>all</strong> of the delimiters are <a href="/Documentable/integration-test/type/Cool">Cool</a>.</p>
<pre class="pod-block-code">say &#39;abc&#39;.split(/b/, :v);               # OUTPUT: «(a ｢b｣ c)␤»
say &#39;abc&#39;.split(&#39;b&#39;, :v);               # OUTPUT: «(a b c)␤»</pre>
<p><code>:k</code> interleaves the keys, that is, the indexes:</p>
<pre class="pod-block-code">say &#39;abc&#39;.split(/b/, :k);               # OUTPUT: «(a 0 c)␤»</pre>
<p><code>:kv</code> adds both indexes and matches:</p>
<pre class="pod-block-code">say &#39;abc&#39;.split(/b/, :kv);               # OUTPUT: «(a 0 ｢b｣ c)␤»</pre>
<p>and <code>:p</code> adds them as <a href="/Documentable/integration-test/type/Pair">Pairs</a>, using the same types for values as <code>:v</code> does:</p>
<pre class="pod-block-code">say &#39;abc&#39;.split(/b/, :p);               # OUTPUT: «(a 0 =&gt; ｢b｣ c)␤»
say &#39;abc&#39;.split(&#39;b&#39;, :p);               # OUTPUT: «(a 0 =&gt; b c)␤»</pre>
<p>You can only use one of the <code>:k, :v, :kv, :p</code> adverbs in a single call to <code>split</code>.</p>
<p>Note that empty chunks are not removed from the result list. For that behavior, use the <code>:skip-empty</code> named argument:</p>
<pre class="pod-block-code">say (&quot;f,,b,c,d&quot;.split: /&quot;,&quot;/             ).raku;  # OUTPUT: «(&quot;f&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)␤»
say (&quot;f,,b,c,d&quot;.split: /&quot;,&quot;/, :skip-empty).raku;  # OUTPUT: «(&quot;f&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)␤»</pre>
<h2 id="(Cool)_routine_lines"><a href="/Documentable/integration-test/type/Cool#routine_lines">(Cool) routine lines</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">sub lines(Str(Cool))
method lines()</pre>
<p>Coerces the invocant (and in sub form, the argument) to <a href="/Documentable/integration-test/type/Str">Str</a>, decomposes it into lines (with the newline characters stripped), and returns the list of lines.</p>
<pre class="pod-block-code">say lines(&quot;a\nb\n&quot;).join(&#39;|&#39;);          # OUTPUT: «a|b␤»
say &quot;some\nmore\nlines&quot;.lines.elems;    # OUTPUT: «3␤»</pre>
<p>This method can be used as part of an <code>IO::Path</code> to process a file line-by-line, since <code>IO::Path</code> objects inherit from <code>Cool</code>, e.g.:</p>
<pre class="pod-block-code">for &#39;huge-csv&#39;.IO.lines -&gt; $line {
    # Do something with $line
}

# or if you&#39;ll be processing later
my @lines = &#39;huge-csv&#39;.IO.lines;
</pre>
<p>Without any arguments, sub <code>lines</code> operates on <code>$*ARGFILES</code>, which defaults to <code>$*IN</code> in the absence of any filenames.</p>
<p>To modify values in place use <code>is copy</code> to force a writable container.</p>
<pre class="pod-block-code">for $*IN.lines -&gt; $_ is copy { s/(\w+)/{$0 ~ $0}/; .say }
</pre>
<h2 id="(Cool)_method_words"><a href="/Documentable/integration-test/type/Cool#method_words">(Cool) method words</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method words(Cool:D: |c)</pre>
<p>Coerces the invocant (or first argument, if it is called as a subroutine) to <a href="/Documentable/integration-test/type/Str">Str</a>, and returns a list of words that make up the string. Check <a href="/Documentable/integration-test/type/Str#routine_words"><code>Str.words</code></a> for additional arguments and its meaning.</p>
<pre class="pod-block-code">say &lt;The quick brown fox&gt;.words.join(&#39;|&#39;);     # OUTPUT: «The|quick|brown|fox␤»
say &lt;The quick brown fox&gt;.words(2).join(&#39;|&#39;);  # OUTPUT: «The|quick␤»
</pre>
<p><code>Cool</code> is the base class for many other classes, and some of them, like <a href="/Documentable/integration-test/type/Match">Match</a>, can be converted to a string. This is what happens in this case:</p>
<pre class="pod-block-code">say ( &quot;easy come, easy goes&quot; ~~ m:g/(ea\w+)/).words(Inf);
# OUTPUT: «(easy easy)␤»
say words( &quot;easy come, easy goes&quot; ~~ m:g/(ea\w+)/ , ∞);
# OUTPUT: «(easy easy)␤»</pre>
<p>The example above illustrates two of the ways <code>words</code> can be invoked, with the first argument turned into invocant by its signature. Of course, <code>Inf</code> is the default value of the second argument, so in both cases (and forms) it can be simply omitted.</p>
<p>Only whitespace (including no-break space) counts as word boundaries</p>
<pre class="pod-block-code">say &lt;Flying on a Boeing&nbsp;747&gt;.words.join(&#39;|&#39;);  # OUTPUT: «Flying|on|a|Boeing|747␤»</pre>
<p>In this case, &quot;Boeing&nbsp;747&quot; includes a (visible only in the source) no-break space; <code>words</code> still splits the (resulting) <code>Str</code> on it, even if the original array only had 4 elements:</p>
<pre class="pod-block-code">say &lt;Flying on a Boeing&nbsp;747&gt;.join(&#39;|&#39;);        # OUTPUT: «Flying|on|a|Boeing&nbsp;747␤»</pre>
<p>Please see <a href="/Documentable/integration-test/type/Str#routine_words"><code>Str.words</code></a> for more examples and ways to invoke it.</p>
<h2 id="(Cool)_routine_comb"><a href="/Documentable/integration-test/type/Cool#routine_comb">(Cool) routine comb</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub comb(Regex $matcher, Cool $input, $limit = *)
multi sub comb(Str $matcher, Cool $input, $limit = *)
multi sub comb(Int:D $size, Cool $input, $limit = *)
multi method comb(|c)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Seq">Seq</a> of all (or if supplied, at most <code>$limit</code>) matches of the invocant (method form) or the second argument (sub form) against the <a href="/Documentable/integration-test/type/Regex">Regex</a>, string or defined number.</p>
<pre class="pod-block-code">say &quot;6 or 12&quot;.comb(/\d+/).join(&quot;, &quot;);           # OUTPUT: «6, 12␤»
say comb(/\d &lt;[1..9]&gt; /,(11..30)).join(&quot;--&quot;);
# OUTPUT:
# «11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29␤»</pre>
<p>The second statement exemplifies the first form of <code>comb</code>, with a <code>Regex</code> that excludes multiples of ten, and a <code>Range</code> (which is <code>Cool</code>) as <code>$input</code>. <code>comb</code> stringifies the <code>Range</code> before applying <code>.comb</code> on the resulting string. Check <a href="/Documentable/integration-test/type/Str#routine_comb"><code>Str.comb</code></a> for its effect on different kind of input strings. When the first argument is an integer, it indicates the (maximum) size of the chunks the input is going to be divided in</p>
<pre class="pod-block-code">say comb(3,[3,33,333,3333]).join(&quot;*&quot;);  # OUTPUT: «3 3*3 3*33 *333*3␤»</pre>
<p>In this case the input is a list, which after transformation to <code>Str</code> (which includes the spaces) is divided in chunks of size 3.</p>
<h2 id="(Cool)_method_contains"><a href="/Documentable/integration-test/type/Cool#method_contains">(Cool) method contains</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method contains(Cool:D: |c)</pre>
<p>Coerces the invocant to a <a href="/Documentable/integration-test/type/Str"><code>Str</code></a>, and calls <a href="/Documentable/integration-test/type/Str#method_contains"><code>Str.contains</code></a> on it. Please refer to that version of the method for arguments and general syntax.</p>
<pre class="pod-block-code">say 123.contains(&quot;2&quot;)# OUTPUT: «True␤»</pre>
<p>Since <a href="/Documentable/integration-test/type/Int">Int</a> is a subclass of <code>Cool</code>, <code>123</code> is coerced to a <code>Str</code> and then <code>contains</code> is called on it.</p>
<pre class="pod-block-code">say (1,1, * + * … * &gt; 250).contains(233)# OUTPUT: «True␤»</pre>
<p><a href="/Documentable/integration-test/type/Seq">Seq</a>s are also subclasses of <code>Cool</code>, and they are stringified to a comma-separated form. In this case we are also using an <code>Int</code>, which is going to be stringified also; <code>&quot;233&quot;</code> is included in that sequence, so it returns <code>True</code>. Please note that this sequence is not lazy; the stringification of lazy sequences does not include each and every one of their components for obvious reasons.</p>
<h2 id="(Cool)_routine_index"><a href="/Documentable/integration-test/type/Cool#routine_index">(Cool) routine index</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub index(Cool:D $s, Cool:D $needle, :i(:$ignorecase), :m(:$ignoremark) --&gt; Int:D)
multi sub index(Cool:D $s, Cool:D $needle, Cool:D $pos, :i(:$ignorecase), :m(:$ignoremark) --&gt; Int:D)
multi method index(Cool:D: Cool:D $needle --&gt; Int:D)
multi method index(Cool:D: Cool:D $needle, :m(:$ignoremark)! --&gt; Int:D)
multi method index(Cool:D: Cool:D $needle, :i(:$ignorecase)!, :m(:$ignoremark) --&gt; Int:D)
multi method index(Cool:D: Cool:D $needle, Cool:D $pos --&gt; Int:D)
multi method index(Cool:D: Cool:D $needle, Cool:D $pos, :m(:$ignoremark)!  --&gt; Int:D)
multi method index(Cool:D: Cool:D $needle, Cool:D $pos, :i(:$ignorecase)!, :m(:$ignoremark) --&gt; Int:D)</pre>
<p>Coerces the first two arguments (in method form, also counting the invocant) to a <a href="/Documentable/integration-test/type/Str">Str</a>, and searches for <code>$needle</code> in the string <code>$s</code> starting from <code>$pos</code>. It returns the offset into the string where <code>$needle</code> was found, and <code>Nil</code> if it was not found.</p>
<p>See <a href="/Documentable/integration-test/type/Str#routine_index">the documentation in type Str</a> for examples.</p>
<h2 id="(Cool)_routine_rindex"><a href="/Documentable/integration-test/type/Cool#routine_rindex">(Cool) routine rindex</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub rindex(Cool:D $s, Cool:D $needle --&gt; Int:D)
multi sub rindex(Cool:D $s, Cool:D $needle, Cool:D $pos --&gt; Int:D)
multi method rindex(Cool:D: Cool:D $needle --&gt; Int:D)
multi method rindex(Cool:D: Cool:D $needle, Cool:D $pos --&gt; Int:D)</pre>
<p>Coerces the first two arguments (including the invocant in method form) to <a href="/Documentable/integration-test/type/Str">Str</a> and <code>$pos</code> to <a href="/Documentable/integration-test/type/Int">Int</a>, and returns the last position of <code>$needle</code> in the string not after <code>$pos</code>. Returns <code>Nil</code> if <code>$needle</code> wasn&#39;t found.</p>
<p>See <a href="/Documentable/integration-test/type/Str#routine_rindex">the documentation in type Str</a> for examples.</p>
<h2 id="(Cool)_method_match"><a href="/Documentable/integration-test/type/Cool#method_match">(Cool) method match</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method match(Cool:D: $target, *%adverbs)</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Str">Str</a> and calls the method <a href="/Documentable/integration-test/type/Str#method_match">match</a> on it.</p>
<h2 id="(Cool)_routine_roots"><a href="/Documentable/integration-test/type/Cool#routine_roots">(Cool) routine roots</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub roots(Numeric(Cool) $x, Int(Cool) $n)
multi method roots(Int(Cool) $n)</pre>
<p>Coerces the first argument (and in method form, the invocant) to <a href="/Documentable/integration-test/type/Numeric">Numeric</a> and the second (<code>$n</code>) to <a href="/Documentable/integration-test/type/Int">Int</a>, and produces a list of <code>$n</code> <a href="/Documentable/integration-test/type/Complex">Complex</a> <code>$n</code>-roots, which means numbers that, raised to the <code>$n</code>th power, approximately produce the original number.</p>
<p>For example</p>
<pre class="pod-block-code">my $original = 16;
my @roots = $original.roots(4);
say @roots;

for @roots -&gt; $r {
    say abs($r ** 4 - $original);
}

# OUTPUT:«2+0i 1.22464679914735e-16+2i -2+2.44929359829471e-16i -3.67394039744206e-16-2i␤»
# OUTPUT:«1.77635683940025e-15␤»
# OUTPUT:«4.30267170434156e-15␤»
# OUTPUT:«8.03651692704705e-15␤»
# OUTPUT:«1.04441561648202e-14␤»
</pre>
<h2 id="(Cool)_method_match"><a href="/Documentable/integration-test/type/Cool#method_match">(Cool) method match</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method match(|)</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Stringy">Stringy</a> and calls <a href="/Documentable/integration-test/type/Str#method_match">Str.match</a>.</p>
<h2 id="(Cool)_method_subst"><a href="/Documentable/integration-test/type/Cool#method_subst">(Cool) method subst</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method subst(|)</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Stringy">Stringy</a> and calls <a href="/Documentable/integration-test/type/Str#method_subst">Str.subst</a>.</p>
<h2 id="(Cool)_method_trans"><a href="/Documentable/integration-test/type/Cool#method_trans">(Cool) method trans</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method trans(|)</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/Str">Str</a> and calls <a href="/Documentable/integration-test/type/Str#method_trans">Str.trans</a></p>
<h2 id="(Cool)_method_IO"><a href="/Documentable/integration-test/type/Cool#method_IO">(Cool) method IO</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method IO(--&gt; IO::Path:D)</pre>
<p>Coerces the invocant to <a href="/Documentable/integration-test/type/IO::Path">IO::Path</a>.</p>
<pre class="pod-block-code">.say for &#39;.&#39;.IO.dir;        # gives a directory listing
</pre>

        </div>
    </div>

    <aside><ol start="1">
<li><a href="#fn-ref-1" id="fn-1">[↑]</a> <em>the <a href="/Documentable/integration-test/routine/comb">comb</a> routine is a much better choice for many tasks that in other languages are handled by the <code>split</code>.</em> </li>
</ol></aside>


    <footer class="pretty-box yellow">
        <p>
            Generated from <a href="https://github.com/Raku/doc/tree/master/docs/Type/IO/Path/Unix.pod6">https://github.com/Raku/doc/tree/master/docs/Type/IO/Path/Unix.pod6</a>.
        </p>
        <p>
            This is a work in progress to document Raku (formerly known as Perl 6), and
            known to be incomplete.
        </p>
        <p>
            <a href="https://github.com/raku/doc/blob/master/CONTRIBUTING.md#reporting-bugs">
                Please report any issues
            </a>
            Your contribution is appreciated.
        </p>
        <p>
            This documentation is provided under the terms of the
            <a href="https://raw.githubusercontent.com/raku/doc/master/LICENSE">
                Artistic License 2.0
            </a>. The Camelia image is
            <a href="https://raw.githubusercontent.com/raku/mu/master/misc/camelia.txt">
                copyright © 2009 by Larry Wall.
            </a>
            <!-- CREDITS -->
            <!--External Link Image by Zapyon, CCA-SA 4.0. Derived from Wikimedia Foundation https://commons.wikimedia.org/wiki/File:External-link-04-bold-12x12.svg -->
        </p>
    </footer>

    <script type="text/javascript" src="/Documentable/integration-test/js/app.js?v=1"></script>
    <script type="text/javascript" src="/Documentable/integration-test/js/search.js?v=3"></script>
</body>
</html>

